:: About Graph Complements
::  by Sebastian Koch
::
:: Received December 30, 2019
:: Copyright (c) 2019-2021 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSET_1, RELAT_1, FUNCT_1, XBOOLE_0, TARSKI, SUBSET_1,
      FINSEQ_1, NAT_1, FUNCT_4, FUNCOP_1, ZFMISC_1, CARD_1, ARYTM_3, CARD_2,
      ORDINAL2, XXREAL_0, PBOOLE, GLIB_000, RING_3, PARTFUN1, FUNCT_2, CHORD,
      SCMYCIEL, REWRITE1, ARYTM_1, GLIB_006, GLIB_007, GLIB_009, GLIB_010,
      GLIB_011, GLIB_012, MCART_1, WAYBEL_0, MOD_4, RELAT_2, GRAPH_1, GLIB_001,
      ORDINAL4, ABIAN, SGRAPH1, RFINSEQ, FINSEQ_8, GRAPH_2;
 notations TARSKI, XBOOLE_0, XTUPLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1,
      ORDINAL1, RELSET_1, PARTFUN1, FUNCT_2, BINOP_1, DOMAIN_1, FUNCOP_1,
      ENUMSET1, FUNCT_4, FINSET_1, CARD_1, PBOOLE, NUMBERS, XCMPLX_0, XXREAL_0,
      XREAL_0, NAT_1, INT_1, VALUED_0, NAT_D, CARD_2, FINSEQ_1, NEWTON, ABIAN,
      RFINSEQ, FINSEQ_6, FINSEQ_8, GRAPH_2, GLIB_000, GLIB_001, GLIB_002,
      CHORD, GLIB_006, GLIB_007, GLIB_008, GLIB_009, GLIB_010, GLIB_011;
 constructors DOMAIN_1, FUNCT_4, XXREAL_0, NAT_1, NAT_D, BINOP_2, CARD_2,
      FINSEQ_4, PBOOLE, ORDINAL3, WELLORD2, PARTFUN1, RELSET_1, GLIB_000,
      NEWTON, XTUPLE_0, CHORD, GLIB_002, GLIB_006, GLIB_007, GLIB_008,
      GLIB_009, GLIB_010, GLIB_011, GLIB_001, ABIAN, BINOP_1, FINSOP_1,
      RVSUM_1, FINSEQ_5, GRAPH_5, FUNCT_2, FIB_NUM2, FINSEQ_8, HELLY, FUNCT_3,
      GRAPH_2, RFINSEQ, FINSEQ_6, FUNCT_7, FINSEQ_1, SUBSET_1, RELAT_1,
      ENUMSET1, ORDINAL1, INT_1, XREAL_0, XCMPLX_0, FINSET_1, CARD_3, FUNCT_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      XREAL_0, NAT_1, CARD_1, FINSEQ_1, RELSET_1, GLIB_000, CHORD, GLIB_006,
      GLIB_007, GLIB_009, GLIB_008, GLIB_010, GLIB_011, XTUPLE_0, ABIAN,
      GLIB_001, MEMBERED, INT_1, MSAFREE5;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 equalities ORDINAL1, GLIB_000, GLIB_010, FUNCOP_1;
 theorems RELSET_1, GLIB_000, CHORD, GLIB_002, GLIB_006, GLIB_007, GLIB_009,
      GLIB_010, GLIB_011, TARSKI, ZFMISC_1, FUNCT_1, XBOOLE_0, XBOOLE_1,
      FUNCT_2, XREGULAR, PARTFUN1, FUNCT_4, GLIB_001, NECKLACE, RELAT_1,
      CARD_1, CARD_2, FUNCOP_1, FINSEQ_1, FINSEQ_3, XXREAL_0, GLIB_008,
      XREAL_1, NAT_1, ENUMSET1, ORDINAL1, FINSEQ_6, FINSEQ_8, RFINSEQ,
      FINSEQ_5, GLIBPRE0;
 schemes FUNCT_1, NAT_1, SUBSET_1;

begin :: Loopfull Graphs

definition
  let G be _Graph;
  attr G is loopfull means :: or reflexive
  :Def1:
  for v being Vertex of G ex e being object st e Joins v,v,G;
end;

theorem Th1:
  for G being _Graph holds G is loopfull iff
    for v being Vertex of G ex e being object st e DJoins v,v,G
proof
  let G be _Graph;
  hereby
    assume A1: G is loopfull;
    let v be Vertex of G;
    consider e being object such that
      A2: e Joins v,v,G by A1;
    take e;
    thus e DJoins v,v,G by A2, GLIB_000:16;
  end;
  assume A3: for v being Vertex of G ex e being object st e DJoins v,v,G;
  let v be Vertex of G;
  consider e being object such that
    A4: e DJoins v,v,G by A3;
  take e;
  thus e Joins v,v,G by A4, GLIB_000:16;
end;

theorem
  for G being _Graph holds G is loopfull iff
    for v being Vertex of G holds v,v are_adjacent
proof
  let G be _Graph;
  hereby
    assume A1: G is loopfull;
    let v be Vertex of G;
    consider e being object such that
      A2: e Joins v,v,G by A1;
    thus v,v are_adjacent by A2, CHORD:def 3;
  end;
  assume A3: for v being Vertex of G holds v,v are_adjacent;
  let v be Vertex of G;
  consider e being object such that
    A4: e Joins v,v,G by A3, CHORD:def 3;
  take e;
  thus thesis by A4;
end;

registration
  cluster loopfull -> non loopless for _Graph;
  coherence
  proof
    let G be _Graph;
    assume G is loopfull;
    then consider e being object such that
      A1: e Joins the Vertex of G,the Vertex of G,G;
    thus thesis by A1, GLIB_000:18;
  end;
  cluster _trivial non loopless -> loopfull for _Graph;
  coherence
  proof
    let G be _Graph;
    assume A2: G is _trivial non loopless;
    let v be Vertex of G;
    consider v0 being Vertex of G such that
      A3: the_Vertices_of G = {v0} by A2, GLIB_000:22;
    A4: v = v0 by A3, TARSKI:def 1;
    consider v9 being object such that
      A5: ex e being object st e Joins v9,v9,G by A2, GLIB_000:18;
    consider e being object such that
      A6: e Joins v9,v9,G by A5;
    take e;
    v9 in the_Vertices_of G by A6, GLIB_000:13;
    then v9 = v0 by A3, TARSKI:def 1;
    hence e Joins v,v,G by A4, A6;
  end;
  cluster loopfull complete for _Graph;
  existence
  proof
    set G2 = the _trivial _Graph;
    set G1 = the addEdge of
      G2,the Vertex of G2,the_Edges_of G2,the Vertex of G2;
    take G1;
    thus thesis;
  end;
  cluster non loopfull for _Graph;
  existence
  proof
    take the loopless _Graph;
    thus thesis;
  end;
end;

theorem Th3:
  for G1 being _Graph, E being set, G2 being reverseEdgeDirections of G1, E
  holds G1 is loopfull iff G2 is loopfull
proof
  let G1 be _Graph, E be set, G2 be reverseEdgeDirections of G1, E;
  hereby
    assume A1: G1 is loopfull;
    now
      let v be Vertex of G2;
      v is Vertex of G1 by GLIB_007:4;
      then consider e being object such that
        A2: e Joins v,v,G1 by A1;
      take e;
      thus e Joins v,v,G2 by A2, GLIB_007:9;
    end;
    hence G2 is loopfull;
  end;
  assume A3: G2 is loopfull;
  now
    let v be Vertex of G1;
    v is Vertex of G2 by GLIB_007:4;
    then consider e being object such that
      A4: e Joins v,v,G2 by A3;
    take e;
    thus e Joins v,v,G1 by A4, GLIB_007:9;
  end;
  hence G1 is loopfull;
end;

registration
  let G be loopfull _Graph, E be set;
  cluster -> loopfull for reverseEdgeDirections of G, E;
  coherence by Th3;
end;

registration
  let G be non loopfull _Graph, E be set;
  cluster -> non loopfull for reverseEdgeDirections of G, E;
  coherence by Th3;
end;

theorem Th4:
  for G1, G2 being _Graph st G1 == G2
  holds G1 is loopfull implies G2 is loopfull
proof
  let G1, G2 be _Graph;
  assume G1 == G2;
  then G2 is reverseEdgeDirections of G1, {} by GLIB_009:42;
  hence thesis;
end;

theorem Th5:
  for G2 being loopfull _Graph, G1 being Supergraph of G2
  st the_Vertices_of G1 = the_Vertices_of G2 holds G1 is loopfull
proof
  let G2 be loopfull _Graph, G1 be Supergraph of G2;
  assume A1: the_Vertices_of G1 = the_Vertices_of G2;
  let v be Vertex of G1;
  consider e being object such that
    A2: e Joins v,v,G2 by A1, Def1;
  take e;
  thus e Joins v,v,G1 by A2, GLIB_006:70;
end;

theorem Th6:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st rng F_V = the_Vertices_of G2 & G1.loops() c= dom F_E
  holds G1 is loopfull implies G2 is loopfull
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: rng F_V = the_Vertices_of G2 & G1.loops() c= dom F_E;
  assume A2: G1 is loopfull;
  now
    let v be Vertex of G2;
    consider v0 being object such that
      A3: v0 in dom F_V & F_V.v0 = v by A1, FUNCT_1:def 3;
    consider e0 being object such that
      A4: e0 Joins v0,v0,G1 by A2, A3;
    reconsider e = F_E.e0 as object;
    take e;
    e0 in G1.loops() by A4, GLIB_009:def 2;
    hence e Joins v,v,G2 by A1, A3, A4, GLIB_010:4;
  end;
  hence G2 is loopfull;
end;

theorem Th7:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is total onto holds G1 is loopfull implies G2 is loopfull
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is total onto;
  G1.loops() c= the_Edges_of G1;
  then G1.loops() c= dom F_E & rng F_V = the_Vertices_of G2
    by A1, GLIB_010:def 11, GLIB_010:def 12;
  hence thesis by Th6;
end;

theorem Th8:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is semi-continuous & dom F_V=the_Vertices_of G1 & G2.loops() c= rng F_E
  holds G2 is loopfull implies G1 is loopfull
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume that
    A1: F is semi-continuous and
    A2: dom F_V = the_Vertices_of G1 & G2.loops() c= rng F_E and
    A3: G2 is loopfull;
  now
    let v be Vertex of G1;
    F_V.v in rng F_V by A2, FUNCT_1:3;
    then consider e being object such that
      A4: e Joins F_V.v,F_V.v,G2 by A3;
    e in G2.loops() by A4, GLIB_009:def 2;
    then consider e0 being object such that
      A5: e0 in dom F_E & F_E.e0 = e by A2, FUNCT_1:def 3;
    take e0;
    thus e0 Joins v,v,G1 by A1, A2, A4, A5, GLIB_010:def 15;
  end;
  hence G1 is loopfull;
end;

theorem Th9:
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is total onto semi-continuous
  holds G2 is loopfull implies G1 is loopfull
proof
  let G1, G2 be _Graph, F be PGraphMapping of G1, G2;
  assume A1: F is total onto semi-continuous;
  G2.loops() c= the_Edges_of G2;
  then dom F_V=the_Vertices_of G1 & G2.loops() c= rng F_E
    by A1, GLIB_010:def 11, GLIB_010:def 12;
  hence thesis by A1, Th8;
end;

theorem
  for G1, G2 being _Graph, F being PGraphMapping of G1, G2
  st F is isomorphism holds G1 is loopfull iff G2 is loopfull by Th7, Th9;

registration
  let G be loopfull _Graph, V be set;
  cluster -> loopfull for inducedSubgraph of G, V;
  coherence
  proof
    let G2 be inducedSubgraph of G, V;
    per cases;
    suppose A1: V is non empty Subset of the_Vertices_of G;
      let v be Vertex of G2;
      v in the_Vertices_of G2;
      then reconsider v0 = v as Vertex of G;
      consider e being object such that
        A2: e Joins v0,v0,G by Def1;
      take e;
      the_Vertices_of G2 = V by A1, GLIB_000:def 37;
      then e in G.edgesBetween(V) by A2, GLIB_000:32;
      then e in the_Edges_of G2 &
        e is set & v is set by A1, GLIB_000:def 37;
      hence e Joins v,v,G2 by A2, GLIB_000:73;
    end;
    suppose not V is non empty Subset of the_Vertices_of G;
      then G2 == G by GLIB_000:def 37;
      hence thesis by Th4;
    end;
  end;
  cluster -> loopfull for removeVertices of G, V;
  coherence;
  cluster -> loopfull for removeVertex of G, V;
  coherence;
end;

registration
  let G be non loopfull _Graph;
  cluster -> non loopfull for spanning Subgraph of G;
  coherence
  proof
    let G2 be spanning Subgraph of G;
    assume A1: G2 is loopfull;
    now
      let v be Vertex of G;
      v is Vertex of G2 by GLIB_000:def 33;
      then consider e being object such that
        A2: e Joins v,v,G2 by A1;
      take e;
      thus e Joins v,v,G by A2, GLIB_000:72;
    end;
    hence contradiction by Def1;
  end;
  let E be set;
  cluster -> non loopfull for inducedSubgraph of G, the_Vertices_of G, E;
  coherence
  proof
    let G2 be inducedSubgraph of G, the_Vertices_of G, E;
    per cases;
    suppose E is Subset of the_Edges_of G;
      hence thesis;
    end;
    suppose not E is Subset of the_Edges_of G;
      then not E c= G.edgesBetween(the_Vertices_of G) by GLIB_000:34;
      then G == G2 by GLIB_000:def 37;
      hence thesis by Th4;
    end;
  end;
  cluster -> non loopfull for removeEdges of G, E;
  coherence;
  cluster -> non loopfull for removeEdge of G, E;
  coherence;
end;

theorem Th11:
  for G2 being _Graph, V being set, G1 being addVertices of G2, V
  st V \ the_Vertices_of G2 <> {} holds G1 is non loopfull
proof
  let G2 be _Graph, V be set, G1 be addVertices of G2, V;
  assume V \ the_Vertices_of G2 <> {};
  then consider v being object such that
    A1: v in V \ the_Vertices_of G2 by XBOOLE_0:def 1;
  reconsider v as Vertex of G1 by A1, GLIB_006:86;
  v.edgesInOut() = {} by A1, GLIB_006:88, GLIB_000:def 49;
  then for e being object holds not e Joins v,v,G1 by GLIB_000:62;
  hence thesis;
end;

registration
  let G be non loopfull _Graph, V be set;
  cluster -> non loopfull for addVertices of G, V;
  coherence
  proof
    let G1 be addVertices of G, V;
    per cases;
    suppose V \ the_Vertices_of G <> {};
      hence thesis by Th11;
    end;
    suppose V \ the_Vertices_of G = {};
      then G == G1 by GLIB_006:78, XBOOLE_1:37;
      hence thesis by Th4;
    end;
  end;
end;

registration
  let G be loopfull _Graph, v,e,w be object;
  cluster -> loopfull for addEdge of G,v,e,w;
  coherence
  proof
    let G1 be addEdge of G,v,e,w;
    per cases;
    suppose A1: v is Vertex of G & w is Vertex of G & not e in the_Edges_of G;
      reconsider e as set by TARSKI:1;
      G is removeEdge of G1,e by A1, GLIB_006:108;
      hence thesis;
    end;
    suppose not(v is Vertex of G & w is Vertex of G & not e in the_Edges_of G);
      then G == G1 by GLIB_006:def 11;
      hence thesis by Th4;
    end;
  end;
end;

theorem Th12:
  for G2 being _Graph, v being Vertex of G2, e,w being object
  for G1 being addAdjVertex of G2,v,e,w
  st not e in the_Edges_of G2 & not w in the_Vertices_of G2
  holds G1 is non loopfull
proof
  let G2 be _Graph, v be Vertex of G2, e,w be object;
  let G1 be addAdjVertex of G2,v,e,w;
  assume A1: not e in the_Edges_of G2 & not w in the_Vertices_of G2;
  then reconsider w as Vertex of G1 by GLIB_006:129;
  v <> w by A1;
  then for e being object holds not e Joins w,w,G1 by A1, GLIB_006:133;
  hence thesis;
end;

theorem Th13:
  for G2 being _Graph, v,e being object, w being Vertex of G2
  for G1 being addAdjVertex of G2,v,e,w
  st not e in the_Edges_of G2 & not v in the_Vertices_of G2
  holds G1 is non loopfull
proof
  let G2 be _Graph, v,e be object, w be Vertex of G2;
  let G1 be addAdjVertex of G2,v,e,w;
  assume A1: not e in the_Edges_of G2 & not v in the_Vertices_of G2;
  then reconsider v as Vertex of G1 by GLIB_006:130;
  v <> w by A1;
  then for e being object holds not e Joins v,v,G1 by A1, GLIB_006:134;
  hence thesis;
end;

registration
  let G be non loopfull _Graph, v,e,w be object;
  cluster -> non loopfull for addAdjVertex of G,v,e,w;
  coherence
  proof
    let G1 be addAdjVertex of G,v,e,w;
    per cases;
    suppose v in the_Vertices_of G & not w in the_Vertices_of G &
        not e in the_Edges_of G;
      hence thesis by Th12;
    end;
    suppose not v in the_Vertices_of G & w in the_Vertices_of G &
        not e in the_Edges_of G;
      hence thesis by Th13;
    end;
    suppose not(v in the_Vertices_of G & not w in the_Vertices_of G &
          not e in the_Edges_of G) &
        not(not v in the_Vertices_of G & w in the_Vertices_of G &
          not e in the_Edges_of G);
      then G1 == G by GLIB_006:def 12;
      hence thesis by Th4;
    end;
  end;
end;

theorem Th14:
  for G2 being _Graph, v being object, V being Subset of the_Vertices_of G2
  for G1 being addAdjVertexAll of G2,v,V st not v in the_Vertices_of G2
  holds G1 is non loopfull
proof
  let G2 be _Graph, v be object, V be Subset of the_Vertices_of G2;
  let G1 be addAdjVertexAll of G2,v,V;
  assume A1: not v in the_Vertices_of G2;
  then reconsider v as Vertex of G1 by GLIB_007:50;
  for e being object holds not e Joins v,v,G1 by A1, GLIB_007:def 4;
  hence thesis;
end;

registration
  let G be non loopfull _Graph, v be object, V be set;
  cluster -> non loopfull for addAdjVertexAll of G,v,V;
  coherence
  proof
    let G1 be addAdjVertexAll of G,v,V;
    per cases;
    suppose V c= the_Vertices_of G & not v in the_Vertices_of G;
      hence thesis by Th14;
    end;
    suppose not(V c= the_Vertices_of G & not v in the_Vertices_of G);
      then G == G1 by GLIB_007:def 4;
      hence thesis by Th4;
    end;
  end;
end;

registration
  let G be loopfull _Graph;
  cluster -> loopfull for removeParallelEdges of G;
  coherence
  proof
    let G2 be removeParallelEdges of G;
    consider E being RepEdgeSelection of G such that
      A1: G2 is inducedSubgraph of G, the_Vertices_of G, E by GLIB_009:def 7;
    now
      let v be Vertex of G2;
      v is Vertex of G by GLIB_000:def 33;
      then consider e0 being object such that
        A2: e0 Joins v,v,G by Def1;
      consider e being object such that
        A3: e Joins v,v,G & e in E  and
        for e9 being object st e9 Joins v,v,G & e9 in E holds e9 = e
        by A2, GLIB_009:def 5;
      take e;
      E c= the_Edges_of G;
      then A4: E c= G.edgesBetween(the_Vertices_of G) by GLIB_000:34;
      the_Vertices_of G c= the_Vertices_of G;
      then the_Edges_of G2 = E by A1, A4, GLIB_000:def 37;
      hence e Joins v,v,G2 by A3, GLIB_000:73;
    end;
    hence thesis;
  end;
  cluster -> loopfull for removeDParallelEdges of G;
  coherence
  proof
    let G2 be removeDParallelEdges of G;
    consider E being RepDEdgeSelection of G such that
      A5: G2 is inducedSubgraph of G, the_Vertices_of G, E by GLIB_009:def 8;
    now
      let v be Vertex of G2;
      v is Vertex of G by GLIB_000:def 33;
      then consider e0 being object such that
        A6: e0 DJoins v,v,G by Th1;
      consider e being object such that
        A7: e DJoins v,v,G & e in E  and
        for e9 being object st e9 DJoins v,v,G & e9 in E holds e9 = e
        by A6, GLIB_009:def 6;
      take e;
      E c= the_Edges_of G;
      then A8: E c= G.edgesBetween(the_Vertices_of G) by GLIB_000:34;
      the_Vertices_of G c= the_Vertices_of G;
      then the_Edges_of G2 = E by A5, A8, GLIB_000:def 37;
      hence e DJoins v,v,G2 by A7, GLIB_000:73;
    end;
    hence thesis by Th1;
  end;
end;

:: removeLoops is loopless, hence non loopfull
registration
  let G be non loopfull _Graph;
  cluster -> non loopfull for removeParallelEdges of G;
  coherence;
  cluster -> non loopfull for removeDParallelEdges of G;
  coherence;
end;

definition
  let GF be Graph-yielding Function;
  attr GF is loopfull means
  :Def2:
  for x being object st x in dom GF
    ex G being _Graph st GF.x = G & G is loopfull;
end;

registration
  let G be loopfull _Graph;
  cluster <* G *> -> loopfull;
  coherence
  proof
    let x be object;
    assume A1: x in dom <* G *>;
    then reconsider n = x as Nat;
    1 <= n <= len <* G *> by A1, FINSEQ_3:25;
    then 1 <= n <= 1 by FINSEQ_1:40;
    then n = 1 by XXREAL_0:1;
    hence thesis by FINSEQ_1:40;
  end;
  cluster NAT --> G -> loopfull;
  coherence by FUNCOP_1:7;
end;

definition
  let GF be non empty Graph-yielding Function;
  redefine attr GF is loopfull means
  :Def3:
  for x being Element of dom GF holds GF.x is loopfull;
  compatibility
  proof
    hereby
      assume A1: GF is loopfull;
      let x be Element of dom GF;
      consider G being _Graph such that
        A2: GF.x = G & G is loopfull by A1;
      thus GF.x is loopfull by A2;
    end;
    assume A3: for x being Element of dom GF holds GF.x is loopfull;
    let x be object;
    assume x in dom GF;
    then reconsider y = x as Element of dom GF;
    take GF.y;
    thus thesis by A3;
  end;
end;

Lm1: :: copied from GLIB_000
  for F being ManySortedSet of NAT, n being object
  holds n is Nat iff n in dom F
proof
  let F be ManySortedSet of NAT, n being object;
  hereby
    assume n is Nat;
    then n in NAT by ORDINAL1:def 12;
    hence n in dom F by PARTFUN1:def 2;
  end;
  assume n in dom F;
  hence n is Nat;
end;

definition
  let GSq be GraphSeq;
  redefine attr GSq is loopfull means
  :Def4:
  for n being Nat holds GSq.n is loopfull;
  compatibility
  proof
    hereby
      assume A1: GSq is loopfull;
      let x be Nat;
      x in dom GSq by Lm1;
      hence GSq.x is loopfull by A1;
    end;
    assume A2: for x being Nat holds GSq.x is loopfull;
    let x be Element of dom GSq;
    thus thesis by A2;
  end;
end;

registration
  cluster empty -> loopfull for Graph-yielding Function;
  coherence;
  cluster non empty loopfull -> non loopless for Graph-yielding Function;
  coherence
  proof
    let GF be Graph-yielding Function;
    assume A1: GF is non empty loopfull;
    then consider x being object such that
      A2: x in dom GF by XBOOLE_0:def 1;
    consider G being _Graph such that
      A3: GF.x = G & G is loopfull by A1, A2;
    thus thesis by A1, A2, A3;
  end;
end;

registration
  cluster loopfull for GraphSeq;
  existence
  proof
    take NAT --> the loopfull _Graph;
    thus thesis;
  end;
  cluster non empty loopfull for Graph-yielding FinSequence;
  existence
  proof
    take <* the loopfull _Graph *>;
    thus thesis;
  end;
end;

registration
  let GF be loopfull non empty Graph-yielding Function, x be Element of dom GF;
  cluster GF.x -> loopfull;
  coherence by Def3;
end;

registration
  let GSq be loopfull GraphSeq, x be Nat;
  cluster GSq.x -> loopfull;
  coherence by Def4;
end;

registration
  let p be loopfull Graph-yielding FinSequence, n be Nat;
  cluster p | n -> loopfull;
  coherence
  proof
    A1: p|n = p|Seg n by FINSEQ_1:def 15;
    now
      let x be object;
      assume A2: x in dom(p|n);
      then x in dom p by A1, RELAT_1:60, TARSKI:def 3;
      then consider G being _Graph such that
        A3: p.x = G & G is loopfull by Def2;
      take G;
      thus (p|n).x = G & G is loopfull by A1, A3, A2, FUNCT_1:47;
    end;
    hence thesis;
  end;
  cluster p /^ n -> loopfull;
  coherence
  proof
    per cases;
    suppose A4: n <= len p;
      now
        let x be object;
        assume A5: x in dom(p /^ n);
        then reconsider i = x as Nat;
        n+i in dom p by A5, FINSEQ_5:26;
        then consider G being _Graph such that
          A6: p.(n+i) = G & G is loopfull by Def2;
        take G;
        thus (p /^ n).x = G & G is loopfull by A4, A5, A6, RFINSEQ:def 1;
      end;
      hence thesis;
    end;
    suppose not (n <= len p);
      hence thesis by RFINSEQ:def 1;
    end;
  end;
  let m be Nat;
  cluster smid(p,m,n) -> loopfull;
  coherence
  proof
    smid(p,m,n) = (p/^(m-'1))|(n+1-'m) by FINSEQ_8:def 1;
    hence thesis;
  end;
  cluster (m,n)-cut p -> loopfull;
  coherence
  proof
    per cases;
    suppose 1 <= m & m <= n & n <= len p;
      then 1 <= m & m <= len p & 1 <= n & n <= len p by XXREAL_0:2;
      then m in dom p & n in dom p by FINSEQ_3:25;
      then smid(p,m,n) = (m,n)-cut p by FINSEQ_8:29;
      hence thesis;
    end;
    suppose not(1 <= m & m <= n & n <= len p);
      hence thesis by FINSEQ_6:def 4;
    end;
  end;
end;

registration
  let p, q be loopfull Graph-yielding FinSequence;
  cluster p ^ q -> loopfull;
  coherence
  proof
    for x being object st x in dom (p^q) ex G being _Graph st
      G = (p^q).x & G is loopfull
    proof
      let x be object;
      assume A1: x in dom (p^q);
      then reconsider k = x as Nat;
      per cases by A1, FINSEQ_1:25;
      suppose k in dom p;
        then (p^q).k = p.k & ex G being _Graph st p.k = G & G is loopfull
          by Def2, FINSEQ_1:def 7;
        hence ex G being _Graph st (p^q).x = G & G is loopfull;
      end;
      suppose ex n being Nat st n in dom q & k = len p + n;
        then consider n being Nat such that
          A2: n in dom q & k = len p + n;
        (p^q).(len p + n) = q.n & ex G being _Graph st q.n = G & G is loopfull
          by A2, Def2, FINSEQ_1:def 7;
        hence ex G being _Graph st (p^q).x = G & G is loopfull by A2;
      end;
    end;
    hence thesis;
  end;
  cluster p ^' q -> loopfull;
  coherence
  proof
    p ^' q = p^(2,len q)-cut q by FINSEQ_6:def 5;
    hence thesis;
  end;
end;

registration
  let G1, G2 be loopfull _Graph;
  cluster <* G1, G2 *> -> loopfull;
  coherence
  proof
    <* G1, G2 *> = <* G1 *> ^ <* G2 *> by FINSEQ_1:def 9;
    hence thesis;
  end;
  let G3 be loopfull _Graph;
  cluster <* G1, G2, G3 *> -> loopfull;
  coherence
  proof
    <* G1, G2, G3 *> = <* G1 *> ^ <* G2 *> ^ <* G3 *> by FINSEQ_1:def 10;
    hence thesis;
  end;
end;

begin :: Adding Loops to a Graph

:: a loop is added to each vertex in V, regardless if that
:: vertex has a loop already or not
definition
  let G be _Graph, V be set;
  mode addLoops of G, V -> Supergraph of G means
  :Def5:
  the_Vertices_of it = the_Vertices_of G &
  ex E being set, f being one-to-one Function
  st E misses the_Edges_of G & the_Edges_of it = the_Edges_of G \/ E &
    dom f = E & rng f = V & the_Source_of it = the_Source_of G +* f &
    the_Target_of it = the_Target_of G +* f if V c= the_Vertices_of G
  otherwise it == G;
  existence
  proof
    hereby
      assume A1: V c= the_Vertices_of G;
      set E = {[the_Edges_of G,v] where v is Vertex of G : v in V};
      deffunc F(object) = $1`2;
      consider f being Function such that
        A2: dom f = E & for x being object st x in E holds f.x = F(x)
        from FUNCT_1:sch 3;
      :: define source and target
      set s = the_Source_of G +* f, t = the_Target_of G +* f;
      now
        let y be object;
        hereby
          assume y in rng f;
          then consider x being object such that
            A3: x in dom f & f.x = y by FUNCT_1:def 3;
          consider v being Vertex of G such that
            A4: x = [the_Edges_of G,v] & v in V by A2, A3;
          y = x`2 by A2, A3
            .= v by A4;
          hence y in V by A4;
        end;
        set x = [the_Edges_of G,y];
        assume y in V;
        then A5: x in dom f by A1, A2;
        then f.x = x`2 by A2
          .= y;
        hence y in rng f by A5, FUNCT_1:3;
      end;
      then A6: rng f = V by TARSKI:2;
      A7: dom s = dom the_Source_of G \/ dom f by FUNCT_4:def 1
        .= the_Edges_of G \/ E by A2, FUNCT_2:def 1;
      A8: dom t = dom the_Target_of G \/ dom f by FUNCT_4:def 1
        .= the_Edges_of G \/ E by A2, FUNCT_2:def 1;
      A9: the_Edges_of G misses E
      proof
        assume the_Edges_of G meets E;
        then consider e being object such that
          A10: e in the_Edges_of G & e in E by XBOOLE_0:3;
        reconsider e as set by TARSKI:1;
        consider v being Vertex of G such that
          A11: e = [the_Edges_of G,v] & v in V by A10;
        A12: the_Edges_of G in {the_Edges_of G} by TARSKI:def 1;
        e = {{the_Edges_of G, v}, {the_Edges_of G}} by A11, TARSKI:def 5;
        then {the_Edges_of G} in e by TARSKI:def 2;
        hence contradiction by A10, A12, XREGULAR:7;
      end;
      rng the_Source_of G \/ rng f c= the_Vertices_of G \/ V &
        rng the_Target_of G \/ rng f c= the_Vertices_of G \/ V
        by A6, XBOOLE_1:9;
      then A13: rng the_Source_of G \/ rng f c= the_Vertices_of G &
        rng the_Target_of G \/ rng f c= the_Vertices_of G by A1, XBOOLE_1:12;
      rng s c= rng the_Source_of G \/ rng f &
        rng t c= rng the_Target_of G \/ rng f by FUNCT_4:17;
      then A14: rng s c= the_Vertices_of G &
        rng t c= the_Vertices_of G by A13, XBOOLE_1:1;
      then reconsider s as Function of the_Edges_of G \/ E, the_Vertices_of G
        by A7, FUNCT_2:2;
      reconsider t as Function of the_Edges_of G \/ E, the_Vertices_of G
        by A8, A14, FUNCT_2:2;
      :: define the supergraph and show properties
      set H = createGraph(the_Vertices_of G, the_Edges_of G \/ E, s, t);
      A15: the_Edges_of G c= the_Edges_of H
        & the_Vertices_of G = the_Vertices_of H by XBOOLE_1:7;
      now
        let e be set;
        assume A16: e in the_Edges_of G;
        then e in the_Edges_of G \/ E by XBOOLE_0:def 3;
        then A17: not e in dom f by A2, A9, A16, XBOOLE_0:5;
        hence (the_Source_of G).e = (the_Source_of H).e by FUNCT_4:11;
        thus (the_Target_of G).e = (the_Target_of H).e by A17, FUNCT_4:11;
      end;
      then reconsider H as Supergraph of G by A15, GLIB_006:def 9;
      take H;
      thus the_Vertices_of H = the_Vertices_of G;
      now
        let x1, x2 be object;
        assume A19: x1 in dom f & x2 in dom f & f.x1 = f.x2;
        then consider v1 being Vertex of G such that
          A20: x1 = [the_Edges_of G,v1] & v1 in V by A2;
        consider v2 being Vertex of G such that
          A21: x2 = [the_Edges_of G,v2] & v2 in V by A2, A19;
        thus x1 = [the_Edges_of G,[the_Edges_of G,v1]`2] by A20
          .= [the_Edges_of G,f.x2] by A2, A19, A20
          .= [the_Edges_of G,[the_Edges_of G,v2]`2] by A2, A19, A21
          .= x2 by A21;
      end;
      then reconsider f as one-to-one Function by FUNCT_1:def 4;
      take E, f;
      thus E misses the_Edges_of G & the_Edges_of H = the_Edges_of G \/ E
        by A9;
      thus dom f = E & rng f = V by A2, A6;
      thus the_Source_of H = the_Source_of G +* f &
        the_Target_of H = the_Target_of G +* f;
    end;
    assume not V c= the_Vertices_of G;
    take G;
    thus thesis by GLIB_006:61;
  end;
  consistency;
end;

definition
  let G be _Graph;
  mode addLoops of G is addLoops of G, the_Vertices_of G;
end;

theorem Th15:
  for G2 being _Graph, V being set, G1 being addLoops of G2, V
  holds the_Vertices_of G1 = the_Vertices_of G2
proof
  let G2 be _Graph, V be set, G1 be addLoops of G2, V;
  per cases;
  suppose V c= the_Vertices_of G2;
    hence thesis by Def5;
  end;
  suppose not V c= the_Vertices_of G2;
    then G1 == G2 by Def5;
    hence thesis by GLIB_000:def 34;
  end;
end;

theorem Th16:
  for G2 being _Graph, V being set, G1 being addLoops of G2, V
  for e,v,w being object st v <> w holds e DJoins v,w,G1 iff e DJoins v,w,G2
proof
  let G2 be _Graph, V be set, G1 be addLoops of G2, V;
  per cases;
  suppose V c= the_Vertices_of G2;
    then consider E being set, f being one-to-one Function such that
      A1: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
        dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f &
        the_Target_of G1 = the_Target_of G2 +* f by Def5;
    let e,v,w be object;
    assume A2: v <> w;
    hereby
      assume A3: e DJoins v,w,G1;
      then A4: e in the_Edges_of G2 \/ E by A1, GLIB_000:def 14;
      not e in E
      proof
        assume A5: e in E;
        then A6: (the_Source_of G1).e = f.e by A1, FUNCT_4:13;
        (the_Target_of G1).e = f.e by A1, A5, FUNCT_4:13;
        then f.e = v & f.e = w by A3, A6, GLIB_000:def 14;
        hence contradiction by A2;
      end;
      then e in the_Edges_of G2 by A1, A4, XBOOLE_0:5;
      hence e DJoins v,w,G2 by A3, GLIB_006:71;
    end;
    assume A7: e DJoins v,w,G2;
    v is set & w is set by TARSKI:1;
    hence thesis by A7, GLIB_006:70;
  end;
  suppose not V c= the_Vertices_of G2;
    then G1 == G2 by Def5;
    hence thesis by GLIB_000:88;
  end;
end;

theorem Th17:
  for G2 being _Graph, V being set, G1 being addLoops of G2, V
  for e,v,w being object st v <> w holds e Joins v,w,G1 iff e Joins v,w,G2
proof
  let G2 be _Graph, V be set, G1 be addLoops of G2, V;
  let e,v,w be object;
  assume A1: v <> w;
  hereby
    assume e Joins v,w,G1;
    then per cases by GLIB_000:16;
    suppose e DJoins v,w,G1;
      then e DJoins v,w,G2 by A1, Th16;
      hence e Joins v,w,G2 by GLIB_000:16;
    end;
    suppose e DJoins w,v,G1;
      then e DJoins w,v,G2 by A1, Th16;
      hence e Joins v,w,G2 by GLIB_000:16;
    end;
  end;
  assume A2: e Joins v,w,G2;
  v is set & w is set by TARSKI:1;
  hence e Joins v,w,G1 by A2, GLIB_006:70;
end;

theorem
  for G2 being _Graph, V being Subset of the_Vertices_of G2
  for G1 being addLoops of G2, V for v being Vertex of G1
  st v in V holds v,v are_adjacent
proof
  let G2 be _Graph, V be Subset of the_Vertices_of G2, G1 be addLoops of G2, V;
  let v be Vertex of G1;
  consider E being set, f being one-to-one Function such that
    A1: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
      dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f &
      the_Target_of G1 = the_Target_of G2 +* f by Def5;
  assume v in V;
  then consider e being object such that
    A2: e in dom f & f.e = v by A1, FUNCT_1:def 3;
  A3: (the_Source_of G1).e = v by A1, A2, FUNCT_4:13;
  A4: (the_Target_of G1).e = v by A1, A2, FUNCT_4:13;
  e in the_Edges_of G1 by A1, A2, XBOOLE_0:def 3;
  then e Joins v,v,G1 by A3, A4, GLIB_000:def 13;
  hence v,v are_adjacent by CHORD:def 3;
end;

theorem
  for G2 being _Graph, V being set
  for G1 being addLoops of G2, V holds G1.order() = G2.order() by Th15;

theorem
  for G2 being _Graph, V being Subset of the_Vertices_of G2
  for G1 being addLoops of G2, V holds G1.size() = G2.size() +` card V
proof
  let G2 be _Graph, V be Subset of the_Vertices_of G2, G1 be addLoops of G2, V;
  consider E being set, f being one-to-one Function such that
    A1: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
      dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f &
      the_Target_of G1 = the_Target_of G2 +* f by Def5;
  thus G1.size() = card the_Edges_of G2 +` card E by A1, CARD_2:35
    .= G2.size() +` card V by A1, CARD_1:70;
end;

theorem Th21:
  for G1, G2 being _Graph holds G1 is addLoops of G2, {} iff G1 == G2
proof
  let G1, G2 be _Graph;
  hereby
    assume A1: G1 is addLoops of G2, {};
    {} c= the_Vertices_of G2 by XBOOLE_1:2;
    then consider E being set, f being one-to-one Function such that
      A2: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
        dom f = E & rng f = {} & the_Source_of G1 = the_Source_of G2 +* f &
        the_Target_of G1 = the_Target_of G2 +* f by A1, Def5;
    A3: f = {} by A2;
    then A4: E = {} by A2;
    A5: the_Source_of G1 = the_Source_of G2 by A2, A3, FUNCT_4:21;
    the_Target_of G1 = the_Target_of G2 by A2, A3, FUNCT_4:21;
    hence G1 == G2 by A1, A2, A4, A5, Th15, GLIB_000:def 34;
  end;
  assume A6: G1 == G2;
  then A7: G1 is Supergraph of G2 by GLIB_006:59;
  now
    thus {} c= the_Vertices_of G2 by XBOOLE_1:2;
    thus the_Vertices_of G1 = the_Vertices_of G2 by A6, GLIB_000:def 34;
    set E = the empty set, f = the empty one-to-one Function;
    take E,f;
    thus E misses the_Edges_of G2 by XBOOLE_1:65;
    thus the_Edges_of G1 = the_Edges_of G2 \/ E by A6, GLIB_000:def 34;
    thus dom f = E & rng f = {};
    thus the_Source_of G1 = the_Source_of G2 by A6, GLIB_000:def 34
      .= the_Source_of G2 +* f by FUNCT_4:21;
    thus the_Target_of G1 = the_Target_of G2 by A6, GLIB_000:def 34
      .= the_Target_of G2 +* f by FUNCT_4:21;
  end;
  hence G1 is addLoops of G2, {} by A7, Def5;
end;

theorem
  for G being _Graph holds G is addLoops of G, {}
proof
  let G be _Graph;
  A1: G is Supergraph of G & {}c= the_Vertices_of G by GLIB_006:61, XBOOLE_1:2;
  now
    thus the_Vertices_of G = the_Vertices_of G;
    reconsider E = {} as set;
    reconsider f = the empty Function as one-to-one Function;
    take E, f;
    thus E misses the_Edges_of G by XBOOLE_1:65;
    thus the_Edges_of G = the_Edges_of G \/ E;
    thus dom f = E & rng f = {};
    thus the_Source_of G = the_Source_of G +* f by FUNCT_4:21;
    thus the_Target_of G = the_Target_of G +* f by FUNCT_4:21;
  end;
  hence thesis by A1, Def5;
end;

theorem
  for G being _Graph, V1, V2 being Subset of the_Vertices_of G
  for G1 being addLoops of G, V1, G2 being addLoops of G1, V2
  st V1 misses V2 holds G2 is addLoops of G, V1 \/ V2
proof
  let G be _Graph, V1, V2 being Subset of the_Vertices_of G;
  let G1 be addLoops of G, V1, G2 be addLoops of G1, V2;
  assume A1: V1 misses V2;
  consider E1 being set, f1 being one-to-one Function such that
    A2: E1 misses the_Edges_of G & the_Edges_of G1 = the_Edges_of G \/ E1 &
      dom f1 = E1 & rng f1 = V1 & the_Source_of G1 = the_Source_of G +* f1 &
      the_Target_of G1 = the_Target_of G +* f1 by Def5;
  V2 c= the_Vertices_of G;
  then V2 c= the_Vertices_of G1 by Th15;
  then consider E2 being set, f2 being one-to-one Function such that
    A3: E2 misses the_Edges_of G1 & the_Edges_of G2 = the_Edges_of G1 \/ E2 &
      dom f2 = E2 & rng f2 = V2 & the_Source_of G2 = the_Source_of G1 +* f2 &
      the_Target_of G2 = the_Target_of G1 +* f2 by Def5;
  A4: G2 is Supergraph of G by GLIB_006:62;
  A5: the_Vertices_of G2 = the_Vertices_of G1 by Th15
    .= the_Vertices_of G by Th15;
  now
    reconsider E = E1 \/ E2 as set;
    reconsider f = f1 +* f2 as one-to-one Function by A1, A2, A3, FUNCT_4:92;
    take E,f;
    A6: E2 misses the_Edges_of G & E2 misses E1 by A2, A3, XBOOLE_1:70;
    hence E misses the_Edges_of G by A2, XBOOLE_1:70;
    thus the_Edges_of G2 =  the_Edges_of G \/ E by A2, A3, XBOOLE_1:4;
    thus dom f = E by A2, A3, FUNCT_4:def 1;
    thus rng f = V1 \/ V2 by A2, A3, A6, NECKLACE:6;
    thus the_Source_of G2 = the_Source_of G +* f by A2, A3, FUNCT_4:14;
    thus the_Target_of G2 = the_Target_of G +* f by A2, A3, FUNCT_4:14;
  end;
  hence thesis by A4, A5, Def5;
end;

theorem Th24:
  for G3 being _Graph, V1, V2 being Subset of the_Vertices_of G3
  for G1 being addLoops of G3, V1 \/ V2 st V1 misses V2
  ex G2 being addLoops of G3, V1 st G1 is addLoops of G2, V2
proof
  let G3 be _Graph, V1, V2 be Subset of the_Vertices_of G3;
  let G1 be addLoops of G3, V1 \/ V2;
  assume A1: V1 misses V2;
  consider E3 being set, f3 being one-to-one Function such that
    A2: E3 misses the_Edges_of G3 & the_Edges_of G1 = the_Edges_of G3 \/ E3 &
      dom f3 = E3 & rng f3 = V1 \/ V2 &
      the_Source_of G1 = the_Source_of G3 +* f3 &
      the_Target_of G1 = the_Target_of G3 +* f3 by Def5;
  :: define G2
  set E1 = f3"V1;
  set f1 = f3|(f3"V1);
  set s1 = the_Source_of G3 +* f1;
  set t1 = the_Target_of G3 +* f1;
  A3: E1 c= E3 by A2, RELAT_1:132;
  then A4: E1 = E1 /\ E3 by XBOOLE_1:28
    .= dom f1 by A2, RELAT_1:61;
  A5: dom s1 = dom the_Source_of G3 \/ dom f1 by FUNCT_4:def 1
    .= the_Edges_of G3 \/ E1 by A4, FUNCT_2:def 1;
  A6: dom t1 = dom the_Target_of G3 \/ dom f1 by FUNCT_4:def 1
    .= the_Edges_of G3 \/ E1 by A4, FUNCT_2:def 1;
  A7: V1 = f3.:(f3"V1) by A2, XBOOLE_1:7, FUNCT_1:77
    .= rng f1 by RELAT_1:115;
  then A8: the_Vertices_of G3 \/ rng f1 = the_Vertices_of G3 by XBOOLE_1:12;
  A9: rng s1 c= rng the_Source_of G3 \/ rng f1 by FUNCT_4:17;
  rng the_Source_of G3 \/ rng f1 c= the_Vertices_of G3 \/ rng f1 by XBOOLE_1:9;
  then reconsider s1 as Function of the_Edges_of G3 \/ E1, the_Vertices_of G3
    by A5, A8, A9, XBOOLE_1:1, FUNCT_2:2;
  A10: rng t1 c= rng the_Target_of G3 \/ rng f1 by FUNCT_4:17;
  rng the_Target_of G3 \/ rng f1 c= the_Vertices_of G3 \/ rng f1 by XBOOLE_1:9;
  then reconsider t1 as Function of the_Edges_of G3 \/ E1, the_Vertices_of G3
    by A6, A8, A10, XBOOLE_1:1, FUNCT_2:2;
  set G2 = createGraph(the_Vertices_of G3,the_Edges_of G3 \/ E1, s1, t1);
  :: G2 is Supergraph of G3
  now
    thus the_Vertices_of G3 c= the_Vertices_of G2;
    thus the_Edges_of G3 c= the_Edges_of G2 by XBOOLE_1:7;
    let e be set;
    assume A11: e in the_Edges_of G3;
    then e in the_Edges_of G3 \/ E3 by XBOOLE_0:def 3;
    then A12: not e in dom f1 by A2, A3, A4, A11, XBOOLE_0:5;
    thus (the_Source_of G3).e = s1.e by A12, FUNCT_4:11
      .= (the_Source_of G2).e;
    thus (the_Target_of G3).e = t1.e by A12, FUNCT_4:11
      .= (the_Target_of G2).e;
  end;
  then reconsider G2 as Supergraph of G3 by GLIB_006:def 9;
  :: G2 is addLoops of G3, V1
  now
    thus the_Vertices_of G2 = the_Vertices_of G3;
    reconsider E1 as set;
    reconsider f1 as one-to-one Function by FUNCT_1:52;
    take E1, f1;
    thus E1 misses the_Edges_of G3 by A2, A3, XBOOLE_1:63;
    thus the_Edges_of G2 = the_Edges_of G3 \/ E1;
    thus dom f1 = E1 by A4;
    thus rng f1 = V1 by A7;
    thus the_Source_of G2 = the_Source_of G3 +* f1;
    thus the_Target_of G2 = the_Target_of G3 +* f1;
  end;
  then reconsider G2 as addLoops of G3, V1 by Def5;
  take G2;
  :: G1 is Supergraph of G2
  set E2 = E3\E1;
  A13: the_Vertices_of G1 = the_Vertices_of G3 by Def5
      .= the_Vertices_of G2;
  A14: the_Edges_of G1 = the_Edges_of G3 \/ (E1 \/ E2) by A2, A3, XBOOLE_1:45
    .= (the_Edges_of G3 \/ E1) \/ E2 by XBOOLE_1:4
    .= the_Edges_of G2 \/ E2;
  now
    thus the_Vertices_of G2 c= the_Vertices_of G1 by A13;
    thus the_Edges_of G2 c= the_Edges_of G1 by A14, XBOOLE_1:7;
    let e be set;
    A15: E1 misses the_Edges_of G3 by A2, A3, XBOOLE_1:63;
    assume e in the_Edges_of G2;
    then A16: e in the_Edges_of G3 \/ E1;
    then per cases by XBOOLE_0:def 3;
    suppose A17: e in the_Edges_of G3;
      then A18: not e in E1 by A15, A16, XBOOLE_0:5;
      thus (the_Source_of G2).e = s1.e
        .= (the_Source_of G3).e by A4, A18, FUNCT_4:11
        .= (the_Source_of G1).e by A17, GLIB_006:def 9;
      thus (the_Target_of G2).e = t1.e
        .= (the_Target_of G3).e by A4, A18, FUNCT_4:11
        .= (the_Target_of G1).e by A17, GLIB_006:def 9;
    end;
    suppose A19: e in E1;
      thus (the_Source_of G2).e = s1.e
        .= f1.e by A4, A19, FUNCT_4:13
        .= f3.e by A19, FUNCT_1:49
        .= (the_Source_of G1).e by A2, A3, A19, FUNCT_4:13;
      thus (the_Target_of G2).e = t1.e
        .= f1.e by A4, A19, FUNCT_4:13
        .= f3.e by A19, FUNCT_1:49
        .= (the_Target_of G1).e by A2, A3, A19, FUNCT_4:13;
    end;
  end;
  then A20: G1 is Supergraph of G2 by GLIB_006:def 9;
  :: G1 is addLoops of G2, V2
  now
    reconsider E2 as set;
    reconsider f2 = f3|E2 as one-to-one Function by FUNCT_1:52;
    take E2, f2;
    E2 misses E3\E2 by XBOOLE_1:79;
    then E2 misses E3 /\ E1 by XBOOLE_1:48;
    then A22: E2 misses E1 by A3, XBOOLE_1:28;
    E2 misses the_Edges_of G3 by A2, XBOOLE_1:63;
    then E2 misses the_Edges_of G3 \/ E1 by A22, XBOOLE_1:70;
    hence E2 misses the_Edges_of G2;
    thus the_Edges_of G1 = the_Edges_of G2 \/ E2 by A14;
    A23: E2 = f3"(V1 \/ V2) \ f3"V1 by A2, RELAT_1:134
      .= f3"((V1 \/ V2) \ V1) by FUNCT_1:69
      .= f3"V2 by A1, XBOOLE_1:88;
    thus dom f2 = dom f3 /\ (f3"V2) by A23, RELAT_1:61
      .= E2 by A2, A23, XBOOLE_1:28;
    thus rng f2 = f3.:(f3"V2) by A23, RELAT_1:115
      .= V2 by A2, XBOOLE_1:7, FUNCT_1:77;
    A24: dom f3 c= E1 \/ E2 by A2, A3, XBOOLE_1:45;
    thus the_Source_of G1
       = the_Source_of G3 +* (f1 +* f3|E2) by A2, A24, FUNCT_4:70
      .= (the_Source_of G3 +* f1) +* f2 by FUNCT_4:14
      .= the_Source_of G2 +* f2;
    thus the_Target_of G1
       = the_Target_of G3 +* (f1 +* f2) by A2, A24, FUNCT_4:70
      .= (the_Target_of G3 +* f1) +* f2 by FUNCT_4:14
      .= the_Target_of G2 +* f2;
  end;
  hence G1 is addLoops of G2, V2 by A13, A20, Def5;
end;

theorem Th25:
  for G2 being loopless _Graph, V being Subset of the_Vertices_of G2
  for G1 being addLoops of G2, V
  holds the_Edges_of G2 misses G1.loops() &
    the_Edges_of G1 = the_Edges_of G2 \/ G1.loops()
proof
  let G2 be loopless _Graph, V be Subset of the_Vertices_of G2;
  let G1 be addLoops of G2, V;
  thus the_Edges_of G2 misses G1.loops()
  proof
    assume the_Edges_of G2 meets G1.loops();
    then consider e being object such that
      A1: e in the_Edges_of G2 & e in G1.loops() by XBOOLE_0:3;
    consider v being object such that
      A2: e Joins v,v,G1 by A1, GLIB_009:def 2;
    thus contradiction by A1, A2, GLIB_006:72, GLIB_000:18;
  end;
  consider E being set, f being one-to-one Function such that
    A3: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
      dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f &
      the_Target_of G1 = the_Target_of G2 +* f by Def5;
  now
    let e be object;
    hereby
      assume e in G1.loops();
      then consider v being object such that
        A4: e Joins v,v,G1 by GLIB_009:def 2;
      A5: not e in the_Edges_of G2 by A4, GLIB_000:18, GLIB_006:72;
      e in the_Edges_of G1 by A4, GLIB_000:def 13;
      hence e in E by A3, A5, XBOOLE_0:def 3;
    end;
    assume e in E;
    then A6: e in dom f & e in the_Edges_of G1 by A3, XBOOLE_0:def 3;
    then (the_Source_of G1).e = f.e & (the_Target_of G1).e = f.e
      by A3, FUNCT_4:13;
    hence e in G1.loops() by A6, GLIB_000:def 14, GLIB_009:45;
  end;
  hence the_Edges_of G1 = the_Edges_of G2 \/ G1.loops() by A3, TARSKI:2;
end;

theorem Th26:
  for G1 being loopless _Graph, V being set
  for G2 being addLoops of G1, V, G3 being removeLoops of G2
  holds G1 == G3
proof
  let G1 be loopless _Graph, V be set;
  let G2 be addLoops of G1, V, G3 be removeLoops of G2;
  per cases;
  suppose A1: V c= the_Vertices_of G1;
    then A2: the_Vertices_of G1 = the_Vertices_of G2 by Def5
      .= the_Vertices_of G3 by GLIB_000:53;
    A3: the_Edges_of G1
       = (the_Edges_of G1 \/ G2.loops()) \ G2.loops() by A1, Th25, XBOOLE_1:88
      .= the_Edges_of G2 \ G2.loops() by A1, Th25
      .= the_Edges_of G3 by GLIB_000:53;
    A4: dom the_Source_of G1 = the_Edges_of G3 by A3, FUNCT_2:def 1
      .= dom the_Source_of G3 by FUNCT_2:def 1;
    A5: dom the_Target_of G1 = the_Edges_of G3 by A3, FUNCT_2:def 1
      .= dom the_Target_of G3 by FUNCT_2:def 1;
    now
      let e be object;
      assume A6: e in dom the_Source_of G1;
      hence (the_Source_of G1).e
         = (the_Source_of G2).e by GLIB_006:def 9
        .= (the_Source_of G3).e by A3, A6, GLIB_000:def 32;
    end;
    then A7: the_Source_of G1 = the_Source_of G3 by A4, FUNCT_1:2;
    now
      let e be object;
      assume A8: e in dom the_Target_of G1;
      hence (the_Target_of G1).e
         = (the_Target_of G2).e by GLIB_006:def 9
        .= (the_Target_of G3).e by A3, A8, GLIB_000:def 32;
    end;
    then the_Target_of G1 = the_Target_of G3 by A5, FUNCT_1:2;
    hence thesis by A2, A3, A7, GLIB_000:def 34;
  end;
  suppose not V c= the_Vertices_of G1;
    then A9: G1 == G2 by Def5;
    then G2 is loopless by GLIB_000:89;
    then G2 == G3 by GLIB_009:58;
    hence thesis by A9, GLIB_000:85;
  end;
end;

theorem Th27:
  for G1, G2 being _Graph, v being Vertex of G2
  holds G1 is addLoops of G2, {v} iff ex e being object
    st not e in the_Edges_of G2 & G1 is addEdge of G2,v,e,v
proof
  let G1, G2 be _Graph, v be Vertex of G2;
  hereby
    assume A1: G1 is addLoops of G2, {v};
    then consider E being set, f being one-to-one Function such that
      A2: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
        dom f = E & rng f = {v} & the_Source_of G1 = the_Source_of G2 +* f &
        the_Target_of G1 = the_Target_of G2 +* f by Def5;
    v in rng f by A2, TARSKI:def 1;
    then consider e being object such that
      A3: e in dom f & f.e = v by FUNCT_1:def 3;
    take e;
    card E = card {v} by A2, CARD_1:70;
    then consider e0 being object such that
      A4: E = {e0} by CARD_1:29;
    A5: E = {e} by A2, A3, A4, TARSKI:def 1;
    hence A6: not e in the_Edges_of G2 by A2, ZFMISC_1:48;
    the_Vertices_of G1 = the_Vertices_of G2 &
      the_Edges_of G1 = the_Edges_of G2 \/ {e} &
      the_Source_of G1 = the_Source_of G2 +* (e .--> v) &
      the_Target_of G1 = the_Target_of G2 +* (e .--> v)
      by A1, A2, A5, Def5, FUNCOP_1:9;
    hence G1 is addEdge of G2,v,e,v by A1, A6, GLIB_006:def 11;
  end;
  given e being object such that
    A7: not e in the_Edges_of G2 & G1 is addEdge of G2,v,e,v;
  now
    thus the_Vertices_of G1 = the_Vertices_of G2 by A7, GLIB_006:def 11;
    reconsider f = e .--> v as one-to-one Function;
    take E = {e}, f;
    thus E misses the_Edges_of G2 by A7, ZFMISC_1:50;
    thus the_Edges_of G1 = the_Edges_of G2 \/ E by A7, GLIB_006:def 11;
    thus dom f = E;
    e is set & v is set by TARSKI:1;
    hence rng f = {v} by FUNCOP_1:88;
    thus the_Source_of G1 = the_Source_of G2 +* f by A7, GLIB_006:def 11;
    thus the_Target_of G1 = the_Target_of G2 +* f by A7, GLIB_006:def 11;
  end;
  hence G1 is addLoops of G2, {v} by A7, Def5;
end;

:: copied from GLIB_008
Lm2:
  for p being non empty FinSequence, x being object
  for n being Element of dom(p^<*x*>) st n <= len(p^<*x*>) - 1
  holds n = len(p^<*x*>) - 1 or n <= len p - 1
proof
  let p be non empty FinSequence, x be object, n be Element of dom(p^<*x*>);
  A1: len(p^<*x*>) = len p + len <*x*> by FINSEQ_1:22
    .= len p + 1 by FINSEQ_1:39;
  assume A2: n <= len(p^<*x*>) - 1;
  assume not n = len(p^<*x*>) - 1;
  then A3: n < len p - 1 + 1 by A1, A2, XXREAL_0:1;
  len p - 1 is Nat by CHORD:1;
  hence n <= len p - 1 by A3, NAT_1:13;
end;

:: finite addition of loops can be finitely constructed with one loop at a time
theorem
  for G2 being _Graph, V being finite Subset of the_Vertices_of G2
  for G1 being addLoops of G2, V
  ex p being non empty Graph-yielding FinSequence
  st p.1 == G2 & p.len p = G1 & len p = card V + 1 &
    for n being Element of dom p st n <= len p - 1 holds
    ex v being Vertex of G2, e being object
    st p.(n+1) is addEdge of p.n, v,e,v & v in V & not e in the_Edges_of p.n
proof
  :: Proof follows along the lines of the similar ones done in GLIB_008
  defpred P[Nat] means for G2 being _Graph
    for V being finite Subset of the_Vertices_of G2
    for G1 being addLoops of G2, V st card V = $1
    ex p being non empty Graph-yielding FinSequence
    st p.1 == G2 & p.len p = G1 & len p = card V + 1 &
      for n being Element of dom p st n <= len p - 1 holds
      ex v being Vertex of G2, e being object
      st p.(n+1) is addEdge of p.n, v,e,v & v in V & not e in the_Edges_of p.n;
  A1: P[0]
  proof
    :: no loops added at all
    let G2 be _Graph, V being finite Subset of the_Vertices_of G2;
    let G1 be addLoops of G2, V;
    assume card V = 0;
    then A2: V = {};
    take p = <* G1 *>;
    p.1 = G1 by FINSEQ_1:40;
    hence p.1 == G2 by A2, Th21;
    thus p.len p = p.1 by FINSEQ_1:40 .= G1 by FINSEQ_1:40;
    thus len p = card V + 1 by A2, FINSEQ_1:40;
    let n be Element of dom p;
    A3: 1 <= n by FINSEQ_3:25;
    assume n <= len p - 1;
    then n <= 1-1 by FINSEQ_1:40;
    hence thesis by A3, XXREAL_0:2; :: by contradiction
  end;
  A4: for k being Nat st P[k] holds P[k+1]
  proof
    let k be Nat;
    assume A5: P[k];
    let G2 be _Graph, V be finite Subset of the_Vertices_of G2;
    let G1 be addLoops of G2, V;
    assume A6: card V = k+1;
    then A7: V <> {};
    set v0 = the Element of V;
    v0 in V by A7;
    then reconsider v0 as Vertex of G2;
    reconsider V9 = V \ {v0} as finite Subset of the_Vertices_of G2;
    :: we use that we can partition the vertices loops should be added to
    :: into two disjoint subsets and then add loops on one subset first
    A8: V = V9 \/ {v0} by A7, ZFMISC_1:116;
    reconsider V0 = {v0} as finite Subset of the_Vertices_of G2;
    v0 in {v0} by TARSKI:def 1;
    then A9: not v0 in V9 by XBOOLE_0:def 5;
    then V9 misses V0 by ZFMISC_1:50;
    then consider G9 being addLoops of G2, V9 such that
      A10: G1 is addLoops of G9, V0 by A8, Th24;
    card V9 = card V - card V0 by A7, ZFMISC_1:31, CARD_2:44
      .= k+1-1 by A6, CARD_1:30;
    then consider p being non empty Graph-yielding FinSequence such that
      A11: p.1 == G2 & p.len p = G9 & len p = card V9 + 1 and
      A12: for n being Element of dom p st n <= len p - 1 holds
        ex v being Vertex of G2, e being object
        st p.(n+1) is addEdge of p.n, v,e,v & v in V9 &
          not e in the_Edges_of p.n by A5;
    take q = p ^ <* G1 *>;
    1 <= len p by FINSEQ_1:20;
    then 1 in dom p by FINSEQ_3:25;
    hence q.1 == G2 by A11, FINSEQ_1:def 7;
    A13: len q = len p + len <* G1 *> by FINSEQ_1:22
      .= len p + 1 by FINSEQ_1:40;
    hence A14: q.len q = G1 by FINSEQ_1:42;
    thus len q = card V + 1 by A8, A9, A11, A13, CARD_2:41;
    let n be Element of dom q;
    assume n <= len q - 1;
    then per cases by Lm2;
    suppose A15: n = len q - 1;
      then A16: q.(n+1) = G1 by A14;
      A17: 1 <= n by FINSEQ_3:25;
      A18: n = len p by A13, A15;
      then n in dom p by A17, FINSEQ_3:25;
      then A19: q.n = G9 by A11, A18, FINSEQ_1:def 7;
      v0 is Vertex of G9 by Th15;
      then consider e being object such that
        A20: not e in the_Edges_of G9 & G1 is addEdge of G9,v0,e,v0
        by A10, Th27;
      reconsider v0 as Vertex of G2;
      take v0, e;
      thus q.(n+1) is addEdge of q.n,v0,e,v0 by A16, A19, A20;
      thus v0 in V by A7;
      thus not e in the_Edges_of q.n by A19, A20;
    end;
    suppose A21: n <= len p - 1;
      then A22: n+0 <= len p - 1 + 1 by XREAL_1:7;
      1 <= n by FINSEQ_3:25;
      then reconsider m = n as Element of dom p by A22, FINSEQ_3:25;
      consider v being Vertex of G2, e being object such that
        A23: p.(m+1) is addEdge of p.m,v,e,v & v in V9 &
          not e in the_Edges_of p.m by A12, A21;
      1+0 <= n+1 & n+1 <= len p - 1 + 1 by A21, XREAL_1:6;
      then n+1 in dom p by FINSEQ_3:25;
      then A24: q.(n+1) = p.(m+1) by FINSEQ_1:def 7;
      A25: q.n = p.m by FINSEQ_1:def 7;
      take v,e;
      v in V by A23, XBOOLE_1:36, TARSKI:def 3;
      hence thesis by A23, A24, A25;
    end;
  end;
  A26: for k being Nat holds P[k] from NAT_1:sch 2(A1,A4);
  let G2 be _Graph, V be finite Subset of the_Vertices_of G2;
  let G1 be addLoops of G2, V;
  thus thesis by A26;
end;

theorem Th29:
  for G3, G4 being _Graph, V1, V2 being set
  for G1 being addLoops of G3, V1, G2 being addLoops of G4, V2
  for F0 being PGraphMapping of G3, G4
  st V1 c= the_Vertices_of G3 & V2 c= the_Vertices_of G4 &
    F0_V | V1 is one-to-one & dom(F0_V | V1) = V1 & rng(F0_V | V1) = V2
  ex F being PGraphMapping of G1, G2 st
    F_V = F0_V & F_E | dom F0_E = F0_E &
    (F0 is non empty  implies F is non empty) &
    (F0 is total implies F is total) &
    (F0 is onto implies F is onto) &
    (F0 is one-to-one implies F is one-to-one) &
    (F0 is directed implies F is directed) &
    (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
    (F0 is isomorphism implies F is isomorphism) &
    (F0 is Disomorphism implies F is Disomorphism)
proof
  let G3, G4 be _Graph, V1, V2 be set;
  let G1 be addLoops of G3, V1, G2 be addLoops of G4, V2;
  let F0 be PGraphMapping of G3, G4;
  assume that
    A1: V1 c= the_Vertices_of G3 & V2 c= the_Vertices_of G4 and
    A2: F0_V | V1 is one-to-one & dom(F0_V | V1) = V1 & rng(F0_V | V1) = V2;
  :: define F_V and F_E
  the_Vertices_of G1 = the_Vertices_of G3 &
    the_Vertices_of G2 = the_Vertices_of G4 by A1, Def5;
  then reconsider f=F0_V as PartFunc of the_Vertices_of G1, the_Vertices_of G2;
  :: below does not accept A2 instead of A1...
  consider E1 being set, f1 being one-to-one Function such that
    A3: E1 misses the_Edges_of G3 & the_Edges_of G1 = the_Edges_of G3 \/ E1 &
      dom f1 = E1 & rng f1 = V1 & the_Source_of G1 = the_Source_of G3 +* f1 &
      the_Target_of G1 = the_Target_of G3 +* f1 by A1, Def5;
  :: why does the checker accept the following?
  consider E2 being set, f2 being one-to-one Function such that
    A4: E2 misses the_Edges_of G4 & the_Edges_of G2 = the_Edges_of G4 \/ E2 &
      dom f2 = E2 & rng f2 = V2 & the_Source_of G2 = the_Source_of G4 +* f2 &
      the_Target_of G2 = the_Target_of G4 +* f2 by A2, Def5;
  set h = f2"*(F0_V|V1)*f1;
  set g = F0_E +* h;
  A5: dom g = dom F0_E \/ dom h by FUNCT_4:def 1;
  A6: dom(f2") = rng(F0_V|V1) by A2, A4, FUNCT_1:33;
  then A7: dom(f2"*(F0_V|V1)) = rng f1 by A2, A3, RELAT_1:27;
  then A8: dom h = E1 by A3, RELAT_1:27;
  then A9: dom g c= the_Edges_of G1 by A3, A5, XBOOLE_1:9;
  rng(f2"*(F0_V|V1)) = rng(f2") by A6, RELAT_1:28
    .= E2 by A4, FUNCT_1:33;
  then A10: rng h = E2 by A7, RELAT_1:28;
  A11: rng g c= rng F0_E \/ rng h by FUNCT_4:17;
  rng F0_E \/ rng h c= the_Edges_of G4 \/ E2 by A10, XBOOLE_1:9;
  then rng g c= the_Edges_of G2 by A4, A11, XBOOLE_1:1;
  then reconsider g as PartFunc of the_Edges_of G1, the_Edges_of G2
    by A9, RELSET_1:4;
  A12: dom((F0_V|V1)*f1) = dom f1 by A2, A3, RELAT_1:27;
  :: reconsider F as PGM
  now
    hereby
      let e be object;
      set v = (the_Source_of G1).e, w = (the_Target_of G1).e;
      assume e in dom g;
      then per cases by FUNCT_4:12;
      suppose A13: e in dom F0_E;
        then v = (the_Source_of G3).e & w = (the_Target_of G3).e
          by GLIB_006:def 9;
        hence v in dom f & w in dom f by A13, GLIB_010:5;
      end;
      suppose e in dom h;
        then A14: e in dom f1 by A3, A8;
        then v = f1.e & w = f1.e by A3, FUNCT_4:13;
        then v in V1 & w in V1 by A3, A14, FUNCT_1:3;
        hence v in dom f & w in dom f by A2, RELAT_1:57;
      end;
    end;
    let e,v,w be object;
    assume A15: e in dom g & v in dom f & w in dom f;
    assume A16: e Joins v,w,G1;
    per cases by A15, FUNCT_4:12;
    suppose A17: e in dom F0_E;
      then e Joins v,w,G3 by A16, GLIB_006:72;
      then A18: F0_E.e Joins F0_V.v,F0_V.w,G4 by A15, A17, GLIB_010:4;
      not e in E1 by A3, A15, A17, XBOOLE_0:5;
      then g.e Joins f.v,f.w,G4 by A8, A18, FUNCT_4:11;
      hence g.e Joins f.v,f.w,G2 by GLIB_006:70;
    end;
    suppose e in dom h;
      then A19: e in E1 & g.e = h.e by A8, FUNCT_4:13;
      then (the_Source_of G1).e = f1.e &
        (the_Target_of G1).e = f1.e by A3, FUNCT_4:13;
      then A20: v = f1.e & w = f1.e by A16, GLIB_000:def 13;
      then A21: v in V1 by A3, A19, FUNCT_1:3;
      then A22: f.v = (F0_V|V1).v by FUNCT_1:49;
      then A23: f.v in V2 by A2, A21, FUNCT_1:3;
      then f.v in dom(f2") by A4, FUNCT_1:33;
      then f2".(f.v) in rng(f2") by FUNCT_1:3;
      then A24: f2".(f.v) in dom f2 by FUNCT_1:33;
      then (the_Source_of G2).(f2".(f.v)) = f2.(f2".(f.v)) &
        (the_Target_of G2).(f2".(f.v)) = f2.(f2".(f.v)) by A4, FUNCT_4:13;
      then A25: (the_Source_of G2).(f2".(f.v)) = f.v &
        (the_Target_of G2).(f2".(f.v))=f.v by A4, A23, FUNCT_1:35;
      f2".(f.v) in the_Edges_of G2 by A4, A24, XBOOLE_0:def 3;
      then f2".((F0_V|V1).v) Joins f.v,f.v,G2 by A22, A25, GLIB_000:def 13;
      then f2".(((F0_V|V1)*f1).e) Joins f.v,f.w,G2 by A3, A19, A20, FUNCT_1:13;
      then (f2"*((F0_V|V1)*f1)).e Joins f.v,f.w,G2 by A3, A12, A19, FUNCT_1:13;
      hence g.e Joins f.v,f.w,G2 by A19, RELAT_1:36;
    end;
  end;
  then reconsider F = [f,g] as PGraphMapping of G1, G2 by GLIB_010:8;
  take F;
  thus F_V = F0_V;
  A26: dom F0_E misses dom h by A3, A8, XBOOLE_1:63;
  hence F_E | dom F0_E = F0_E by FUNCT_4:33;
  :: show the properties
  hereby
    assume F0 is non empty;
    then dom F_V <> {};
    hence F is non empty;
  end;
  thus A27: F0 is total implies F is total
  proof
    assume F0 is total;
    then A28: dom F0_V = the_Vertices_of G3 & dom F0_E = the_Edges_of G3
      by GLIB_010:def 11;
    :: here A1 cannot be substituted by A2
    then A29: dom F_V = the_Vertices_of G1 by A1, Def5;
    dom F_E = the_Edges_of G1 by A3, A8, A28, FUNCT_4:def 1;
    hence F is total by A29, GLIB_010:def 11;
  end;
  thus A30: F0 is onto implies F is onto
  proof
    assume F0 is onto;
    then A31: rng F0_V = the_Vertices_of G4 & rng F0_E = the_Edges_of G4
      by GLIB_010:def 12;
    :: here A2 instead of A1 works again...
    then A32: rng F_V = the_Vertices_of G2 by A2, Def5;
    rng F_E = the_Edges_of G2 by A4, A10, A26, A31, NECKLACE:6;
    hence F is onto by A32, GLIB_010:def 12;
  end;
  thus A33: F0 is one-to-one implies F is one-to-one
  proof
    assume A34: F0 is one-to-one;
    rng F0_E misses E2 by A4, XBOOLE_1:63;
    then F_V is one-to-one & F_E is one-to-one by A2, A10, A34, FUNCT_4:92;
    hence F is one-to-one by GLIB_010:def 13;
  end;
  thus A35: F0 is directed implies F is directed
  proof
    assume A36: F0 is directed;
    now
      let e,v,w be object;
      assume A37: e in dom F_E & v in dom F_V & w in dom F_V;
      assume A38: e DJoins v,w,G1;
      per cases by A37, FUNCT_4:12;
      suppose A39: e in dom F0_E;
        then e DJoins v,w,G3 by A38, GLIB_006:71;
        then A40: F0_E.e DJoins F0_V.v,F0_V.w,G4
          by A36, A37, A39, GLIB_010:def 14;
        not e in E1 by A3, A37, A39, XBOOLE_0:5;
        then g.e DJoins f.v,f.w,G4 by A8, A40, FUNCT_4:11;
        hence F_E.e DJoins F_V.v,F_V.w,G2 by GLIB_006:70;
      end;
      suppose e in dom h;
        then A41: e in E1 & g.e = h.e by A8, FUNCT_4:13;
        then (the_Source_of G1).e = f1.e &
          (the_Target_of G1).e = f1.e by A3, FUNCT_4:13;
        then A42: v = f1.e & w = f1.e by A38, GLIB_000:def 14;
        then A43: v in V1 by A3, A41, FUNCT_1:3;
        then A44: f.v = (F0_V|V1).v by FUNCT_1:49;
        then A45: f.v in V2 by A2, A43, FUNCT_1:3;
        then f.v in dom(f2") by A4, FUNCT_1:33;
        then f2".(f.v) in rng(f2") by FUNCT_1:3;
        then A46: f2".(f.v) in dom f2 by FUNCT_1:33;
        then (the_Source_of G2).(f2".(f.v)) = f2.(f2".(f.v)) &
          (the_Target_of G2).(f2".(f.v)) = f2.(f2".(f.v)) by A4, FUNCT_4:13;
        then A47: (the_Source_of G2).(f2".(f.v)) = f.v &
          (the_Target_of G2).(f2".(f.v))=f.v
          by A4, A45, FUNCT_1:35;
        f2".(f.v) in the_Edges_of G2 by A4, A46, XBOOLE_0:def 3;
        then f2".((F0_V|V1).v) DJoins f.v,f.v,G2 by A44, A47, GLIB_000:def 14;
        then f2".(((F0_V|V1)*f1).e) DJoins f.v,f.w,G2
          by A3, A41, A42, FUNCT_1:13;
        then (f2"*((F0_V|V1)*f1)).e DJoins f.v,f.w,G2
          by A3, A12, A41, FUNCT_1:13;
        hence F_E.e DJoins F_V.v,F_V.w,G2 by A41, RELAT_1:36;
      end;
    end;
    hence F is directed by GLIB_010:def 14;
  end;
  thus F0 is weak_SG-embedding implies F is weak_SG-embedding by A27, A33;
  thus F0 is isomorphism implies F is isomorphism by A27, A30, A33;
  thus F0 is Disomorphism implies F is Disomorphism by A27, A30, A33, A35;
end;

theorem
  for G3 being _Graph, G4 being G3-isomorphic _Graph
  for G1 being addLoops of G3 for G2 being addLoops of G4
  holds G2 is G1-isomorphic
proof
  let G3 be _Graph, G4 be G3-isomorphic _Graph;
  let G1 be addLoops of G3;
  let G2 be addLoops of G4;
  consider F0 being PGraphMapping of G3, G4 such that
    A1: F0 is isomorphism by GLIB_010:def 23;
  A2: dom(F0_V | the_Vertices_of G3) = the_Vertices_of G3
    by A1, GLIB_010:def 11;
  rng(F0_V | the_Vertices_of G3) = the_Vertices_of G4
    by A1, GLIB_010:def 12;
  then consider F being PGraphMapping of G1, G2 such that
    F_V = F0_V & F_E | dom F0_E = F0_E and
    F0 is non empty  implies F is non empty and
    F0 is total implies F is total and
    F0 is onto implies F is onto and
    F0 is one-to-one implies F is one-to-one and
    F0 is directed implies F is directed and
    F0 is weak_SG-embedding implies F is weak_SG-embedding and
    A3: F0 is isomorphism implies F is isomorphism and
    F0 is Disomorphism implies F is Disomorphism by A1, A2, Th29;
  thus thesis by A1, A3, GLIB_010:def 23;
end;

theorem
  for G3 being _Graph, G4 being G3-Disomorphic _Graph
  for G1 being addLoops of G3 for G2 being addLoops of G4
  holds G2 is G1-Disomorphic
proof
  let G3 be _Graph, G4 be G3-Disomorphic _Graph;
  let G1 be addLoops of G3;
  let G2 be addLoops of G4;
  consider F0 being PGraphMapping of G3, G4 such that
    A1: F0 is Disomorphism by GLIB_010:def 24;
  A2: dom(F0_V | the_Vertices_of G3) = the_Vertices_of G3
    by A1, GLIB_010:def 11;
  rng(F0_V | the_Vertices_of G3) = the_Vertices_of G4
    by A1, GLIB_010:def 12;
  then consider F being PGraphMapping of G1, G2 such that
    F_V = F0_V & F_E | dom F0_E = F0_E and
    F0 is non empty  implies F is non empty and
    F0 is total implies F is total and
    F0 is onto implies F is onto and
    F0 is one-to-one implies F is one-to-one and
    F0 is directed implies F is directed and
    F0 is weak_SG-embedding implies F is weak_SG-embedding and
    F0 is isomorphism implies F is isomorphism and
    A3: F0 is Disomorphism implies F is Disomorphism by A1, A2, Th29;
  thus thesis by A1, A3, GLIB_010:def 24;
end;

theorem
  for G3, G4 being _Graph, V being set
  for G1 being addLoops of G3, V, G2 being addLoops of G4, V
  st G3 == G4 holds G2 is G1-Disomorphic
proof
  let G3, G4 be _Graph, V be set;
  let G1 be addLoops of G3, V, G2 be addLoops of G4, V;
  assume A1: G3 == G4;
  per cases;
  suppose A2: V c= the_Vertices_of G3;
    consider F0 being PGraphMapping of G3, G4 such that
      A3: F0 = id G3 & F0 is Disomorphism by A1, GLIBPRE0:77;
    A4: F0_V | V is one-to-one by A3, FUNCT_1:52;
    A5: dom(F0_V | V) = dom F0_V /\ V by RELAT_1:61
      .= V by A2, A3, XBOOLE_1:28;
    A6: rng(F0_V | V) = (id G3)_V.:V by A3, RELAT_1:115
      .= V by A2, FUNCT_1:92;
    consider F being PGraphMapping of G1, G2 such that
      F_V = F0_V & F_E | dom F0_E = F0_E and
      F0 is non empty  implies F is non empty and
      F0 is total implies F is total and
      F0 is onto implies F is onto and
      F0 is one-to-one implies F is one-to-one and
      F0 is directed implies F is directed and
      F0 is weak_SG-embedding implies F is weak_SG-embedding and
      F0 is isomorphism implies F is isomorphism and
      A7: F0 is Disomorphism implies F is Disomorphism
      by A2, A4, A5, A6, Th29;
    thus thesis by A3, A7, GLIB_010:def 24;
  end;
  suppose not V c= the_Vertices_of G3;
    then G1 == G3 & not V c= the_Vertices_of G4 by A1, Def5, GLIB_000:def 34;
    then G1 == G4 & G2 == G4 by A1, Def5, GLIB_000:85;
    hence thesis by GLIB_000:85,GLIBPRE0:78;
  end;
end;

theorem
  for G3 being _Graph, V, E being set, G4 being reverseEdgeDirections of G3, E
  for G1 being addLoops of G3, V, G2 being addLoops of G4, V
  holds G2 is G1-isomorphic
proof
  let G3 be _Graph, V, E be set, G4 be reverseEdgeDirections of G3, E;
  let G1 be addLoops of G3, V, G2 be addLoops of G4, V;
  per cases;
  suppose A1: V c= the_Vertices_of G3;
    consider F0 being PGraphMapping of G3, G4 such that
      A2: F0 = id G3 & F0 is isomorphism by GLIBPRE0:79;
    A3: F0_V | V is one-to-one by A2, FUNCT_1:52;
    A4: dom(F0_V | V) = dom F0_V /\ V by RELAT_1:61
      .= V by A1, A2, XBOOLE_1:28;
    A5: rng(F0_V | V) = (id G3)_V.:V by A2, RELAT_1:115
      .= V by A1, FUNCT_1:92;
    consider F being PGraphMapping of G1, G2 such that
      F_V = F0_V & F_E | dom F0_E = F0_E and
      F0 is non empty  implies F is non empty and
      F0 is total implies F is total and
      F0 is onto implies F is onto and
      F0 is one-to-one implies F is one-to-one and
      F0 is directed implies F is directed and
      F0 is weak_SG-embedding implies F is weak_SG-embedding and
      A6: F0 is isomorphism implies F is isomorphism and
      F0 is Disomorphism implies F is Disomorphism
      by A1, A3, A4, A5, Th29;
    thus thesis by A2, A6, GLIB_010:def 23;
  end;
  suppose not V c= the_Vertices_of G3;
    then G1 == G3 & not V c= the_Vertices_of G4 by Def5, GLIB_007:4;
    then A7: G1 == G3 & G2 == G4 by Def5;
    then G2 is reverseEdgeDirections of G3, E by GLIB_007:2;
    then G3 is reverseEdgeDirections of G2, E by GLIB_007:3;
    then G1 is reverseEdgeDirections of G2, E by A7, GLIB_007:2;
    then G2 is reverseEdgeDirections of G1, E by GLIB_007:3;
    hence thesis by GLIBPRE0:80;
  end;
end;

theorem
  for G3 being _Graph, E, V being set, G4 being reverseEdgeDirections of G3, E
  for G1 being addLoops of G3, V, G2 being reverseEdgeDirections of G1, E
  st E c= the_Edges_of G3 holds G2 is addLoops of G4, V
proof
  let G3 be _Graph, E, V be set, G4 be reverseEdgeDirections of G3, E;
  let G1 be addLoops of G3, V, G2 be reverseEdgeDirections of G1, E;
  assume A1: E c= the_Edges_of G3;
  A2: the_Vertices_of G2 = the_Vertices_of G1 by GLIB_007:4
    .= the_Vertices_of G3 by Th15
    .= the_Vertices_of G4 by GLIB_007:4;
  the_Edges_of G3 c= the_Edges_of G1 by GLIB_006:def 9;
  then A3: E c= the_Edges_of G1 by A1, XBOOLE_1:1;
  A4: G2 is Supergraph of G4 by A1, GLIBPRE0:52;
  per cases;
  suppose A5: V c= the_Vertices_of G3;
    then A6: V c= the_Vertices_of G4 by GLIB_007:4;
    now
      consider D being set, f being one-to-one Function such that
        A7: D misses the_Edges_of G3 & the_Edges_of G1 = the_Edges_of G3 \/ D &
          dom f = D & rng f = V & the_Source_of G1 = the_Source_of G3 +* f &
          the_Target_of G1 = the_Target_of G3 +* f by A5, Def5;
      take D, f;
      thus D misses the_Edges_of G4 by A7, GLIB_007:4;
      thus the_Edges_of G2 = the_Edges_of G1 by GLIB_007:4
        .= the_Edges_of G4 \/ D by A7, GLIB_007:4;
      thus dom f = D & rng f = V by A7;
      E = the_Edges_of G3 /\ E by A1, XBOOLE_1:28;
      then A8: dom f misses the_Edges_of G3 /\ E by A1, A7, XBOOLE_1:63;
      then dom f misses dom the_Source_of G3 /\ E by FUNCT_2:def 1;
      then A9: dom f misses dom((the_Source_of G3)|E) by RELAT_1:61;
      dom f misses dom the_Target_of G3 /\ E by A8, FUNCT_2:def 1;
      then A10: dom f misses dom((the_Target_of G3)|E) by RELAT_1:61;
      A11: (the_Source_of G1)|E
         = ((the_Source_of G1)|the_Edges_of G3)|E by A1, RELAT_1:74
        .= (the_Source_of G3)|E by GLIB_006:69;
      A12: (the_Target_of G1)|E
         = ((the_Target_of G1)|the_Edges_of G3)|E by A1, RELAT_1:74
        .= (the_Target_of G3)|E by GLIB_006:69;
      thus the_Source_of G2
         = the_Source_of G1 +* ((the_Target_of G1)|E) by A3, GLIB_007:def 1
        .= the_Source_of G3 +* (f +* ((the_Target_of G3)|E))
          by A7, A12, FUNCT_4:14
        .= the_Source_of G3 +* ((the_Target_of G3)|E +* f) by A10, FUNCT_4:35
        .= the_Source_of G3 +* ((the_Target_of G3)|E) +* f by FUNCT_4:14
        .= the_Source_of G4 +* f by A1, GLIB_007:def 1;
      thus the_Target_of G2
         = the_Target_of G1 +* ((the_Source_of G1)|E) by A3, GLIB_007:def 1
        .= the_Target_of G3 +* (f +* ((the_Source_of G3)|E))
          by A7, A11, FUNCT_4:14
        .= the_Target_of G3 +* ((the_Source_of G3)|E +* f) by A9, FUNCT_4:35
        .= the_Target_of G3 +* ((the_Source_of G3)|E) +* f by FUNCT_4:14
        .= the_Target_of G4 +* f by A1, GLIB_007:def 1;
    end;
    hence thesis by A2, A4, A6, Def5;
  end;
  suppose not V c= the_Vertices_of G3;
    then A13: G1 == G3 & not V c= the_Vertices_of G4 by Def5, GLIB_007:4;
    G3 is reverseEdgeDirections of G4, E by GLIB_007:3;
    then G1 is reverseEdgeDirections of G4, E by A13, GLIB_007:2;
    then G4 is reverseEdgeDirections of G1, E by GLIB_007:3;
    then G2 == G4 by GLIB_007:1;
    hence thesis by A4, A13, Def5;
  end;
end;

theorem
  for G3 being _Graph, V1 being Subset of the_Vertices_of G3
  for V2 being non empty Subset of the_Vertices_of G3
  for G4 being inducedSubgraph of G3, V2
  for G1 being addLoops of G3, V1, G2 being inducedSubgraph of G1, V2
  holds G2 is addLoops of G4, V1 /\ V2
proof
  let G3 be _Graph, V1 be Subset of the_Vertices_of G3;
  let V2 be non empty Subset of the_Vertices_of G3;
  let G4 be inducedSubgraph of G3, V2;
  let G1 be addLoops of G3, V1, G2 be inducedSubgraph of G1, V2;
  A1: the_Vertices_of G1 = the_Vertices_of G3 by Def5;
  A2: the_Vertices_of G4 = V2 by GLIB_000:def 37;
  A3: the_Vertices_of G2 = V2 by A1, GLIB_000:def 37;
  A4: the_Edges_of G4 = G3.edgesBetween(V2) by GLIB_000:def 37;
  A5: the_Edges_of G2 = G1.edgesBetween(V2) by A1, GLIB_000:def 37;
  consider E being set, f being one-to-one Function such that
    A6: E misses the_Edges_of G3 & the_Edges_of G1 = the_Edges_of G3 \/ E &
      dom f = E & rng f = V1 & the_Source_of G1 = the_Source_of G3 +* f &
      the_Target_of G1 = the_Target_of G3 +* f by Def5;
  set g = f|(f"V2);
  set D = dom g;
  :: show that the_Edges_of G2 = the_Edges_of G4 \/ D
  now
    let e be object;
    thus e in the_Edges_of G2 implies e in the_Edges_of G4 or e in D
    proof
      assume e in the_Edges_of G2;
      then A7: e in the_Edges_of G1 & (the_Source_of G1).e in V2 &
        (the_Target_of G1).e in V2 by A5, GLIB_000:31;
      then per cases by A6, XBOOLE_0:def 3;
      suppose A8: e in the_Edges_of G3;
        then (the_Source_of G3).e in V2 & (the_Target_of G3).e in V2
          by A7, GLIB_006:def 9;
        hence thesis by A4, A8, GLIB_000:31;
      end;
      suppose A9: e in E;
        then (the_Source_of G1).e = f.e by A6, FUNCT_4:13;
        then e in f"V2 by A6, A7, A9, FUNCT_1:def 7;
        hence thesis by A6, A9, RELAT_1:57;
      end;
    end;
    assume e in the_Edges_of G4 or e in D;
    then per cases;
    suppose e in the_Edges_of G4;
      then A10: e in the_Edges_of G3 & (the_Source_of G3).e in V2 &
        (the_Target_of G3).e in V2 by A4, GLIB_000:31;
      then A11: (the_Source_of G3).e = (the_Source_of G1).e &
        (the_Target_of G3).e = (the_Target_of G1).e by GLIB_006:def 9;
      the_Edges_of G3 c= the_Edges_of G1 by GLIB_006:def 9;
      hence e in the_Edges_of G2 by A5, A10, A11, GLIB_000:31;
    end;
    suppose e in D;
      then e in f"V2 by RELAT_1:57;
      then A12: e in dom f & f.e in V2 by FUNCT_1:def 7;
      then A13: (the_Source_of G1).e in V2 & (the_Target_of G1).e in V2
        by A6, FUNCT_4:13;
      e in the_Edges_of G1 by A6, A12, XBOOLE_0:def 3;
      hence e in the_Edges_of G2 by A5, A13, GLIB_000:31;
    end;
  end;
  then A14: the_Edges_of G2 = the_Edges_of G4 \/ D by XBOOLE_0:def 3;
  :: show that G2 is Supergraph of G4
  now
    thus the_Vertices_of G4 c= the_Vertices_of G2 by A2, A3;
    thus the_Edges_of G4 c= the_Edges_of G2 by A14, XBOOLE_1:7;
    let e be set;
    set v = (the_Source_of G4).e, w = (the_Target_of G4).e;
    assume A15: e in the_Edges_of G4;
    then e DJoins v,w,G4 by GLIB_000:def 14;
    then A16: e DJoins v,w,G3 by GLIB_000:72;
    then A17: e DJoins v,w,G1 by GLIB_006:70;
    then A18: v = (the_Source_of G1).e & w = (the_Target_of G1).e
      by GLIB_000:def 14;
    v = (the_Source_of G3).e & w = (the_Target_of G3).e
      by A16, GLIB_000:def 14;
    then A19: e in the_Edges_of G3 & v in V2 & w in V2 by A4, A15, GLIB_000:31;
    the_Edges_of G3 c= the_Edges_of G1 by GLIB_006:def 9;
    then e in G1.edgesBetween(V2) by A19, A18, GLIB_000:31;
    then e DJoins v,w,G2 by A5, A17, GLIB_000:73;
    hence (the_Source_of G2).e = (the_Source_of G4).e &
      (the_Target_of G2).e = (the_Target_of G4).e by GLIB_000:def 14;
  end;
  then A20: G2 is Supergraph of G4 by GLIB_006:def 9;
  A21: V1 /\ V2 c= the_Vertices_of G4 by A2, XBOOLE_1:17;
  :: show addLoops properties
  now
    thus the_Vertices_of G2 = the_Vertices_of G4 by A2, A3;
    reconsider D as set;
    reconsider g as one-to-one Function by FUNCT_1:52;
    take D,g;
    D c= dom f & the_Edges_of G4 c= the_Edges_of G3 by RELAT_1:60;
    hence A22: D misses the_Edges_of G4 by A6, XBOOLE_1:64;
    thus the_Edges_of G2 = the_Edges_of G4 \/ D by A14;
    thus dom g = D;
    thus rng g = f.:f"V2 by RELAT_1:115
      .= V2 /\ f.:dom f by FUNCT_1:78
      .= V1 /\ V2 by A6, RELAT_1:113;
    :: first the_Source_of G2
    A23: dom the_Source_of G2 = the_Edges_of G4 \/ D by A14, FUNCT_2:def 1
      .= dom the_Source_of G4 \/ dom g by FUNCT_2:def 1
      .= dom(the_Source_of G4 +* g) by FUNCT_4:def 1;
    now
      let x be object;
      assume x in dom the_Source_of G2;
      then A24: x in the_Edges_of G4 \/ D by A14;
      then per cases by XBOOLE_0:def 3;
      suppose A25: x in the_Edges_of G4;
        then A26: not x in D by A22, A24, XBOOLE_0:5;
        thus (the_Source_of G2).x
           = (the_Source_of G4).x by A20, A25, GLIB_006:def 9
          .= (the_Source_of G4 +* g).x by A26, FUNCT_4:11;
      end;
      suppose A27: x in D;
        then A28: x in f"V2 by RELAT_1:57;
        then A29: x in dom f & f.x in V2 by FUNCT_1:def 7;
        then A30: (the_Source_of G1).x = f.x & (the_Target_of G1).x = f.x
          by A6, FUNCT_4:13;
        x in the_Edges_of G1 by A6, A29, XBOOLE_0:def 3;
        then A31: x Joins f.x,f.x,G1 by A30, GLIB_000:def 13;
        then x in G1.edgesBetween(V2) by A29, GLIB_000:32;
        then x Joins f.x,f.x,G2 by A5, A31, GLIB_000:73;
        hence (the_Source_of G2).x = f.x by GLIB_000:def 13
          .= g.x by A28, FUNCT_1:49
          .= (the_Source_of G4 +* g).x by A27, FUNCT_4:13;
      end;
    end;
    hence the_Source_of G2 = the_Source_of G4 +* g by A23, FUNCT_1:2;
    :: analogous for the_Target_of G2
    A32: dom the_Target_of G2 = the_Edges_of G4 \/ D by A14, FUNCT_2:def 1
      .= dom the_Target_of G4 \/ dom g by FUNCT_2:def 1
      .= dom(the_Target_of G4 +* g) by FUNCT_4:def 1;
    now
      let x be object;
      assume x in dom the_Target_of G2;
      then A33: x in the_Edges_of G4 \/ D by A14;
      then per cases by XBOOLE_0:def 3;
      suppose A34: x in the_Edges_of G4;
        then A35: not x in D by A22, A33, XBOOLE_0:5;
        thus (the_Target_of G2).x
           = (the_Target_of G4).x by A20, A34, GLIB_006:def 9
          .= (the_Target_of G4 +* g).x by A35, FUNCT_4:11;
      end;
      suppose A36: x in D;
        then A37: x in f"V2 by RELAT_1:57;
        then A38: x in dom f & f.x in V2 by FUNCT_1:def 7;
        then A39: (the_Source_of G1).x = f.x & (the_Target_of G1).x = f.x
          by A6, FUNCT_4:13;
        x in the_Edges_of G1 by A6, A38, XBOOLE_0:def 3;
        then A40: x Joins f.x,f.x,G1 by A39, GLIB_000:def 13;
        then x in G1.edgesBetween(V2) by A38, GLIB_000:32;
        then x Joins f.x,f.x,G2 by A5, A40, GLIB_000:73;
        hence (the_Target_of G2).x = f.x by GLIB_000:def 13
          .= g.x by A37, FUNCT_1:49
          .= (the_Target_of G4 +* g).x by A36, FUNCT_4:13;
      end;
    end;
    hence the_Target_of G2 = the_Target_of G4 +* g by A32, FUNCT_1:2;
  end;
  hence G2 is addLoops of G4, V1 /\ V2 by A20, A21, Def5;
end;

theorem
  for G2 being _Graph, V being set, G1 being addLoops of G2, V
  for v1 being Vertex of G1, v2 being Vertex of G2
  st not v1 in V & v1 = v2 holds
    (v1 is isolated iff v2 is isolated) &
    (v1 is endvertex iff v2 is endvertex)
proof
  let G2 be _Graph, V be set, G1 be addLoops of G2, V;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: not v1 in V & v1 = v2;
  per cases;
  suppose V c= the_Vertices_of G2;
    then consider E being set, f being one-to-one Function such that
      A2: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
        dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f &
        the_Target_of G1 = the_Target_of G2 +* f by Def5;
    A3: G2 is Subgraph of G1 by GLIB_006:57;
    hence v1 is isolated implies v2 is isolated by A1, GLIB_000:83;
    thus v2 is isolated implies v1 is isolated
    proof
      assume A4: v2 is isolated;
      assume not v1 is isolated;
      then v1.allNeighbors() <> {} by GLIB_008:7;
      then consider w being object such that
        A5: w in v1.allNeighbors() by XBOOLE_0:def 1;
      consider e being object such that
        A6: e Joins v1,w,G1 by A5, GLIB_000:71;
      per cases by A1, A6, GLIB_006:72;
      suppose A7: e Joins v2,w,G2;
        w is set by TARSKI:1;
        then w in v2.allNeighbors() by A7, GLIB_000:71;
        hence contradiction by A4, GLIB_008:7;
      end;
      suppose A8: not e in the_Edges_of G2;
        e in the_Edges_of G2 \/ E by A2, A6, GLIB_000:def 13;
        then A9: e in dom f by A2, A8, XBOOLE_0:5;
        then (the_Source_of G1).e = f.e & (the_Target_of G1).e = f.e
          by A2, FUNCT_4:13;
        then v1 = f.e by A6, GLIB_000:def 13;
        hence contradiction by A1, A2, A9, FUNCT_1:3;
      end;
    end;
    thus v1 is endvertex implies v2 is endvertex
    proof
      assume A10: v1 is endvertex;
      assume not v2 is endvertex;
      then A11: v2 is isolated by A1, A3, A10, GLIB_000:84;
      consider e being object such that
        A12: v1.edgesInOut() = {e} & not e Joins v1,v1,G1
        by A10, GLIB_000:def 51;
      e in v1.edgesInOut() by A12, TARSKI:def 1;
      then A13: e in the_Edges_of G1 & ((the_Source_of G1).e = v1
        or (the_Target_of G1).e = v1) by GLIB_000:61;
      then per cases;
      suppose A14: (the_Source_of G1).e = v1;
        set w = (the_Target_of G1).e;
        e Joins v1,w,G1 by A13, A14, GLIB_000:def 13;
        then e Joins v2,w,G2 by A1, A12, Th17;
        then w in v2.allNeighbors() by GLIB_000:71;
        hence contradiction by A11, GLIB_008:7;
      end;
      suppose A15: (the_Target_of G1).e = v1;
        set w = (the_Source_of G1).e;
        e Joins v1,w,G1 by A13, A15, GLIB_000:def 13;
        then e Joins v2,w,G2 by A1, A12, Th17;
        then w in v2.allNeighbors() by GLIB_000:71;
        hence contradiction by A11, GLIB_008:7;
      end;
    end;
    thus v2 is endvertex implies v1 is endvertex
    proof
      assume v2 is endvertex;
      then consider e being object such that
        A16: v2.edgesInOut() = {e} & not e Joins v2,v2,G2 by GLIB_000:def 51;
      :: show that v1.edgesInOut() = {e}
      now
        let e0 be object;
        hereby
          assume e0 in v1.edgesInOut();
          then A17: e0 in the_Edges_of G1 & ((the_Source_of G1).e0 = v1
            or (the_Target_of G1).e0 = v1) by GLIB_000:61;
          then per cases;
          suppose A18: (the_Source_of G1).e0 = v1;
            set w = (the_Target_of G1).e0;
            A19: e0 Joins v1,w,G1 by A17, A18, GLIB_000:def 13;
            e0 in the_Edges_of G2
            proof
              assume not e0 in the_Edges_of G2;
              then A20: e0 in dom f by A2, A17, XBOOLE_0:def 3;
              then v1 = f.e0 by A2, A17, FUNCT_4:13;
              hence contradiction by A1, A2, A20, FUNCT_1:3;
            end;
            then e0 in v2.edgesInOut() by A1, A19, GLIB_006:72, GLIB_000:62;
            hence e0 = e by A16, TARSKI:def 1;
          end;
          suppose A21: (the_Target_of G1).e0 = v1;
            set w = (the_Source_of G1).e0;
            A22: e0 Joins v1,w,G1 by A17, A21, GLIB_000:def 13;
            e0 in the_Edges_of G2
            proof
              assume not e0 in the_Edges_of G2;
              then A23: e0 in dom f by A2, A17, XBOOLE_0:def 3;
              then v1 = f.e0 by A2, A17, FUNCT_4:13;
              hence contradiction by A1, A2, A23, FUNCT_1:3;
            end;
            then e0 in v2.edgesInOut() by A1, A22, GLIB_006:72, GLIB_000:62;
            hence e0 = e by A16, TARSKI:def 1;
          end;
        end;
        assume e0 = e;
        then e0 in v2.edgesInOut() by A16, TARSKI:def 1;
        hence e0 in v1.edgesInOut() by A1, A3, GLIB_000:78, TARSKI:def 3;
      end;
      then A24: v1.edgesInOut() = {e} by TARSKI:def 1;
      e in v2.edgesInOut() by A16, TARSKI:def 1;
      then not e Joins v1,v1,G1 by A1, A16, GLIB_006:72;
      hence v1 is endvertex by A24, GLIB_000:def 51;
    end;
  end;
  suppose not V c= the_Vertices_of G2;
    then G1 == G2 by Def5;
    hence thesis by A1, GLIB_000:97;
  end;
end;

theorem Th37:
  for G2 being _Graph, V being set, G1 being addLoops of G2, V
  for P being Path of G1
  holds P is Path of G2 or
    ex v,e being object st e Joins v,v,G1 & P = G1.walkOf(v,e,v)
proof
  let G2 be _Graph, V be set, G1 be addLoops of G2, V;
  let P be Path of G1;
  A1: G2 is Subgraph of G1 by GLIB_006:57;
  per cases;
  suppose P is non trivial & P.edges() c= the_Edges_of G2;
    hence thesis by A1, GLIB_001:169, GLIB_001:176;
  end;
  suppose A2: P is trivial;
    P.first() in the_Vertices_of G1;
    then P.first() in the_Vertices_of G2 by Th15;
    hence thesis by A1, A2, GLIB_001:168;
  end;
  suppose not V c= the_Vertices_of G2;
    then G1 == G2 by Def5;
    hence thesis by GLIB_001:179, GLIB_001:181;
  end;
  suppose A3: not P.edges() c= the_Edges_of G2 &
      V c= the_Vertices_of G2;
    then P.edges() \ the_Edges_of G2 <> {} by XBOOLE_1:37;
    then consider e being object such that
      A4: e in P.edges() \ the_Edges_of G2 by XBOOLE_0:def 1;
    consider E being set, f being one-to-one Function such that
      A5: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
        dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f &
        the_Target_of G1 = the_Target_of G2 +* f by A3, Def5;
    A6: not e in the_Edges_of G2 & e in the_Edges_of G1 by A4, XBOOLE_0:def 5;
    then e in dom f by A5, XBOOLE_0:def 3;
    then (the_Source_of G1).e = f.e & (the_Target_of G1).e = f.e
      by A5, FUNCT_4:13;
    then A7: e Joins f.e,f.e,G1 by A6, GLIB_000:def 13;
    e in P.edges() by A4, XBOOLE_0:def 5;
    then consider n being odd Element of NAT such that
      A8: n < len P & P.(n+1) = e by GLIB_001:100;
    P.(n+1) Joins P.n, P.(n+2), G1 by A8, GLIB_001:def 3;
    then A9: P.n = f.e & P.(n+2) = f.e by A7, A8, GLIB_000:15;
    n+0 < n+2 & n+2 <= len P by A8, CHORD:4, XREAL_1:8;
    then A10: n = 1 & n+2 = len P by A9, GLIB_001:def 28;
    A11: P = <*f.e,e,f.e*> by A8, A9, A10, FINSEQ_1:45;
    now
      reconsider e as object;
      reconsider v = f.e as object;
      take v,e;
      thus e Joins v,v,G1 by A7;
      hence P = G1.walkOf(v,e,v) by A11, GLIB_001:def 5;
    end;
    hence thesis;
  end;
end;

theorem
  for G2 being _Graph, V being set, G1 being addLoops of G2, V
  for W being Walk of G1 st W.edges() misses G1.loops() \ G2.loops()
  holds W is Walk of G2
proof
  let G2 be _Graph, V be set, G1 be addLoops of G2, V;
  let W be Walk of G1;
  A1: G2 is Subgraph of G1 by GLIB_006:57;
  assume A2: W.edges() misses G1.loops() \ G2.loops();
  per cases;
  suppose V c= the_Vertices_of G2;
    then consider E being set, f being one-to-one Function such that
      A3: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
        dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f &
        the_Target_of G1 = the_Target_of G2 +* f by Def5;
    now
      let e be object;
      assume A4: e in E;
      then A5: (the_Source_of G1).e = f.e & (the_Target_of G1).e = f.e
        by A3, FUNCT_4:13;
      A6: e in the_Edges_of G2 \/ E by A4, XBOOLE_0:def 3;
      then e Joins f.e,f.e,G1 by A3, A5, GLIB_000:def 13;
      then A7: e in G1.loops() by GLIB_009:def 2;
      not e in G2.loops() by A3, A4, A6, XBOOLE_0:5;
      hence e in G1.loops() \ G2.loops() by A7, XBOOLE_0:def 5;
    end;
    then W.edges() misses E by A2, XBOOLE_1:63, TARSKI:def 3;
    then A8: W.edges() c= the_Edges_of G2 by A3, XBOOLE_1:73;
    W.vertices() c= the_Vertices_of G1;
    then W.vertices() c= the_Vertices_of G2 by Th15;
    hence thesis by A1, A8, GLIB_001:170;
  end;
  suppose not V c= the_Vertices_of G2;
    then G1 == G2 by Def5;
    hence W is Walk of G2 by GLIB_001:179;
  end;
end;

registration
  let G be _Graph;
  cluster -> loopfull for addLoops of G;
  coherence
  proof
    let G1 be addLoops of G;
    let v be Vertex of G1;
    consider E being set, f being one-to-one Function such that
      A1: E misses the_Edges_of G & the_Edges_of G1 = the_Edges_of G \/ E &
        dom f = E & rng f = the_Vertices_of G &
        the_Source_of G1 = the_Source_of G +* f &
        the_Target_of G1 = the_Target_of G +* f by Def5;
    v in the_Vertices_of G1;
    then v in the_Vertices_of G by Th15;
    then consider e being object such that
      A2: e in dom f & f.e = v by A1, FUNCT_1:def 3;
    take e;
    A3: (the_Source_of G1).e = f.e & (the_Target_of G1).e = f.e
      by A1, A2, FUNCT_4:13;
    e in the_Edges_of G1 by A1, A2, XBOOLE_0:def 3;
    hence e Joins v,v,G1 by A2, A3, GLIB_000:def 13;
  end;
  let V be non empty Subset of the_Vertices_of G;
  cluster -> non loopless for addLoops of G, V;
  coherence
  proof
    let G1 be addLoops of G, V;
    consider E being set, f being one-to-one Function such that
      A4: E misses the_Edges_of G & the_Edges_of G1 = the_Edges_of G \/ E &
        dom f = E & rng f = V & the_Source_of G1 = the_Source_of G +* f &
        the_Target_of G1 = the_Target_of G +* f by Def5;
    now
      reconsider v = the Element of V as object;
      take v;
      consider e being object such that
        A5: e in dom f & f.e = v by A4, FUNCT_1:def 3;
      take e;
      A6: (the_Source_of G1).e = f.e & (the_Target_of G1).e = f.e
        by A4, A5, FUNCT_4:13;
      e in the_Edges_of G1 by A4, A5, XBOOLE_0:def 3;
      hence e DJoins v,v,G1 by A5, A6, GLIB_000:def 14;
    end;
    hence thesis by GLIB_009:17;
  end;
end;

theorem Th39:
  for G2 being _Graph, V being set, G1 being addLoops of G2, V
  holds G1 is _finite iff G2 is _finite
proof
  let G2 be _Graph, V be set, G1 be addLoops of G2, V;
  per cases;
  suppose A1: V c= the_Vertices_of G2;
    then consider E being set, f being one-to-one Function such that
      A2: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E &
        dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f &
        the_Target_of G1 = the_Target_of G2 +* f by Def5;
    thus G1 is _finite implies G2 is _finite;
    assume A3: G2 is _finite;
    then E is finite by A1, A2, CARD_1:59;
    then A4: the_Edges_of G1 is finite by A2, A3;
    the_Vertices_of G2 = the_Vertices_of G1 by Th15;
    hence thesis by A3, A4, GLIB_000:def 17;
  end;
  suppose not V c= the_Vertices_of G2;
    then G1 == G2 by Def5;
    hence thesis by GLIB_000:89;
  end;
end;

registration
  let G be _finite _Graph, V be set;
  cluster -> _finite for addLoops of G, V;
  coherence by Th39;
end;

registration
  let G be non _finite _Graph, V be set;
  cluster -> non _finite for addLoops of G, V;
  coherence;
end;

theorem Th40:
  for G2 being _Graph, V being set, G1 being addLoops of G2, V
  holds G1 is connected iff G2 is connected
proof
  let G2 be _Graph, V be set, G1 be addLoops of G2, V;
  hereby
    assume A1: G1 is connected;
    now
      let u,v be Vertex of G2;
      u is Vertex of G1 & v is Vertex of G1 by Th15;
      then consider W1 being Walk of G1 such that
        A2: W1 is_Walk_from u,v by A1, GLIB_002:def 1;
      set P1 = the Path of W1;
      per cases by Th37;
      suppose P1 is Path of G2;
        then reconsider P2 = P1 as Walk of G2;
        take P2;
        P1 is_Walk_from u,v by A2, GLIB_001:160;
        hence P2 is_Walk_from u,v by GLIB_001:19;
      end;
      suppose ex w,e being object st e Joins w,w,G1 & P1 = G1.walkOf(w,e,w);
        then consider w,e being object such that
          A3: e Joins w,w,G1 & P1 = G1.walkOf(w,e,w);
        A4: P1.first() = w & P1.last() = w by A3, GLIB_001:15;
        P1 is_Walk_from u,v by A2, GLIB_001:160;
        then A5: P1.first() = u & P1.last() = v by GLIB_001:def 23;
        reconsider W2 = G2.walkOf(u) as Walk of G2;
        take W2;
        thus W2 is_Walk_from u,v by A4, A5, GLIB_001:13;
      end;
    end;
    hence G2 is connected by GLIB_002:def 1;
  end;
  assume A6: G2 is connected;
  now
    let u,v be Vertex of G1;
    u is Vertex of G2 & v is Vertex of G2 by Th15;
    then consider W2 being Walk of G2 such that
      A7: W2 is_Walk_from u,v by A6, GLIB_002:def 1;
    G2 is Subgraph of G1 by GLIB_006:57;
    then reconsider W1 = W2 as Walk of G1 by GLIB_001:167;
    take W1;
    thus W1 is_Walk_from u,v by A7, GLIB_001:19;
  end;
  hence G1 is connected by GLIB_002:def 1;
end;

registration
  let G be connected _Graph, V be set;
  cluster -> connected for addLoops of G, V;
  coherence by Th40;
end;

registration
  let G be non connected _Graph, V be set;
  cluster -> non connected for addLoops of G, V;
  coherence by Th40;
end;

theorem Th41:
  for G2 being _Graph, V being set, G1 being addLoops of G2, V
  holds G1 is chordal iff G2 is chordal
proof
  let G2 be _Graph, V be set, G1 be addLoops of G2, V;
  hereby
    assume A1: G1 is chordal;
    now
      let P2 be Walk of G2;
      assume A2: P2.length() > 3 & P2 is Cycle-like;
      reconsider P1 = P2 as Walk of G1 by GLIB_006:75;
      A3: P1.length() = P2.length() & P1 is Cycle-like
        by A2, GLIB_006:76, GLIB_001:114;
      now
        consider m, n being odd Nat such that
          A4: m+2 < n & n <= len P1 & P1.m <> P1.n and
          A5: ex e being object st e Joins P1.m,P1.n,G1 and
          A6: for f being object st f in P1.edges()
            holds not f Joins P1.m,P1.n,G1
          by A1, A2, A3, CHORD:def 10, CHORD:def 11;
        take m,n;
        thus m+2 < n & n <= len P2 & P2.m <> P2.n by A4;
        thus ex e being object st e Joins P2.m,P2.n,G2
        proof
          consider e being object such that
            A7: e Joins P1.m,P1.n,G1 by A5;
          take e;
          thus e Joins P2.m,P2.n,G2 by A4, A7, Th17;
        end;
        thus for f being object st f in P2.edges()
          holds not f Joins P2.m,P2.n,G2
        proof
          let f be object;
          assume f in P2.edges();
          then f in P1.edges() by GLIB_001:110;
          then not f Joins P1.m,P1.n,G1 by A6;
          hence not f Joins P2.m,P2.n,G2 by A4, Th17;
        end;
      end;
      hence P2 is chordal by CHORD:def 10;
    end;
    hence G2 is chordal by CHORD:def 11;
  end;
  assume A8: G2 is chordal;
  now
    let P1 be Walk of G1;
    assume A9: P1.length() > 3 & P1 is Cycle-like;
    P1 is Walk of G2
    proof
      assume not P1 is Walk of G2;
      then consider v,e being object such that
        A10: e Joins v,v,G1 & P1 = G1.walkOf(v,e,v) by A9, Th37;
      2*1+1 = len P1 by A10, GLIB_001:14
        .= 2*P1.length()+1 by GLIB_001:112;
      hence contradiction by A9;
    end;
    then reconsider P2 = P1 as Walk of G2;
    A11: P1.length() = P2.length() & P2 is Cycle-like
      by A9, GLIB_006:76, GLIB_001:114;
    now
      consider m, n being odd Nat such that
        A12: m+2 < n & n <= len P2 & P2.m <> P2.n and
        A13: ex e being object st e Joins P2.m,P2.n,G2 and
        A14: for f being object st f in P2.edges()
          holds not f Joins P2.m,P2.n,G2
        by A8, A9, A11, CHORD:def 10, CHORD:def 11;
      take m,n;
      thus m+2 < n & n <= len P1 & P1.m <> P1.n by A12;
      thus ex e being object st e Joins P1.m,P1.n,G1
      proof
        consider e being object such that
          A15: e Joins P2.m,P2.n,G2 by A13;
        take e;
        thus e Joins P1.m,P1.n,G1 by A12, A15, Th17;
      end;
      thus for f being object st f in P1.edges()
        holds not f Joins P1.m,P1.n,G1
      proof
        let f be object;
        assume f in P1.edges();
        then f in P2.edges() by GLIB_001:110;
        then not f Joins P2.m,P2.n,G2 by A14;
        hence not f Joins P1.m,P1.n,G1 by A12, Th17;
      end;
    end;
    hence P1 is chordal by CHORD:def 10;
  end;
  hence thesis by CHORD:def 11;
end;

registration
  let G be chordal _Graph, V be set;
  cluster -> chordal for addLoops of G, V;
  coherence by Th41;
end;

:: non chordal clustering will be done later

registration
  let G be non edgeless _Graph, V be set;
  cluster -> non edgeless for addLoops of G, V;
  coherence;
end;

registration
  let G be loopfull _Graph, V be set;
  cluster -> loopfull for addLoops of G, V;
  coherence
  proof
    let G1 be addLoops of G, V;
    the_Vertices_of G1 = the_Vertices_of G by Th15;
    hence thesis by Th5;
  end;
end;

registration
  let G be simple _Graph, V be set;
  cluster -> non-multi for addLoops of G, V;
  coherence
  proof
    let G2 be addLoops of G, V;
    per cases;
    suppose A1: V c= the_Vertices_of G;
      now
        let e1,e2,v1,v2 be object;
        assume A2: e1 Joins v1,v2,G2 & e2 Joins v1,v2,G2;
        per cases;
        suppose A3: v1 = v2;
          consider E being set, f being one-to-one Function such that
            E misses the_Edges_of G and
            A4: the_Edges_of G2 = the_Edges_of G \/ E and
            A5: dom f = E & rng f = V and
            A6: the_Source_of G2 = the_Source_of G +* f and
            the_Target_of G2 = the_Target_of G +* f by A1, Def5;
          A7: not e1 in the_Edges_of G
          proof
            assume A8: e1 in the_Edges_of G;
            then e1 Joins v1,v1,G by A2, A3, GLIB_006:72;
            then (the_Source_of G).e1 = v1 & (the_Target_of G).e1 = v1
              by GLIB_000:def 13;
            hence contradiction by A8, GLIB_000:def 18;
          end;
          A9: not e2 in the_Edges_of G
          proof
            assume A10: e2 in the_Edges_of G;
            then e2 Joins v1,v1,G by A2, A3, GLIB_006:72;
            then (the_Source_of G).e2 = v1 & (the_Target_of G).e2 = v1
              by GLIB_000:def 13;
            hence contradiction by A10, GLIB_000:def 18;
          end;
          e1 in the_Edges_of G2 by A2, GLIB_000:def 13;
          then A11: e1 in E by A4, A7, XBOOLE_0:def 3;
          e2 in the_Edges_of G2 by A2, GLIB_000:def 13;
          then A12: e2 in E by A4, A9, XBOOLE_0:def 3;
          f.e1 = (the_Source_of G2).e1 by A5, A6, A11, FUNCT_4:13
            .= v1 by A2, A3, GLIB_000:def 13
            .= (the_Source_of G2).e2 by A2, A3, GLIB_000:def 13
            .= f.e2 by A5, A6, A12, FUNCT_4:13;
          hence e1 = e2 by A5, A11, A12, FUNCT_1:def 4;
        end;
        suppose v1 <> v2;
          then e1 Joins v1,v2,G & e2 Joins v1,v2,G by A2, Th17;
          hence e1 = e2 by GLIB_000:def 20;
        end;
      end;
      hence thesis by GLIB_000:def 20;
    end;
    suppose not V c= the_Vertices_of G;
      then G == G2 by Def5;
      hence thesis by GLIB_000:89;
    end;
  end;
end;

registration
  let G be Dsimple _Graph, V be set;
  cluster -> non-Dmulti for addLoops of G, V;
  coherence
  proof
    let G2 be addLoops of G, V;
    per cases;
    suppose A1: V c= the_Vertices_of G;
      now
        let e1,e2,v1,v2 be object;
        assume A2: e1 DJoins v1,v2,G2 & e2 DJoins v1,v2,G2;
        per cases;
        suppose A3: v1 = v2;
          consider E being set, f being one-to-one Function such that
            E misses the_Edges_of G and
            A4: the_Edges_of G2 = the_Edges_of G \/ E and
            A5: dom f = E & rng f = V and
            A6: the_Source_of G2 = the_Source_of G +* f and
            the_Target_of G2 = the_Target_of G +* f by A1, Def5;
          A7: not e1 in the_Edges_of G
          proof
            assume A8: e1 in the_Edges_of G;
            then e1 DJoins v1,v1,G by A2, A3, GLIB_006:71;
            then (the_Source_of G).e1 = v1 & (the_Target_of G).e1 = v1
              by GLIB_000:def 14;
            hence contradiction by A8, GLIB_000:def 18;
          end;
          A9: not e2 in the_Edges_of G
          proof
            assume A10: e2 in the_Edges_of G;
            then e2 DJoins v1,v1,G by A2, A3, GLIB_006:71;
            then (the_Source_of G).e2 = v1 & (the_Target_of G).e2 = v1
              by GLIB_000:def 14;
            hence contradiction by A10, GLIB_000:def 18;
          end;
          e1 in the_Edges_of G2 by A2, GLIB_000:def 14;
          then A11: e1 in E by A4, A7, XBOOLE_0:def 3;
          e2 in the_Edges_of G2 by A2, GLIB_000:def 14;
          then A12: e2 in E by A4, A9, XBOOLE_0:def 3;
          f.e1 = (the_Source_of G2).e1 by A5, A6, A11, FUNCT_4:13
            .= v1 by A2, GLIB_000:def 14
            .= (the_Source_of G2).e2 by A2, GLIB_000:def 14
            .= f.e2 by A5, A6, A12, FUNCT_4:13;
          hence e1 = e2 by A5, A11, A12, FUNCT_1:def 4;
        end;
        suppose v1 <> v2;
          then e1 DJoins v1,v2,G & e2 DJoins v1,v2,G by A2, Th16;
          hence e1 = e2 by GLIB_000:def 21;
        end;
      end;
      hence thesis by GLIB_000:def 21;
    end;
    suppose not V c= the_Vertices_of G;
      then G == G2 by Def5;
      hence thesis by GLIB_000:89;
    end;
  end;
end;

theorem Th42:
  for G2 being _Graph, V being Subset of the_Vertices_of G2
  for G1 being addLoops of G2, V, v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & v1 in V ex e being object
    st e DJoins v1,v1,G1 & not e in the_Edges_of G2 &
      v1.edgesIn() = v2.edgesIn()\/{e} & v1.edgesOut() = v2.edgesOut()\/{e} &
      v1.edgesInOut() = v2.edgesInOut() \/ {e}
proof
  let G2 be _Graph, V be Subset of the_Vertices_of G2;
  let G1 be addLoops of G2, V, v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & v1 in V;
  consider E being set, f being one-to-one Function such that
    A2: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E and
    A3: dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f and
    A4: the_Target_of G1 = the_Target_of G2 +* f by Def5;
  consider e being object such that
    A5: e in dom f & f.e = v1 by A1, A3, FUNCT_1:def 3;
  take e;
  A6: e in the_Edges_of G1 by A2, A3, A5, XBOOLE_0:def 3;
  A7: (the_Source_of G1).e = v1 by A3, A5, FUNCT_4:13;
  (the_Target_of G1).e = v1 by A4, A5, FUNCT_4:13;
  hence A8: e DJoins v1,v1,G1 by A6, A7, GLIB_000:def 14;
  thus not e in the_Edges_of G2
  proof
    assume e in the_Edges_of G2;
    then e in E /\ the_Edges_of G2 by A3, A5, XBOOLE_0:def 4;
    hence contradiction by A2, XBOOLE_0:def 7;
  end;
  now
    let x be object;
    hereby
      assume x in v1.edgesIn();
      then consider w being set such that
        A9: x DJoins w,v1,G1 by GLIB_000:57;
      per cases by A9, GLIB_006:71;
      suppose A10: x DJoins w,v1,G2;
        x is set by TARSKI:1;
        then x in v2.edgesIn() by A1, A10, GLIB_000:57;
        hence x in v2.edgesIn() \/ {e} by XBOOLE_0:def 3;
      end;
      suppose A11: not x in the_Edges_of G2;
        x in the_Edges_of G1 by A9, GLIB_000:def 14;
        then A12: x in E by A2, A11, XBOOLE_0:def 3;
        f.x = (the_Target_of G1).x by A3, A4, A12, FUNCT_4:13
          .= v1 by A9, GLIB_000:def 14;
        then x = e by A3, A5, A12, FUNCT_1:def 4;
        then x in {e} by TARSKI:def 1;
        hence x in v2.edgesIn() \/ {e} by XBOOLE_0:def 3;
      end;
    end;
    assume x in v2.edgesIn() \/ {e};
    then per cases by XBOOLE_0:def 3;
    suppose A13: x in v2.edgesIn();
      G2 is Subgraph of G1 by GLIB_006:57;
      then v2.edgesIn() c= v1.edgesIn() by A1, GLIB_000:78;
      hence x in v1.edgesIn() by A13;
    end;
    suppose x in {e};
      then x = e & e is set by TARSKI:def 1;
      hence x in v1.edgesIn() by A8, GLIB_000:57;
    end;
  end;
  hence A14: v1.edgesIn() = v2.edgesIn() \/ {e} by TARSKI:2;
  now
    let x be object;
    hereby
      assume x in v1.edgesOut();
      then consider w being set such that
        A15: x DJoins v1,w,G1 by GLIB_000:59;
      per cases by A15, GLIB_006:71;
      suppose A16: x DJoins v1,w,G2;
        x is set by TARSKI:1;
        then x in v2.edgesOut() by A1, A16, GLIB_000:59;
        hence x in v2.edgesOut() \/ {e} by XBOOLE_0:def 3;
      end;
      suppose A17: not x in the_Edges_of G2;
        x in the_Edges_of G1 by A15, GLIB_000:def 14;
        then A18: x in E by A2, A17, XBOOLE_0:def 3;
        f.x = (the_Source_of G1).x by A3, A18, FUNCT_4:13
          .= v1 by A15, GLIB_000:def 14;
        then x = e by A3, A5, A18, FUNCT_1:def 4;
        then x in {e} by TARSKI:def 1;
        hence x in v2.edgesOut() \/ {e} by XBOOLE_0:def 3;
      end;
    end;
    assume x in v2.edgesOut() \/ {e};
    then per cases by XBOOLE_0:def 3;
    suppose A19: x in v2.edgesOut();
      G2 is Subgraph of G1 by GLIB_006:57;
      then v2.edgesOut() c= v1.edgesOut() by A1, GLIB_000:78;
      hence x in v1.edgesOut() by A19;
    end;
    suppose x in {e};
      then x = e & e is set by TARSKI:def 1;
      hence x in v1.edgesOut() by A8, GLIB_000:59;
    end;
  end;
  hence A20: v1.edgesOut() = v2.edgesOut() \/ {e} by TARSKI:2;
  thus v1.edgesInOut() = v2.edgesInOut() \/ {e} by A14, A20, XBOOLE_1:5;
end;

theorem
  for G2 being _Graph, V being Subset of the_Vertices_of G2
  for G1 being addLoops of G2, V, v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & v1 in V holds
    v1.inDegree() = v2.inDegree() +` 1 & v1.outDegree() = v2.outDegree() +` 1 &
    v1.degree() = v2.degree() +` 2
proof
  let G2 be _Graph, V be Subset of the_Vertices_of G2;
  let G1 be addLoops of G2, V, v1 be Vertex of G1, v2 be Vertex of G2;
  assume v1 = v2 & v1 in V;
  then consider e being object such that
    A1: e DJoins v1,v1,G1 & not e in the_Edges_of G2 and
    A2: v1.edgesIn() = v2.edgesIn() \/ {e} and
    A3: v1.edgesOut() = v2.edgesOut() \/ {e} and
    v1.edgesInOut() = v2.edgesInOut() \/ {e} by Th42;
  not e in v2.edgesIn() by A1;
  hence A4: v1.inDegree() = v2.inDegree() +` card {e}
      by A2, CARD_2:35, ZFMISC_1:50
    .= v2.inDegree() +` 1 by CARD_1:30;
  not e in v2.edgesOut() by A1;
  hence v1.outDegree() = v2.outDegree() +` card {e}
      by A3, CARD_2:35, ZFMISC_1:50
    .= v2.outDegree() +` 1 by CARD_1:30;
  hence v1.degree()
     = v2.inDegree() +` (1 +` (v2.outDegree() +` 1)) by A4, CARD_2:19
    .= v2.inDegree() +` (v2.outDegree() +` (1 +` 1)) by CARD_2:19
    .= v2.degree() +` 2 by CARD_2:19;
end;

theorem
  for G2 being _Graph, V being Subset of the_Vertices_of G2
  for G1 being addLoops of G2, V, v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & not v1 in V holds
    v1.edgesIn() = v2.edgesIn() & v1.inDegree() = v2.inDegree() &
    v1.edgesOut() = v2.edgesOut() & v1.outDegree() = v2.outDegree() &
    v1.edgesInOut() = v2.edgesInOut() & v1.degree() = v2.degree()
proof
  let G2 be _Graph, V be Subset of the_Vertices_of G2;
  let G1 be addLoops of G2, V, v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & not v1 in V;
  consider E being set, f being one-to-one Function such that
    A2: E misses the_Edges_of G2 & the_Edges_of G1 = the_Edges_of G2 \/ E and
    A3: dom f = E & rng f = V & the_Source_of G1 = the_Source_of G2 +* f and
    A4: the_Target_of G1 = the_Target_of G2 +* f by Def5;
  A5: G2 is Subgraph of G1 by GLIB_006:57;
  then A6: v2.edgesIn() c= v1.edgesIn() by A1, GLIB_000:78;
  now
    let e be object;
    assume e in v1.edgesIn();
    then consider x being set such that
      A7: e DJoins x,v1,G1 by GLIB_000:57;
    e in the_Edges_of G2
    proof
      assume A8: not e in the_Edges_of G2;
      e in the_Edges_of G1 by A7, GLIB_000:def 14;
      then A9: e in E by A2, A8, XBOOLE_0:def 3;
      v1 = (the_Target_of G1).e by A7, GLIB_000:def 14
        .= f.e by A3, A4, A9, FUNCT_4:13;
      hence contradiction by A1, A3, A9, FUNCT_1:3;
    end;
    hence e in v2.edgesIn() by A1, A7, GLIB_006:71, GLIB_000:57;
  end;
  then v1.edgesIn() c= v2.edgesIn() by TARSKI:def 3;
  hence A10: v1.edgesIn() = v2.edgesIn() by A6, XBOOLE_0:def 10;
  hence v1.inDegree() = v2.inDegree();
  A11: v2.edgesOut() c= v1.edgesOut() by A1, A5, GLIB_000:78;
  now
    let e be object;
    assume e in v1.edgesOut();
    then consider x being set such that
      A12: e DJoins v1,x,G1 by GLIB_000:59;
    e in the_Edges_of G2
    proof
      assume A13: not e in the_Edges_of G2;
      e in the_Edges_of G1 by A12, GLIB_000:def 14;
      then A14: e in E by A2, A13, XBOOLE_0:def 3;
      v1 = (the_Source_of G1).e by A12, GLIB_000:def 14
        .= f.e by A3, A14, FUNCT_4:13;
      hence contradiction by A1, A3, A14, FUNCT_1:3;
    end;
    hence e in v2.edgesOut() by A1, A12, GLIB_006:71, GLIB_000:59;
  end;
  then v1.edgesOut() c= v2.edgesOut() by TARSKI:def 3;
  hence A15: v1.edgesOut() = v2.edgesOut() by A11, XBOOLE_0:def 10;
  hence v1.outDegree() = v2.outDegree();
  thus thesis by A10, A15;
end;

begin :: Directed Graph Complement with Loops

definition
  let G be _Graph;
  mode DLGraphComplement of G -> non-Dmulti _Graph means
  :Def6:
  the_Vertices_of it = the_Vertices_of G &
  the_Edges_of it misses the_Edges_of G &
  for v,w being Vertex of G holds
    (ex e1 being object st e1 DJoins v,w,G) iff
    (not ex e2 being object st e2 DJoins v,w,it);
  existence
  proof
    set E = {[the_Edges_of G,[v,w]] where v is Vertex of G, w is Vertex of G
      : not ex e being object st e DJoins v,w,G};
    deffunc S(object) = $1`2`1;
    consider s being Function such that
      A1: dom s = E & for x being object st x in E holds s.x = S(x)
      from FUNCT_1:sch 3;
    now
      let y be object;
      assume y in rng s;
      then consider x being object such that
        A2: x in dom s & s.x = y by FUNCT_1:def 3;
      consider v, w being Vertex of G such that
        A3: x = [the_Edges_of G,[v,w]] and
        not ex e being object st e DJoins v,w,G by A1, A2;
      y = [the_Edges_of G,[v,w]]`2`1 by A1, A2, A3
        .= v;
      hence y in the_Vertices_of G;
    end;
    then reconsider s as Function of E, the_Vertices_of G
      by A1, TARSKI:def 3, FUNCT_2:2;
    deffunc T(object) = $1`2`2;
    consider t being Function such that
      A4: dom t = E & for x being object st x in E holds t.x = T(x)
      from FUNCT_1:sch 3;
    now
      let y be object;
      assume y in rng t;
      then consider x being object such that
        A5: x in dom t & t.x = y by FUNCT_1:def 3;
      consider v, w being Vertex of G such that
        A6: x = [the_Edges_of G,[v,w]] and
        not ex e being object st e DJoins v,w,G by A4, A5;
      y = [the_Edges_of G,[v,w]]`2`2 by A4, A5, A6
        .= w;
      hence y in the_Vertices_of G;
    end;
    then reconsider t as Function of E, the_Vertices_of G
      by A4, TARSKI:def 3, FUNCT_2:2;
    set H = createGraph(the_Vertices_of G,E,s,t);
    now
      let e1,e2,v1,v2 be object;
      assume A7: e1 DJoins v1,v2,H & e2 DJoins v1,v2,H;
      then e1 in the_Edges_of H by GLIB_000:def 14;
      then A8: e1 in E;
      then consider a,b being Vertex of G such that
        A9: e1 = [the_Edges_of G,[a,b]] and
        not ex e being object st e DJoins a,b,G;
      A10: v1 = (the_Source_of H).e1 by A7, GLIB_000:def 14
        .= s.e1
        .= [the_Edges_of G,[a,b]]`2`1 by A1, A8, A9
        .= a;
      A11: v2 = (the_Target_of H).e1 by A7, GLIB_000:def 14
        .= t.e1
        .= [the_Edges_of G,[a,b]]`2`2 by A4, A8, A9
        .= b;
      e2 in the_Edges_of H by A7, GLIB_000:def 14;
      then A12: e2 in E;
      then consider c,d being Vertex of G such that
        A13: e2 = [the_Edges_of G,[c,d]] and
        not ex e being object st e DJoins c,d,G;
      A14: v1 = (the_Source_of H).e2 by A7, GLIB_000:def 14
        .= s.e2
        .= [the_Edges_of G,[c,d]]`2`1 by A1, A12, A13
        .= c;
      v2 = (the_Target_of H).e2 by A7, GLIB_000:def 14
        .= t.e2
        .= [the_Edges_of G,[c,d]]`2`2 by A4, A12, A13
        .= d;
      hence e1 = e2 by A9, A10, A11, A13, A14;
    end;
    then reconsider H as non-Dmulti _Graph by GLIB_000:def 21;
    take H;
    thus the_Vertices_of H = the_Vertices_of G;
    E /\ the_Edges_of G = {}
    proof
      assume E /\ the_Edges_of G <> {};
      then consider x being object such that
        A15: x in E /\ the_Edges_of G by XBOOLE_0:def 1;
      reconsider x as set by TARSKI:1;
      x in E by A15, XBOOLE_0:def 4;
      then consider v,w being Vertex of G such that
        A16: x = [the_Edges_of G,[v,w]] and
        not ex e being object st e DJoins v,w,G;
      A17: x in the_Edges_of G by A15, XBOOLE_0:def 4;
      A18: the_Edges_of G in {the_Edges_of G} by TARSKI:def 1;
      x = {{the_Edges_of G,[v,w]},{the_Edges_of G}} by A16, TARSKI:def 5;
      then {the_Edges_of G} in x by TARSKI:def 2;
      hence contradiction by A17, A18, XREGULAR:7;
    end;
    then the_Edges_of H /\ the_Edges_of G = {};
    hence the_Edges_of H misses the_Edges_of G by XBOOLE_0:def 7;
    let v,w be Vertex of G;
    hereby
      given e1 being object such that
        A19: e1 DJoins v,w,G;
      given e2 being object such that
        A20: e2 DJoins v,w,H;
      e2 in the_Edges_of H by A20, GLIB_000:def 14;
      then A21: e2 in E;
      then consider a,b being Vertex of G such that
        A22: e2 = [the_Edges_of G,[a,b]] and
        A23: not ex e being object st e DJoins a,b,G;
      A24: v = (the_Source_of H).e2 by A20, GLIB_000:def 14
        .= s.e2
        .= [the_Edges_of G,[a,b]]`2`1 by A1, A21, A22
        .= a;
      w = (the_Target_of H).e2 by A20, GLIB_000:def 14
        .= t.e2
        .= [the_Edges_of G,[a,b]]`2`2 by A4, A21, A22
        .= b;
      hence contradiction by A19, A23, A24;
    end;
    set e2 = [the_Edges_of G,[v,w]];
    now
      assume not ex e1 being object st e1 DJoins v,w,G;
      then A25: e2 in E;
      then A26: e2 in the_Edges_of H;
      A27: v = [the_Edges_of G,[v,w]]`2`1
        .= s.e2 by A1, A25
        .= (the_Source_of H).e2;
      w = [the_Edges_of G,[v,w]]`2`2
        .= t.e2 by A4, A25
        .= (the_Target_of H).e2;
      hence e2 DJoins v,w,H by A26, A27, GLIB_000:def 14;
    end;
    hence thesis;
  end;
end;

theorem Th45:
  for G1, G2, G3 being _Graph, G4 being DLGraphComplement of G1
  st G1 == G2 & G3 == G4 holds G3 is DLGraphComplement of G2
proof
  let G1, G2, G3 be _Graph, G4 be DLGraphComplement of G1;
  assume A1: G1 == G2 & G3 == G4;
  then the_Vertices_of G4 = the_Vertices_of G3 &
    the_Edges_of G4 = the_Edges_of G3 by GLIB_000:def 34;
  then the_Vertices_of G1 = the_Vertices_of G3 &
    the_Edges_of G3 misses the_Edges_of G1 by Def6;
  then A2: the_Vertices_of G3 = the_Vertices_of G2 &
    the_Edges_of G3 misses the_Edges_of G2 by A1, GLIB_000:def 34;
  A3: G3 is non-Dmulti by A1, GLIB_000:89;
  now
    let v,w be Vertex of G2;
    A4: v is Vertex of G1 & w is Vertex of G1 by A1, GLIB_000:def 34;
    hereby
      given e1 being object such that
        A5: e1 DJoins v,w,G2;
      A6: e1 DJoins v,w,G1 by A1, A5, GLIB_000:88;
      thus not ex e2 being object st e2 DJoins v,w,G3
      proof
        given e2 being object such that
          A7: e2 DJoins v,w,G3;
        e2 DJoins v,w,G4 by A1, A7, GLIB_000:88;
        hence contradiction by A4, A6, Def6;
      end;
    end;
    assume A8: not ex e2 being object st e2 DJoins v,w,G3;
    not ex e2 being object st e2 DJoins v,w,G4
    proof
      given e2 being object such that
        A9: e2 DJoins v,w,G4;
      e2 DJoins v,w,G3 by A1, A9, GLIB_000:88;
      hence contradiction by A8;
    end;
    then consider e1 being object such that
      A10: e1 DJoins v,w,G1 by A4, Def6;
    take e1;
    thus e1 DJoins v,w,G2 by A1, A10, GLIB_000:88;
  end;
  hence thesis by A2, A3, Def6;
end;

registration
  let G be _Graph;
  cluster plain for DLGraphComplement of G;
  existence
  proof
    set G1 = the DLGraphComplement of G;
    set G2 = G1 | _GraphSelectors;
    G1 == G1 & G1 == G2 by GLIB_009:9;
    then reconsider G2 as DLGraphComplement of G by Th45;
    take G2;
    thus thesis;
  end;
end;

theorem Th46:
  for G1 being _Graph, G2 being DLGraphComplement of G1, e1,e2,v,w being object
  holds e1 DJoins v,w,G1 implies not e2 DJoins v,w,G2
proof
  let G1 be _Graph, G2 be DLGraphComplement of G1, e1,e2,v,w be object;
  assume A1: e1 DJoins v,w,G1;
  then e1 Joins v,w,G1 by GLIB_000:16;
  then v in the_Vertices_of G1 & w in the_Vertices_of G1 by GLIB_000:13;
  hence thesis by A1, Def6;
end;

theorem Th47:
  for G1 being _Graph, G2 being removeDParallelEdges of G1
  for G3 being DLGraphComplement of G1
  holds G3 is DLGraphComplement of G2
proof
  let G1 be _Graph, G2 be removeDParallelEdges of G1;
  let G3 be DLGraphComplement of G1;
  consider E being RepDEdgeSelection of G1 such that
    A1: G2 is inducedSubgraph of G1, the_Vertices_of G1, E by GLIB_009:def 8;
  the_Vertices_of G1 c= the_Vertices_of G1 &
    the_Edges_of G1 = G1.edgesBetween(the_Vertices_of G1) by GLIB_000:34;
  then A2: the_Vertices_of G2 = the_Vertices_of G1 & the_Edges_of G2 = E
    by A1, GLIB_000:def 37;
  then A3: the_Vertices_of G3 = the_Vertices_of G2 by Def6;
  the_Edges_of G3 misses the_Edges_of G1 by Def6;
  then A4: the_Edges_of G3 misses the_Edges_of G2 by XBOOLE_1:63;
  now
    let v,w be Vertex of G2;
    A5: v is Vertex of G1 & w is Vertex of G1 by GLIB_000:def 33;
    reconsider v1=v, w1=w as Vertex of G1 by GLIB_000:def 33;
    hereby
      given e2 being object such that
        A6: e2 DJoins v,w,G2;
      A7: e2 DJoins v,w,G1 by A6, GLIB_000:72;
      given e3 being object such that
        A8: e3 DJoins v,w,G3;
      thus contradiction by A7, A8, Th46;
    end;
    assume not ex e3 being object st e3 DJoins v,w,G3;
    then consider e1 being object such that
      A9: e1 DJoins v,w,G1 by A5, Def6;
    consider e2 being object such that
      A10: e2 DJoins v,w,G1 & e2 in E and
      for e9 being object st e9 DJoins v,w,G1 & e9 in E holds e9 = e2
      by A9, GLIB_009:def 6;
    take e2;
    thus e2 DJoins v,w,G2 by A2, A10, GLIB_000:73;
  end;
  hence thesis by A3, A4, Def6;
end;

theorem Th48:
  for G1, G2 being _Graph
  for G3 being removeDParallelEdges of G1, G4 being removeDParallelEdges of G2
  for G5 being DLGraphComplement of G1, G6 being DLGraphComplement of G2
  st G4 is G3-Disomorphic holds G6 is G5-Disomorphic
proof
  let G1, G2 be _Graph;
  let G3 be removeDParallelEdges of G1, G4 be removeDParallelEdges of G2;
  let G5 be DLGraphComplement of G1, G6 be DLGraphComplement of G2;
  A1: G5 is DLGraphComplement of G3 & G6 is DLGraphComplement of G4 by Th47;
  assume G4 is G3-Disomorphic;
  then consider f being directed PVertexMapping of G3, G4 such that
    A2: f is Disomorphism by GLIB_011:50;
  A3: the_Vertices_of G3 = the_Vertices_of G5 &
    the_Vertices_of G4 = the_Vertices_of G6 by A1, Def6;
  then reconsider g = f as PartFunc of the_Vertices_of G5, the_Vertices_of G6;
  now
    let v,w,e be object;
    assume A4: v in dom g & w in dom g & e DJoins v,w,G5;
    then A5: not ex e3 being object st e3 DJoins v,w,G3 by A1, A3, Def6;
    thus ex e6 being object st e6 DJoins g.v,g.w,G6
    proof
      assume A6: not ex e6 being object st e6 DJoins g.v,g.w,G6;
      g.v in rng f & g.w in rng f by A4, FUNCT_1:3;
      then consider e4 being object such that
        A7: e4 DJoins g.v,g.w,G4 by A1, A6, Def6;
      consider e3 being object such that
        A8: e3 DJoins v,w,G3 by A2, A4, A7, GLIB_011:def 4;
      thus contradiction by A5, A8;
    end;
  end;
  then reconsider g as directed PVertexMapping of G5, G6 by GLIB_011:4;
  now
    let v,w,e6 be object;
    assume A9: v in dom g & w in dom g & e6 DJoins g.v,g.w,G6;
    then g.v in rng f & g.w in rng f by FUNCT_1:3;
    then A10: not ex e4 being object st e4 DJoins g.v,g.w,G4 by A1, A9, Def6;
    thus ex e5 being object st e5 DJoins v,w,G5
    proof
      assume not ex e5 being object st e5 DJoins v,w,G5;
      then consider e3 being object such that
        A11: e3 DJoins v,w,G3 by A1, A3, A9, Def6;
      consider e4 being object such that
        A12: e4 DJoins f.v,f.w,G4 by A9, A11, GLIB_011:def 2;
      thus contradiction by A10, A12;
    end;
  end;
  then g is Dcontinuous by GLIB_011:def 4;
  hence thesis by A2, A3, GLIB_011:50;
end;

theorem Th49:
  for G1 being _Graph, G2 being G1-Disomorphic _Graph
  for G3 being DLGraphComplement of G1, G4 being DLGraphComplement of G2
  holds G4 is G3-Disomorphic
proof
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  let G3 be DLGraphComplement of G1, G4 be DLGraphComplement of G2;
  set G5 = the removeDParallelEdges of G1;
  set G6 = the removeDParallelEdges of G2;
  G6 is G5-Disomorphic by GLIB_010:170;
  hence thesis by Th48;
end;

theorem Th50:
  for G1 being _Graph, G2, G3 being DLGraphComplement of G1
  holds G3 is G2-Disomorphic
proof
  let G1 be _Graph, G2, G3 be DLGraphComplement of G1;
  G1 is G1-Disomorphic by GLIB_010:53;
  hence thesis by Th49;
end;

theorem
  for G1 being _Graph, G2 being reverseEdgeDirections of G1
  for G3 being DLGraphComplement of G1, G4 being reverseEdgeDirections of G3
  holds G4 is DLGraphComplement of G2
proof
  let G1 be _Graph, G2 be reverseEdgeDirections of G1;
  let G3 be DLGraphComplement of G1, G4 be reverseEdgeDirections of G3;
  A1: the_Vertices_of G4 = the_Vertices_of G3 by GLIB_007:4
    .= the_Vertices_of G1 by Def6
    .= the_Vertices_of G2 by GLIB_007:4;
  the_Edges_of G3 misses the_Edges_of G1 by Def6;
  then the_Edges_of G4 misses the_Edges_of G1 by GLIB_007:4;
  then A2: the_Edges_of G4 misses the_Edges_of G2 by GLIB_007:4;
  now
    let v,w be Vertex of G2;
    A3: v is Vertex of G1 & w is Vertex of G1 by GLIB_007:4;
    hereby
      given e2 being object such that
        A4: e2 DJoins v,w,G2;
      e2 in the_Edges_of G2 by A4, GLIB_000:def 14;
      then e2 in the_Edges_of G1 by GLIB_007:4;
      then A5: e2 DJoins w,v,G1 by A4, GLIB_007:7;
      given e4 being object such that
        A6: e4 DJoins v,w,G4;
      e4 in the_Edges_of G4 by A6, GLIB_000:def 14;
      then e4 in the_Edges_of G3 by GLIB_007:4;
      then e4 DJoins w,v,G3 by A6, GLIB_007:7;
      hence contradiction by A5, Th46;
    end;
    assume A7: not ex e4 being object st e4 DJoins v,w,G4;
    not ex e3 being object st e3 DJoins w,v,G3
    proof
      given e3 being object such that
        A8: e3 DJoins w,v,G3;
      e3 in the_Edges_of G3 by A8, GLIB_000:def 14;
      then e3 DJoins v,w,G4 by A8, GLIB_007:7;
      hence contradiction by A7;
    end;
    then consider e1 being object such that
      A9: e1 DJoins w,v,G1 by A3, Def6;
    take e1;
    e1 in the_Edges_of G1 by A9, GLIB_000:def 14;
    hence e1 DJoins v,w,G2 by A9, GLIB_007:7;
  end;
  hence thesis by A1, A2, Def6;
end;

theorem Th52:
  for G1 being _Graph, V being non empty Subset of the_Vertices_of G1
  for G2 being inducedSubgraph of G1, V
  for G3 being DLGraphComplement of G1, G4 being inducedSubgraph of G3, V
  holds G4 is DLGraphComplement of G2
proof
  let G1 be _Graph, V be non empty Subset of the_Vertices_of G1;
  let G2 be inducedSubgraph of G1, V;
  let G3 be DLGraphComplement of G1, G4 be inducedSubgraph of G3, V;
  A1: V is non empty Subset of the_Vertices_of G3 by Def6;
  then A2: the_Vertices_of G4 = V by GLIB_000:def 37
    .= the_Vertices_of G2 by GLIB_000:def 37;
  A3: the_Edges_of G4 misses the_Edges_of G2
  proof
    assume the_Edges_of G4 meets the_Edges_of G2;
    then consider e being object such that
      A4: e in the_Edges_of G4 & e in the_Edges_of G2 by XBOOLE_0:3;
    A5: e in the_Edges_of G1 \/ the_Edges_of G3 by A4, XBOOLE_0:def 3;
    the_Edges_of G3 misses the_Edges_of G1 by Def6;
    hence contradiction by A4, A5, XBOOLE_0:5;
  end;
  now
    let v,w be Vertex of G2;
    hereby
      given e2 being object such that
        A6: e2 DJoins v,w,G2;
      A7: e2 DJoins v,w,G1 by A6, GLIB_000:72;
      given e4 being object such that
        A8: e4 DJoins v,w,G4;
      e4 DJoins v,w,G3 by A8, GLIB_000:72;
      hence contradiction by A7, Th46;
    end;
    assume A9: not ex e4 being object st e4 DJoins v,w,G4;
    ex e1 being object st e1 DJoins v,w,G1
    proof
      assume A10: not ex e1 being object st e1 DJoins v,w,G1;
      the_Vertices_of G2 c= the_Vertices_of G1;
      then v is Vertex of G1 & w is Vertex of G1 by TARSKI:def 3;
      then consider e3 being object such that
        A11: e3 DJoins v,w,G3 by A10, Def6;
      A12: e3 Joins v,w,G3 by A11, GLIB_000:16;
      the_Vertices_of G2 = V by GLIB_000:def 37;
      then e3 in G3.edgesBetween(V) by A12, GLIB_000:32;
      then e3 in the_Edges_of G4 & e3 is set by A1, GLIB_000:def 37;
      then e3 DJoins v,w,G4 by A11, GLIB_000:73;
      hence contradiction by A9;
    end;
    then consider e1 being object such that
      A13: e1 DJoins v,w,G1;
    take e1;
    A14: e1 Joins v,w,G1 by A13, GLIB_000:16;
    the_Vertices_of G2 = V by GLIB_000:def 37;
    then e1 in G1.edgesBetween(V) by A14, GLIB_000:32;
    then e1 in the_Edges_of G2 & e1 is set by GLIB_000:def 37;
    hence e1 DJoins v,w,G2 by A13, GLIB_000:73;
  end;
  hence thesis by A2, A3, Def6;
end;

theorem
  for G1 being _Graph, V being proper Subset of the_Vertices_of G1
  for G2 being removeVertices of G1, V
  for G3 being DLGraphComplement of G1, G4 being removeVertices of G3, V
  holds G4 is DLGraphComplement of G2
proof
  let G1 be _Graph, V be proper Subset of the_Vertices_of G1;
  let G2 be removeVertices of G1, V;
  let G3 be DLGraphComplement of G1, G4 be removeVertices of G3, V;
  the_Vertices_of G1 \ V is non empty Subset of the_Vertices_of G1 &
    the_Vertices_of G1 \ V = the_Vertices_of G3 \ V
    by Def6, XBOOLE_1:105, GLIBPRE0:6;
  hence thesis by Th52;
end;

:: involutiveness of graph complement (DLC case)
theorem
  for G1 being non-Dmulti _Graph, G2 being DLGraphComplement of G1
  holds G1 is DLGraphComplement of G2
proof
  let G1 be non-Dmulti _Graph, G2 be DLGraphComplement of G1;
  A1: the_Vertices_of G1 = the_Vertices_of G2 &
    the_Edges_of G1 misses the_Edges_of G2 by Def6;
  now
    let v,w be Vertex of G2;
    v is Vertex of G1 & w is Vertex of G1 by Def6;
    hence (ex e2 being object st e2 DJoins v,w,G2) iff
      (not ex e1 being object st e1 DJoins v,w,G1) by Def6;
  end;
  hence thesis by A1, Def6;
end;

theorem Th55:
  for G1 being _Graph, G2 being DLGraphComplement of G1
  holds G1.order() = G2.order() by Def6;

theorem Th56:
  for G1 being _Graph, G2 being DLGraphComplement of G1 holds
    (G1 is _trivial iff G2 is _trivial) &
    (G1 is loopfull iff G2 is loopless) &
    (G1 is loopless iff G2 is loopfull)
proof
  let G1 be _Graph, G2 be DLGraphComplement of G1;
  hereby
    assume G1 is _trivial;
    then 1 = G1.order() by GLIB_000:26
      .= G2.order() by Th55;
    hence G2 is _trivial by GLIB_000:26;
  end;
  hereby
    assume G2 is _trivial;
    then 1 = G2.order() by GLIB_000:26
      .= G1.order() by Th55;
    hence G1 is _trivial by GLIB_000:26;
  end;
  hereby
    assume A1: G1 is loopfull;
    now
      let v be object;
      given e2 being object such that
        A2: e2 DJoins v,v,G2;
      e2 Joins v,v,G2 by A2, GLIB_000:16;
      then v in the_Vertices_of G2 by GLIB_000:13;
      then v in the_Vertices_of G1 by Def6;
      then consider e1 being object such that
        A3: e1 DJoins v,v,G1 by A1, Th1;
      thus contradiction by A2, A3, Th46;
    end;
    hence G2 is loopless by GLIB_009:17;
  end;
  hereby
    assume A4: G2 is loopless;
    now
      let v be Vertex of G1;
      assume not ex e1 being object st e1 DJoins v,v,G1;
      then ex e2 being object st e2 DJoins v,v,G2 by Def6;
      hence contradiction by A4, GLIB_009:17;
    end;
    hence G1 is loopfull by Th1;
  end;
  hereby
    assume A5: G1 is loopless;
    now
      let v be Vertex of G2;
      A6: v is Vertex of G1 by Def6;
      assume not ex e2 being object st e2 DJoins v,v,G2;
      then ex e1 being object st e1 DJoins v,v,G1 by A6, Def6;
      hence contradiction by A5, GLIB_009:17;
    end;
    hence G2 is loopfull by Th1;
  end;
  hereby
    assume A7: G2 is loopfull;
    now
      let v be object;
      given e1 being object such that
        A8: e1 DJoins v,v,G1;
      e1 Joins v,v,G1 by A8, GLIB_000:16;
      then v in the_Vertices_of G1 by GLIB_000:13;
      then v in the_Vertices_of G2 by Def6;
      then consider e2 being object such that
        A9: e2 DJoins v,v,G2 by A7, Th1;
      thus contradiction by A8, A9, Th46;
    end;
    hence G1 is loopless by GLIB_009:17;
  end;
end;

registration
  let G be _trivial _Graph;
  cluster -> _trivial for DLGraphComplement of G;
  coherence by Th56;
end;

registration
  let G be non _trivial _Graph;
  cluster -> non _trivial for DLGraphComplement of G;
  coherence by Th56;
end;

registration
  let G be loopfull _Graph;
  cluster -> loopless for DLGraphComplement of G;
  coherence by Th56;
end;

registration
  let G be non loopfull _Graph;
  cluster -> non loopless for DLGraphComplement of G;
  coherence by Th56;
end;

registration
  let G be loopless _Graph;
  cluster -> loopfull for DLGraphComplement of G;
  coherence by Th56;
end;

registration
  let G be non loopless _Graph;
  cluster -> non loopfull for DLGraphComplement of G;
  coherence by Th56;
end;

theorem Th57:
  for G1 being _Graph, G2 being DLGraphComplement of G1
  st the_Edges_of G1 = G1.loops() holds G2 is complete
proof
  let G1 be _Graph, G2 be DLGraphComplement of G1;
  assume A1: the_Edges_of G1 = G1.loops();
  now
    let v,w be Vertex of G2;
    A2: v is Vertex of G1 & w is Vertex of G1 by Def6;
    assume A3: v <> w;
    not ex e1 being object st e1 DJoins v,w,G1
    proof
      given e1 being object such that
        A4: e1 DJoins v,w,G1;
      e1 Joins v,w,G1 by A4, GLIB_000:16;
      hence contradiction by A1, A3, A4, GLIB_009:46, GLIB_000:def 14;
    end;
    then consider e2 being object such that
      A5: e2 DJoins v,w,G2 by A2, Def6;
    e2 Joins v,w,G2 by A5, GLIB_000:16;
    hence v,w are_adjacent by CHORD:def 3;
  end;
  hence thesis by CHORD:def 6;
end;

registration
  let G be edgeless _Graph;
  cluster -> complete for DLGraphComplement of G;
  coherence
  proof
    let G2 be DLGraphComplement of G;
    the_Edges_of G = {} & G.loops() = {};
    hence thesis by Th57;
  end;
end;

registration
  let G be non connected _Graph;
  cluster -> connected for DLGraphComplement of G;
  coherence
  proof
    let G2 be DLGraphComplement of G;
    consider w1, w2 being Vertex of G such that
      A1: for W being Walk of G holds not W is_Walk_from w1,w2
      by GLIB_002:def 1;
    not ex e being object st e DJoins w1,w2,G
    proof
      given e being object such that
        A2: e DJoins w1,w2,G;
      e Joins w1,w2,G by A2, GLIB_000:16;
      then G.walkOf(w1,e,w2) is_Walk_from w1,w2 by GLIB_001:15;
      hence contradiction by A1;
    end;
    then consider e being object such that
      A3: e DJoins w1,w2,G2 by Def6;
    now
      let v1,v2 be Vertex of G2;
      reconsider u1=v1, u2=v2 as Vertex of G by Def6;
      per cases;
      suppose A4: (ex e1 being object st e1 DJoins v1,w1,G) &
          (ex e2 being object st e2 DJoins v2,w2,G);
        then consider e1 being object such that
          A5: e1 DJoins v1,w1,G;
        consider e2 being object such that
          A6: e2 DJoins v2,w2,G by A4;
        A7: e1 Joins w1,v1,G by A5, GLIB_000:16;
        A8: e2 Joins v2,w2,G by A6, GLIB_000:16;
        not ex e3 being object st e3 DJoins u1,w2,G
        proof
          given e3 being object such that
            A9: e3 DJoins u1,w2,G;
          set W2 = G.walkOf(v1,e3,w2);
          e3 Joins v1,w2,G by A9, GLIB_000:16;
          then A10: W2 is_Walk_from v1,w2 by GLIB_001:15;
          set W1 = G.walkOf(w1,e1,v1);
          W1 is_Walk_from w1,v1 by A7, GLIB_001:15;
          then W1.append(W2) is_Walk_from w1,w2 by A10, GLIB_001:31;
          hence contradiction by A1;
        end;
        then consider e3 being object such that
          A11: e3 DJoins u1,w2,G2 by Def6;
        A12: e3 Joins v1,w2,G2 by A11, GLIB_000:16;
        not ex e4 being object st e4 DJoins w1,u2,G
        proof
          given e4 being object such that
            A13: e4 DJoins w1,u2,G;
          set W1 = G.walkOf(w1,e4,u2);
          e4 Joins w1,v2,G by A13, GLIB_000:16;
          then A14: W1 is_Walk_from w1,v2 by GLIB_001:15;
          set W2 = G.walkOf(v2,e2,w2);
          W2 is_Walk_from v2,w2 by A8, GLIB_001:15;
          then W1.append(W2) is_Walk_from w1,w2 by A14, GLIB_001:31;
          hence contradiction by A1;
        end;
        then consider e4 being object such that
          A15: e4 DJoins w1,u2,G2 by Def6;
        A16: e4 Joins w1,v2,G2 by A15, GLIB_000:16;
        set W1 = G2.walkOf(v1,e3,w2), W2 = G2.walkOf(w2,e,w1),
          W3 = G2.walkOf(w1,e4,v2);
        reconsider W = W1.append(W2).append(W3) as Walk of G2;
        take W;
        A17: W1 is_Walk_from v1,w2 by A12, GLIB_001:15;
        e Joins w2,w1,G2 by A3, GLIB_000:16;
        then W2 is_Walk_from w2,w1 by GLIB_001:15;
        then A18: W1.append(W2) is_Walk_from v1,w1 by A17, GLIB_001:31;
        W3 is_Walk_from w1,v2 by A16, GLIB_001:15;
        hence W is_Walk_from v1,v2 by A18, GLIB_001:31;
      end;
      suppose A19: (not ex e1 being object st e1 DJoins v1,w1,G) &
          (ex e2 being object st e2 DJoins v2,w2,G);
        then consider e2 being object such that
          A20: e2 DJoins v2,w2,G;
        A21: e2 Joins v2,w2,G by A20, GLIB_000:16;
        consider e3 being object such that
          A22: e3 DJoins u1,w1,G2 by A19, Def6;
        A23: e3 Joins v1,w1,G2 by A22, GLIB_000:16;
        not ex e4 being object st e4 DJoins w1,u2,G
        proof
          given e4 being object such that
            A24: e4 DJoins w1,u2,G;
          set W1 = G.walkOf(w1,e4,u2);
          e4 Joins w1,v2,G by A24, GLIB_000:16;
          then A25: W1 is_Walk_from w1,v2 by GLIB_001:15;
          set W2 = G.walkOf(v2,e2,w2);
          W2 is_Walk_from v2,w2 by A21, GLIB_001:15;
          then W1.append(W2) is_Walk_from w1,w2 by A25, GLIB_001:31;
          hence contradiction by A1;
        end;
        then consider e4 being object such that
          A26: e4 DJoins w1,u2,G2 by Def6;
        A27: e4 Joins w1,v2,G2 by A26, GLIB_000:16;
        set W1 = G2.walkOf(v1,e3,w1), W2 = G2.walkOf(w1,e4,v2);
        reconsider W = W1.append(W2) as Walk of G2;
        take W;
        A28: W1 is_Walk_from v1,w1 by A23, GLIB_001:15;
        W2 is_Walk_from w1,v2 by A27, GLIB_001:15;
        hence W is_Walk_from v1,v2 by A28, GLIB_001:31;
      end;
      suppose A29: (ex e1 being object st e1 DJoins v1,w1,G) &
          (not ex e2 being object st e2 DJoins v2,w2,G);
        then consider e1 being object such that
          A30: e1 DJoins v1,w1,G;
        A31: e1 Joins w1,v1,G by A30, GLIB_000:16;
        not ex e3 being object st e3 DJoins u1,w2,G
        proof
          given e3 being object such that
            A32: e3 DJoins u1,w2,G;
          set W2 = G.walkOf(v1,e3,w2);
          e3 Joins v1,w2,G by A32, GLIB_000:16;
          then A33: W2 is_Walk_from v1,w2 by GLIB_001:15;
          set W1 = G.walkOf(w1,e1,v1);
          W1 is_Walk_from w1,v1 by A31, GLIB_001:15;
          then W1.append(W2) is_Walk_from w1,w2 by A33, GLIB_001:31;
          hence contradiction by A1;
        end;
        then consider e3 being object such that
          A34: e3 DJoins u1,w2,G2 by Def6;
        A35: e3 Joins v1,w2,G2 by A34, GLIB_000:16;
        consider e4 being object such that
          A36: e4 DJoins u2,w2,G2 by A29, Def6;
        A37: e4 Joins w2,v2,G2 by A36, GLIB_000:16;
        set W1 = G2.walkOf(v1,e3,w2), W2 = G2.walkOf(w2,e4,v2);
        reconsider W = W1.append(W2) as Walk of G2;
        take W;
        A38: W1 is_Walk_from v1,w2 by A35, GLIB_001:15;
        W2 is_Walk_from w2,v2 by A37, GLIB_001:15;
        hence W is_Walk_from v1,v2 by A38, GLIB_001:31;
      end;
      suppose A39: (not ex e1 being object st e1 DJoins v1,w1,G) &
          (not ex e2 being object st e2 DJoins v2,w2,G);
        then consider e3 being object such that
          A40: e3 DJoins u1,w1,G2 by Def6;
        A41: e3 Joins v1,w1,G2 by A40, GLIB_000:16;
        consider e4 being object such that
          A42: e4 DJoins u2,w2,G2 by A39, Def6;
        A43: e4 Joins w2,v2,G2 by A42, GLIB_000:16;
        set W1 = G2.walkOf(v1,e3,w1), W2 = G2.walkOf(w1,e,w2),
          W3 = G2.walkOf(w2,e4,v2);
        reconsider W = W1.append(W2).append(W3) as Walk of G2;
        take W;
        A44: W1 is_Walk_from v1,w1 by A41, GLIB_001:15;
        e Joins w1,w2,G2 by A3, GLIB_000:16;
        then W2 is_Walk_from w1,w2 by GLIB_001:15;
        then A45: W1.append(W2) is_Walk_from v1,w2 by A44, GLIB_001:31;
        W3 is_Walk_from w2,v2 by A43, GLIB_001:15;
        hence W is_Walk_from v1,v2 by A45, GLIB_001:31;
      end;
    end;
    hence thesis by GLIB_002:def 1;
  end;
end;

theorem
  for G1 being _Graph, G2 being DLGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2 st v1 = v2 holds
    (v1 is isolated implies v2 is non isolated) &
    (v1 is endvertex implies v2 is non endvertex)
proof
  let G1 be _Graph, G2 be DLGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2;
  hereby
    assume A2: v1 is isolated;
    not ex e1 being object st e1 DJoins v1,v1,G1
    proof
      given e1 being object such that
        A3: e1 DJoins v1,v1,G1;
      e1 Joins v1,v1,G1 by A3, GLIB_000:16;
      hence contradiction by A2, GLIBPRE0:21;
    end;
    then consider e2 being object such that
      A4: e2 DJoins v1,v1,G2 by Def6;
    e2 Joins v2,v2,G2 by A1, A4, GLIB_000:16;
    hence v2 is non isolated by GLIBPRE0:21;
  end;
  hereby
    assume A5: v1 is endvertex;
    not ex e1 being object st e1 DJoins v1,v1,G1
    proof
      given e1 being object such that
        A6: e1 DJoins v1,v1,G1;
      e1 Joins v1,v1,G1 by A6, GLIB_000:16;
      hence contradiction by A5, GLIBPRE0:24;
    end;
    then consider e2 being object such that
      A7: e2 DJoins v1,v1,G2 by Def6;
    e2 Joins v2,v2,G2 by A1, A7, GLIB_000:16;
    hence v2 is non endvertex by GLIBPRE0:24;
  end;
end;

theorem
  for G1 being _Graph, G2 being DLGraphComplement of G1
  for v,w being Vertex of G1 holds
    (not ex e being object st e Joins v,w,G1) implies
    (ex e being object st e Joins v,w,G2)
proof
  let G1 be _Graph, G2 be DLGraphComplement of G1;
  let v,w be Vertex of G1;
  assume A1: not ex e being object st e Joins v,w,G1;
  not ex e being object st e DJoins v,w,G1
  proof
    given e being object such that
      A2: e DJoins v,w,G1;
    e Joins v,w,G1 by A2, GLIB_000:16;
    hence contradiction by A1;
  end;
  then consider e being object such that
    A3: e DJoins v,w,G2 by Def6;
  take e;
  thus e Joins v,w,G2 by A3, GLIB_000:16;
end;

theorem Th60:
  for G1 being _Graph, G2 being DLGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2 st v1 = v2
  holds
    v2.inNeighbors() = the_Vertices_of G2 \ v1.inNeighbors() &
    v2.outNeighbors() = the_Vertices_of G2 \ v1.outNeighbors()
proof
  let G1 be _Graph, G2 be DLGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2;
  now
    let x be object;
    hereby
      assume x in v2.inNeighbors();
      then consider e being object such that
        A2: e DJoins x,v2,G2 by GLIB_000:69;
      e Joins x,v2,G2 by A2, GLIB_000:16;
      then A3: x in the_Vertices_of G2 by GLIB_000:13;
      then reconsider w = x as Vertex of G1 by Def6;
      not ex e0 being object st e0 DJoins w,v1,G1 by A1, A2, Def6;
      then not x in v1.inNeighbors() by GLIB_000:69;
      hence x in the_Vertices_of G2 \ v1.inNeighbors() by A3, XBOOLE_0:def 5;
    end;
    assume x in the_Vertices_of G2 \ v1.inNeighbors();
    then A4: x in the_Vertices_of G2 & not x in v1.inNeighbors()
      by XBOOLE_0:def 5;
    then reconsider w = x as Vertex of G1 by Def6;
    not ex e0 being object st e0 DJoins w,v1,G1 by A4, GLIB_000:69;
    then consider e being object such that
      A5: e DJoins w,v1,G2 by Def6;
    thus x in v2.inNeighbors() by A1, A5, GLIB_000:69;
  end;
  hence v2.inNeighbors() = the_Vertices_of G2 \ v1.inNeighbors() by TARSKI:2;
  now
    let x be object;
    hereby
      assume x in v2.outNeighbors();
      then consider e being object such that
        A6: e DJoins v2,x,G2 by GLIB_000:70;
      e Joins v2,x,G2 by A6, GLIB_000:16;
      then A7: x in the_Vertices_of G2 by GLIB_000:13;
      then reconsider w = x as Vertex of G1 by Def6;
      not ex e0 being object st e0 DJoins v1,w,G1 by A1, A6, Def6;
      then not x in v1.outNeighbors() by GLIB_000:70;
      hence x in the_Vertices_of G2 \ v1.outNeighbors() by A7, XBOOLE_0:def 5;
    end;
    assume x in the_Vertices_of G2 \ v1.outNeighbors();
    then A8: x in the_Vertices_of G2 & not x in v1.outNeighbors()
      by XBOOLE_0:def 5;
    then reconsider w = x as Vertex of G1 by Def6;
    not ex e0 being object st e0 DJoins v1,w,G1 by A8, GLIB_000:70;
    then consider e being object such that
      A9: e DJoins v1,w,G2 by Def6;
    thus x in v2.outNeighbors() by A1, A9, GLIB_000:70;
  end;
  hence v2.outNeighbors() = the_Vertices_of G2 \ v1.outNeighbors() by TARSKI:2;
end;

theorem
  for G1 being _Graph, G2 being DLGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & v1 is isolated holds
    v2.inNeighbors() = the_Vertices_of G2 &
    v2.outNeighbors() = the_Vertices_of G2 &
    v2.allNeighbors() = the_Vertices_of G2
proof
  let G1 be _Graph, G2 be DLGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & v1 is isolated;
  then v1.allNeighbors() = {} by GLIB_008:7;
  then A2: v1.inNeighbors() = {} & v1.outNeighbors() = {};
  hence A3: v2.inNeighbors() = the_Vertices_of G2 \ {} by A1, Th60
    .= the_Vertices_of G2;
  thus v2.outNeighbors() = the_Vertices_of G2 \ {} by A1, A2, Th60
    .= the_Vertices_of G2;
  hence v2.allNeighbors() = the_Vertices_of G2 by A3;
end;

begin :: Undirected Graph Complement with Loops

definition
  let G be _Graph;
  mode LGraphComplement of G -> non-multi _Graph means
  :Def7:
  the_Vertices_of it = the_Vertices_of G &
  the_Edges_of it misses the_Edges_of G &
  for v,w being Vertex of G holds
    (ex e1 being object st e1 Joins v,w,G) iff
    (not ex e2 being object st e2 Joins v,w,it);
  existence
  proof
    set E = {[the_Edges_of G,{v,w}] where v is Vertex of G, w is Vertex of G
      : not ex e being object st e Joins v,w,G};
    deffunc S(object) = the Element of Segm($1`2);
    consider s being Function such that
      A1: dom s = E & for x being object st x in E holds s.x = S(x)
      from FUNCT_1:sch 3;
    now
      let y be object;
      assume y in rng s;
      then consider x being object such that
        A2: x in dom s & s.x = y by FUNCT_1:def 3;
      consider v, w being Vertex of G such that
        A3: x = [the_Edges_of G,{v,w}] and
        not ex e being object st e Joins v,w,G by A1, A2;
      y = S(x) by A1, A2
        .= the Element of {v,w} by A3;
      hence y in the_Vertices_of G;
    end;
    then reconsider s as Function of E, the_Vertices_of G
      by A1, TARSKI:def 3, FUNCT_2:2;
    deffunc T(object) = IFEQ(Segm($1`2)\{S($1)},{},
      S($1),the Element of (Segm($1`2)\{S($1)}));
    A4: for x,y being object st x <> y holds T([the_Edges_of G,{x,y}])
      = the Element of ({x,y}\{the Element of {x,y}})
      by FUNCOP_1:def 8, GLIBPRE0:3;
    A5: for x being object holds T([the_Edges_of G,{x,x}])
      = the Element of {x,x}
    proof
      let x be object;
      A6: {x,x}\{the Element of {x,x}} = {} by GLIBPRE0:3;
      thus T([the_Edges_of G,{x,x}])
        = the Element of {x,x} by A6, FUNCOP_1:def 8;
    end;
    consider t being Function such that
      A7: dom t = E & for x being object st x in E holds t.x = T(x)
      from FUNCT_1:sch 3;
    now
      let y be object;
      assume y in rng t;
      then consider x being object such that
        A8: x in dom t & t.x = y by FUNCT_1:def 3;
      consider v, w being Vertex of G such that
        A9: x = [the_Edges_of G,{v,w}] and
        not ex e being object st e Joins v,w,G by A7, A8;
      per cases;
      suppose A10: v <> w;
        y = T([the_Edges_of G,{v,w}]) by A7, A8, A9
          .= the Element of ({v,w}\{the Element of {v,w}}) by A4, A10;
        then y = v or y = w by A10, GLIBPRE0:4;
        hence y in the_Vertices_of G;
      end;
      suppose A11: v = w;
        y = T([the_Edges_of G,{v,w}]) by A7, A8, A9
          .= the Element of {v,v} by A5, A11;
        hence y in the_Vertices_of G;
      end;
    end;
    then reconsider t as Function of E, the_Vertices_of G
      by A7, TARSKI:def 3, FUNCT_2:2;
    set H = createGraph(the_Vertices_of G,E,s,t);
    now
      let e1,e2,v1,v2 be object;
      assume A12: e1 Joins v1,v2,H & e2 Joins v1,v2,H;
      then e1 in the_Edges_of H by GLIB_000:def 13;
      then A13: e1 in E;
      then consider a,b being Vertex of G such that
        A14: e1 = [the_Edges_of G,{a,b}] and
        not ex e being object st e Joins a,b,G;
      e2 in the_Edges_of H by A12, GLIB_000:def 13;
      then A15: e2 in E;
      then consider c,d being Vertex of G such that
        A16: e2 = [the_Edges_of G,{c,d}] and
        not ex e being object st e Joins c,d,G;
      per cases;
      suppose A17: a <> b & c <> d;
        per cases by A12, GLIB_000:16;
        suppose A18: e1 DJoins v1,v2,H & e2 DJoins v1,v2,H;
          A19: v1 = (the_Source_of H).e1 by A18, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A20: v2 = (the_Target_of H).e1 by A18, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A17, A14;
          A21: v1 = (the_Source_of H).e2 by A18, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          v2 = (the_Target_of H).e2 by A18, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of ({c,d}\{the Element of {c,d}}) by A4, A17, A16;
          then A22: v1 = c & v2 = d or v1 = d & v2 = c by A17, A21, GLIBPRE0:4;
          v1 = a & v2 = b or v1 = b & v2 = a by A17, A19, A20, GLIBPRE0:4;
          hence e1 = e2 by A14, A16, A22;
        end;
        suppose A23: e1 DJoins v1,v2,H & e2 DJoins v2,v1,H;
          A24: v1 = (the_Source_of H).e1 by A23, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A25: v2 = (the_Target_of H).e1 by A23, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A17, A14;
          A26: v1 = (the_Target_of H).e2 by A23, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of ({c,d}\{the Element of {c,d}}) by A4, A17, A16;
          v2 = (the_Source_of H).e2 by A23, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          then A27: v1 = c & v2 = d or v1 = d & v2 = c by A17, A26, GLIBPRE0:4;
          v1 = a & v2 = b or v1 = b & v2 = a by A17, A24, A25, GLIBPRE0:4;
          hence e1 = e2 by A14, A16, A27;
        end;
        suppose A28: e1 DJoins v2,v1,H & e2 DJoins v2,v1,H;
          A29: v1 = (the_Target_of H).e1 by A28, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A17, A14;
          A30: v2 = (the_Source_of H).e1 by A28, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A31: v1 = (the_Target_of H).e2 by A28, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of ({c,d}\{the Element of {c,d}}) by A4, A17, A16;
          v2 = (the_Source_of H).e2 by A28, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          then A32: v1 = c & v2 = d or v1 = d & v2 = c by A17, A31, GLIBPRE0:4;
          v1 = a & v2 = b or v1 = b & v2 = a by A17, A29, A30, GLIBPRE0:4;
          hence e1 = e2 by A14, A16, A32;
        end;
        suppose A33: e1 DJoins v2,v1,H & e2 DJoins v1,v2,H;
          A34: v1 = (the_Target_of H).e1 by A33, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A17, A14;
          A35: v2 = (the_Source_of H).e1 by A33, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A36: v1 = (the_Source_of H).e2 by A33, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          v2 = (the_Target_of H).e2 by A33, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of ({c,d}\{the Element of {c,d}}) by A4, A17, A16;
          then A37: v1 = c & v2 = d or v1 = d & v2 = c by A17, A36, GLIBPRE0:4;
          v1 = a & v2 = b or v1 = b & v2 = a by A17, A34, A35, GLIBPRE0:4;
          hence e1 = e2 by A14, A16, A37;
        end;
      end;
      suppose A38: a <> b & c = d;
        per cases by A12, GLIB_000:16;
        suppose A39: e1 DJoins v1,v2,H & e2 DJoins v1,v2,H;
          A40: v1 = (the_Source_of H).e1 by A39, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A41: v2 = (the_Target_of H).e1 by A39, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A38, A14;
          A42: v1 = (the_Source_of H).e2 by A39, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          A43: v2 = (the_Target_of H).e2 by A39, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of {c,d} by A5, A38, A16;
          v1 = a & v2 = b or v1 = b & v2 = a by A38, A40, A41, GLIBPRE0:4;
          hence e1 = e2 by A38, A42, A43; :: by contradiction
        end;
        suppose A44: e1 DJoins v1,v2,H & e2 DJoins v2,v1,H;
          A45: v1 = (the_Source_of H).e1 by A44, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A46: v2 = (the_Target_of H).e1 by A44, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A38, A14;
          A47: v1 = (the_Target_of H).e2 by A44, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of {c,d} by A5, A38, A16;
          A48: v2 = (the_Source_of H).e2 by A44, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          v1 = a & v2 = b or v1 = b & v2 = a by A38, A45, A46, GLIBPRE0:4;
          hence e1 = e2 by A38, A47, A48; :: by contradiction
        end;
        suppose A49: e1 DJoins v2,v1,H & e2 DJoins v2,v1,H;
          A50: v1 = (the_Target_of H).e1 by A49, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A38, A14;
          A51: v2 = (the_Source_of H).e1 by A49, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A52: v1 = (the_Target_of H).e2 by A49, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of {c,d} by A5, A38, A16;
          A53: v2 = (the_Source_of H).e2 by A49, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          v1 = a & v2 = b or v1 = b & v2 = a by A38, A50, A51, GLIBPRE0:4;
          hence e1 = e2 by A38, A52, A53; :: by contradiction
        end;
        suppose A54: e1 DJoins v2,v1,H & e2 DJoins v1,v2,H;
          A55: v1 = (the_Target_of H).e1 by A54, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A38, A14;
          A56: v2 = (the_Source_of H).e1 by A54, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A57: v1 = (the_Source_of H).e2 by A54, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          A58: v2 = (the_Target_of H).e2 by A54, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of {c,d} by A5, A38, A16;
          v1 = a & v2 = b or v1 = b & v2 = a by A38, A55, A56, GLIBPRE0:4;
          hence e1 = e2 by A38, A57, A58; :: by contradiction
        end;
      end;
      suppose A59: a = b & c <> d;
        per cases by A12, GLIB_000:16;
        suppose A60: e1 DJoins v1,v2,H & e2 DJoins v1,v2,H;
          A61: v1 = (the_Source_of H).e1 by A60, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A62: v2 = (the_Target_of H).e1 by A60, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of {a,b} by A5, A59, A14;
          A63: v1 = (the_Source_of H).e2 by A60, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          v2 = (the_Target_of H).e2 by A60, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of ({c,d}\{the Element of {c,d}}) by A4, A59, A16;
          then v1 = c & v2 = d or v1 = d & v2 = c by A59, A63, GLIBPRE0:4;
          hence e1 = e2 by A59, A61, A62; :: by contradiction
        end;
        suppose A64: e1 DJoins v1,v2,H & e2 DJoins v2,v1,H;
          A65: v1 = (the_Source_of H).e1 by A64, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A66: v2 = (the_Target_of H).e1 by A64, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of {a,b} by A5, A59, A14;
          A67: v1 = (the_Target_of H).e2 by A64, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of ({c,d}\{the Element of {c,d}}) by A4, A59, A16;
          v2 = (the_Source_of H).e2 by A64, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          then v1 = c & v2 = d or v1 = d & v2 = c by A59, A67, GLIBPRE0:4;
          hence e1 = e2 by A59, A65, A66; :: by contradiction
        end;
        suppose A68: e1 DJoins v2,v1,H & e2 DJoins v2,v1,H;
          A69: v1 = (the_Target_of H).e1 by A68, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of {a,b} by A5, A59, A14;
          A70: v2 = (the_Source_of H).e1 by A68, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A71: v1 = (the_Target_of H).e2 by A68, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of ({c,d}\{the Element of {c,d}}) by A4, A59, A16;
          v2 = (the_Source_of H).e2 by A68, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          then v1 = c & v2 = d or v1 = d & v2 = c by A59, A71, GLIBPRE0:4;
          hence e1 = e2 by A59, A69, A70; :: by contradiction
        end;
        suppose A72: e1 DJoins v2,v1,H & e2 DJoins v1,v2,H;
          A73: v1 = (the_Target_of H).e1 by A72, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of {a,b} by A5, A59, A14;
          A74: v2 = (the_Source_of H).e1 by A72, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= the Element of {a,b};
          A75: v1 = (the_Source_of H).e2 by A72, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= the Element of {c,d};
          v2 = (the_Target_of H).e2 by A72, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of ({c,d}\{the Element of {c,d}}) by A4, A59, A16;
          then v1 = c & v2 = d or v1 = d & v2 = c by A59, A75, GLIBPRE0:4;
          hence e1 = e2 by A59, A73, A74; :: by contradiction
        end;
      end;
      suppose A76: a = b & c = d;
        A77: {a,a} = {a} & {c,c} = {c} by ENUMSET1:29;
        per cases by A12, GLIB_000:16;
        suppose A78: e1 DJoins v1,v2,H & e2 DJoins v1,v2,H;
          A79: v1 = (the_Source_of H).e1 by A78, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= a by A76, A77, TARSKI:def 1;
          v1 = (the_Source_of H).e2 by A78, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= c by A76, A77, TARSKI:def 1;
          hence e1 = e2 by A14, A16, A76, A79;
        end;
        suppose A80: e1 DJoins v1,v2,H & e2 DJoins v2,v1,H;
          A81: v1 = (the_Source_of H).e1 by A80, GLIB_000:def 14
            .= s.e1
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A13, A14
            .= a by A76, A77, TARSKI:def 1;
          v1 = (the_Target_of H).e2 by A80, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of {c,d} by A5, A76, A16
            .= c by A76, A77, TARSKI:def 1;
          hence e1 = e2 by A14, A16, A76, A81;
        end;
        suppose A82: e1 DJoins v2,v1,H & e2 DJoins v2,v1,H;
          A83: v1 = (the_Target_of H).e1 by A82, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of {a,b} by A5, A76, A14
            .= a by A76, A77, TARSKI:def 1;
          v1 = (the_Target_of H).e2 by A82, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A15
            .= the Element of {c,d} by A5, A76, A16
            .= c by A76, A77, TARSKI:def 1;
          hence e1 = e2 by A14, A16, A76, A83;
        end;
        suppose A84: e1 DJoins v2,v1,H & e2 DJoins v1,v2,H;
          A85: v1 = (the_Target_of H).e1 by A84, GLIB_000:def 14
            .= t.e1
            .= T(e1) by A7, A13
            .= the Element of {a,b} by A5, A76, A14
            .= a by A76, A77, TARSKI:def 1;
          v1 = (the_Source_of H).e2 by A84, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{c,d}]`2) by A1, A15, A16
            .= c by A76, A77, TARSKI:def 1;
          hence e1 = e2 by A14, A16, A76, A85;
        end;
      end;
    end;
    then reconsider H as non-multi _Graph by GLIB_000:def 20;
    take H;
    thus the_Vertices_of H = the_Vertices_of G;
    E /\ the_Edges_of G = {}
    proof
      assume E /\ the_Edges_of G <> {};
      then consider x being object such that
        A86: x in E /\ the_Edges_of G by XBOOLE_0:def 1;
      reconsider x as set by TARSKI:1;
      x in E by A86, XBOOLE_0:def 4;
      then consider v,w being Vertex of G such that
        A87: x = [the_Edges_of G,{v,w}] and
        not ex e being object st e Joins v,w,G;
      A88: x in the_Edges_of G by A86, XBOOLE_0:def 4;
      A89: the_Edges_of G in {the_Edges_of G} by TARSKI:def 1;
      x = {{the_Edges_of G,{v,w}},{the_Edges_of G}} by A87, TARSKI:def 5;
      then {the_Edges_of G} in x by TARSKI:def 2;
      hence contradiction by A88, A89, XREGULAR:7;
    end;
    then the_Edges_of H /\ the_Edges_of G = {};
    hence the_Edges_of H misses the_Edges_of G by XBOOLE_0:def 7;
    let v,w be Vertex of G;
    hereby
      given e1 being object such that
        A90: e1 Joins v,w,G;
      given e2 being object such that
        A91: e2 Joins v,w,H;
      e2 in the_Edges_of H by A91, GLIB_000:def 13;
      then A92: e2 in E;
      then consider a,b being Vertex of G such that
        A93: e2 = [the_Edges_of G,{a,b}] and
        A94: not ex e being object st e Joins a,b,G;
      per cases;
      suppose A95: a <> b;
        per cases by A91, GLIB_000:16;
        suppose A96: e2 DJoins v,w,H;
          A97: v = (the_Source_of H).e2 by A96, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A92, A93
            .= the Element of {a,b};
          w = (the_Target_of H).e2 by A96, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A92
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A93, A95;
          then v = a & w = b or v = b & w = a by A95, A97, GLIBPRE0:4;
          hence contradiction by A90, A94, GLIB_000:14;
        end;
        suppose A98: e2 DJoins w,v,H;
          A99: v = (the_Target_of H).e2 by A98, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A92
            .= the Element of ({a,b}\{the Element of {a,b}}) by A4, A93, A95;
          w = (the_Source_of H).e2 by A98, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A92, A93
            .= the Element of {a,b};
          then v = a & w = b or v = b & w = a by A95, A99, GLIBPRE0:4;
          hence contradiction by A90, A94, GLIB_000:14;
        end;
      end;
      suppose A100: a = b;
        A101: {a,a} = {a} by ENUMSET1:29;
        per cases by A91, GLIB_000:16;
        suppose A102: e2 DJoins v,w,H;
          A103: v = (the_Source_of H).e2 by A102, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A92, A93
            .= a by A100, A101, TARSKI:def 1;
          w = (the_Target_of H).e2 by A102, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A92
            .= the Element of {a,b} by A5, A93, A100
            .= b by A100, A101, TARSKI:def 1;
          hence contradiction by A90, A94, A103;
        end;
        suppose A104: e2 DJoins w,v,H;
          A105: v = (the_Target_of H).e2 by A104, GLIB_000:def 14
            .= t.e2
            .= T(e2) by A7, A92
            .= the Element of {a,b} by A5, A93, A100
            .= a by A100, A101, TARSKI:def 1;
          w = (the_Source_of H).e2 by A104, GLIB_000:def 14
            .= s.e2
            .= the Element of Segm([the_Edges_of G,{a,b}]`2) by A1, A92, A93
            .= b by A100, A101, TARSKI:def 1;
          hence contradiction by A90, A94, A105;
        end;
      end;
    end;
    set e2 = [the_Edges_of G,{v,w}];
    now
      assume not ex e1 being object st e1 Joins v,w,G;
      then A106: e2 in E;
      then A107: e2 in the_Edges_of H;
      per cases;
      suppose A108: v <> w;
        the Element of {v,w} = the Element of {v,w} &
          the Element of ({v,w}\{the Element of {v,w}}) =
          the Element of ({v,w}\{the Element of {v,w}});
        then per cases by A108, GLIBPRE0:4;
        suppose A109: v = the Element of {v,w} &
            w = the Element of ({v,w}\{the Element of {v,w}});
          A110: v = the Element of Segm([the_Edges_of G,{v,w}]`2) by A109
            .= s.e2 by A1, A106
            .= (the_Source_of H).e2;
          w = T(e2) by A4, A108, A109
            .= t.e2 by A7, A106
            .= (the_Target_of H).e2;
          hence e2 Joins v,w,H by A107, A110, GLIB_000:def 13;
        end;
        suppose A111: w = the Element of {v,w} &
            v = the Element of ({v,w}\{the Element of {v,w}});
          A112: w = the Element of Segm([the_Edges_of G,{v,w}]`2) by A111
            .= s.e2 by A1, A106
            .= (the_Source_of H).e2;
          v = T(e2) by A4, A108, A111
            .= t.e2 by A7, A106
            .= (the_Target_of H).e2;
          hence e2 Joins v,w,H by A107, A112, GLIB_000:def 13;
        end;
      end;
      suppose A113: v = w;
        A114: {v,v} = {v} by ENUMSET1:29;
        A115: v = the Element of Segm([the_Edges_of G,{v,w}]`2)
            by A113, A114, TARSKI:def 1
          .= s.e2 by A1, A106
          .= (the_Source_of H).e2;
        w = the Element of Segm([the_Edges_of G,{v,w}]`2)
            by A113, A114, TARSKI:def 1
          .= T(e2) by A5, A113
          .= t.e2 by A7, A106
          .= (the_Target_of H).e2;
        hence e2 Joins v,w,H by A107, A115, GLIB_000:def 13;
      end;
    end;
    hence thesis;
  end;
end;

theorem Th62:
  for G1, G2, G3 being _Graph, G4 being LGraphComplement of G1
  st G1 == G2 & G3 == G4 holds G3 is LGraphComplement of G2
proof
  let G1, G2, G3 be _Graph, G4 be LGraphComplement of G1;
  assume A1: G1 == G2 & G3 == G4;
  then the_Vertices_of G4 = the_Vertices_of G3 &
    the_Edges_of G4 = the_Edges_of G3 by GLIB_000:def 34;
  then the_Vertices_of G1 = the_Vertices_of G3 &
    the_Edges_of G3 misses the_Edges_of G1 by Def7;
  then A2: the_Vertices_of G3 = the_Vertices_of G2 &
    the_Edges_of G3 misses the_Edges_of G2 by A1, GLIB_000:def 34;
  A3: G3 is non-multi by A1, GLIB_000:89;
  now
    let v,w be Vertex of G2;
    A4: v is Vertex of G1 & w is Vertex of G1 by A1, GLIB_000:def 34;
    hereby
      given e1 being object such that
        A5: e1 Joins v,w,G2;
      e1 Joins v,w,G1 by A1, A5, GLIB_000:88;
      then A6: not ex e2 being object st e2 Joins v,w,G4 by A4, Def7;
      thus not ex e2 being object st e2 Joins v,w,G3
      proof
        given e2 being object such that
          A7: e2 Joins v,w,G3;
        e2 Joins v,w,G4 by A1, A7, GLIB_000:88;
        hence contradiction by A6;
      end;
    end;
    assume A8: not ex e2 being object st e2 Joins v,w,G3;
    not ex e2 being object st e2 Joins v,w,G4
    proof
      given e2 being object such that
        A9: e2 Joins v,w,G4;
      e2 Joins v,w,G3 by A1, A9, GLIB_000:88;
      hence contradiction by A8;
    end;
    then consider e1 being object such that
      A10: e1 Joins v,w,G1 by A4, Def7;
    take e1;
    thus e1 Joins v,w,G2 by A1, A10, GLIB_000:88;
  end;
  hence thesis by A2, A3, Def7;
end;

registration
  let G be _Graph;
  cluster plain for LGraphComplement of G;
  existence
  proof
    set G1 = the LGraphComplement of G;
    set G2 = G1 | _GraphSelectors;
    G1 == G1 & G1 == G2 by GLIB_009:9;
    then reconsider G2 as LGraphComplement of G by Th62;
    take G2;
    thus thesis;
  end;
end;

theorem
  for G1 being _Graph, G2 being non-multi _Graph
  holds G2 is LGraphComplement of G1 iff
    the_Vertices_of G2 = the_Vertices_of G1 &
    the_Edges_of G2 misses the_Edges_of G1 &
    for v1,w1 being Vertex of G1, v2,w2 being Vertex of G2 st v1 = v2 & w1 = w2
    holds v1,w1 are_adjacent iff not v2,w2 are_adjacent
proof
  let G1 be _Graph, G2 be non-multi _Graph;
  hereby
    assume A1: G2 is LGraphComplement of G1;
    hence the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 misses the_Edges_of G1 by Def7;
    let v1,w1 be Vertex of G1, v2,w2 be Vertex of G2;
    assume A2: v1 = v2 & w1 = w2;
    hereby
      assume v1,w1 are_adjacent;
      then ex e1 being object st e1 Joins v1,w1,G1 by CHORD:def 3;
      then not ex e2 being object st e2 Joins v1,w1,G2 by A1, Def7;
      hence not v2,w2 are_adjacent by A2, CHORD:def 3;
    end;
    assume not v2,w2 are_adjacent;
    then not ex e2 being object st e2 Joins v1,w1,G2 by A2, CHORD:def 3;
    then ex e1 being object st e1 Joins v1,w1,G1 by A1, Def7;
    hence v1,w1 are_adjacent by CHORD:def 3;
  end;
  assume that A3: the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 misses the_Edges_of G1 and
    A4: for v1,w1 being Vertex of G1, v2,w2 being Vertex of G2
      st v1 = v2 & w1 = w2 holds v1,w1 are_adjacent iff not v2,w2 are_adjacent;
  now
    let v1,w1 be Vertex of G1;
    reconsider v2=v1, w2=w1 as Vertex of G2 by A3;
    hereby
      assume ex e1 being object st e1 Joins v1,w1,G1;
      then v1,w1 are_adjacent by CHORD:def 3;
      then not v2,w2 are_adjacent by A4;
      hence not ex e2 being object st e2 Joins v1,w1,G2 by CHORD:def 3;
    end;
    assume not ex e2 being object st e2 Joins v1,w1,G2;
    then not v2,w2 are_adjacent by CHORD:def 3;
    then v1,w1 are_adjacent by A4;
    hence ex e1 being object st e1 Joins v1,w1,G1 by CHORD:def 3;
  end;
  hence thesis by A3, Def7;
end;

theorem Th64:
  for G1 being _Graph, G2 being LGraphComplement of G1, e1,e2,v,w being object
  holds e1 Joins v,w,G1 implies not e2 Joins v,w,G2
proof
  let G1 be _Graph, G2 be LGraphComplement of G1, e1,e2,v,w be object;
  assume A1: e1 Joins v,w,G1;
  then v in the_Vertices_of G1 & w in the_Vertices_of G1 by GLIB_000:13;
  hence thesis by A1, Def7;
end;

theorem Th65:
  for G1 being _Graph, G2 being removeParallelEdges of G1
  for G3 being LGraphComplement of G1
  holds G3 is LGraphComplement of G2
proof
  let G1 be _Graph, G2 be removeParallelEdges of G1;
  let G3 be LGraphComplement of G1;
  consider E being RepEdgeSelection of G1 such that
    A1: G2 is inducedSubgraph of G1, the_Vertices_of G1, E by GLIB_009:def 7;
  the_Vertices_of G1 c= the_Vertices_of G1 &
    the_Edges_of G1 = G1.edgesBetween(the_Vertices_of G1) by GLIB_000:34;
  then A2: the_Vertices_of G2 = the_Vertices_of G1 & the_Edges_of G2 = E
    by A1, GLIB_000:def 37;
  then A3: the_Vertices_of G3 = the_Vertices_of G2 by Def7;
  the_Edges_of G3 misses the_Edges_of G1 by Def7;
  then A4: the_Edges_of G3 misses the_Edges_of G2 by XBOOLE_1:63;
  now
    let v,w be Vertex of G2;
    A5: v is Vertex of G1 & w is Vertex of G1 by GLIB_000:def 33;
    reconsider v1=v, w1=w as Vertex of G1 by GLIB_000:def 33;
    hereby
      given e2 being object such that
        A6: e2 Joins v,w,G2;
      A7: e2 Joins v,w,G1 by A6, GLIB_000:72;
      given e3 being object such that
        A8: e3 Joins v,w,G3;
      thus contradiction by A7, A8, Th64;
    end;
    assume not ex e3 being object st e3 Joins v,w,G3;
    then consider e1 being object such that
      A9: e1 Joins v,w,G1 by A5, Def7;
    consider e2 being object such that
      A10: e2 Joins v,w,G1 & e2 in E and
      for e9 being object st e9 Joins v,w,G1 & e9 in E holds e9 = e2
      by A9, GLIB_009:def 5;
    take e2;
    thus e2 Joins v,w,G2 by A2, A10, GLIB_000:73;
  end;
  hence thesis by A3, A4, Def7;
end;

theorem Th66:
  for G1, G2 being _Graph
  for G3 being removeParallelEdges of G1, G4 being removeParallelEdges of G2
  for G5 being LGraphComplement of G1, G6 being LGraphComplement of G2
  st G4 is G3-isomorphic holds G6 is G5-isomorphic
proof
  let G1, G2 be _Graph;
  let G3 be removeParallelEdges of G1, G4 be removeParallelEdges of G2;
  let G5 be LGraphComplement of G1, G6 be LGraphComplement of G2;
  A1: G5 is LGraphComplement of G3 & G6 is LGraphComplement of G4 by Th65;
  assume G4 is G3-isomorphic;
  then consider f being PVertexMapping of G3, G4 such that
    A2: f is isomorphism by GLIB_011:49;
  A3: the_Vertices_of G3 = the_Vertices_of G5 &
    the_Vertices_of G4 = the_Vertices_of G6 by A1, Def7;
  then reconsider g = f as PartFunc of the_Vertices_of G5, the_Vertices_of G6;
  now
    let v,w,e be object;
    assume A4: v in dom g & w in dom g & e Joins v,w,G5;
    then A5: not ex e3 being object st e3 Joins v,w,G3 by A1, A3, Def7;
    thus ex e6 being object st e6 Joins g.v,g.w,G6
    proof
      assume A6: not ex e6 being object st e6 Joins g.v,g.w,G6;
      g.v in rng f & g.w in rng f by A4, FUNCT_1:3;
      then consider e4 being object such that
        A7: e4 Joins g.v,g.w,G4 by A1, A6, Def7;
      consider e3 being object such that
        A8: e3 Joins v,w,G3 by A2, A4, A7, GLIB_011:2;
      thus contradiction by A5, A8;
    end;
  end;
  then reconsider g as PVertexMapping of G5, G6 by GLIB_011:1;
  now
    let v,w,e6 be object;
    assume A9: v in dom g & w in dom g & e6 Joins g.v,g.w,G6;
    g.v in rng f & g.w in rng f by A9, FUNCT_1:3;
    then A10: not ex e4 being object st e4 Joins g.v,g.w,G4 by A1, A9, Def7;
    thus ex e5 being object st e5 Joins v,w,G5
    proof
      assume not ex e5 being object st e5 Joins v,w,G5;
      then consider e3 being object such that
        A11: e3 Joins v,w,G3 by A1, A3, A9, Def7;
      consider e4 being object such that
        A12: e4 Joins f.v,f.w,G4 by A9, A11, GLIB_011:1;
      thus contradiction by A10, A12;
    end;
  end;
  then g is continuous by GLIB_011:2;
  hence thesis by A2, A3, GLIB_011:49;
end;

theorem Th67:
  for G1 being _Graph, G2 being G1-isomorphic _Graph
  for G3 being LGraphComplement of G1, G4 being LGraphComplement of G2
  holds G4 is G3-isomorphic
proof
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  let G3 be LGraphComplement of G1, G4 be LGraphComplement of G2;
  set G5 = the removeParallelEdges of G1;
  set G6 = the removeParallelEdges of G2;
  G6 is G5-isomorphic by GLIB_010:168;
  hence thesis by Th66;
end;

theorem Th68:
  for G1 being _Graph, G2, G3 being LGraphComplement of G1
  holds G3 is G2-isomorphic
proof
  let G1 be _Graph, G2, G3 be LGraphComplement of G1;
  G1 is G1-isomorphic by GLIB_010:53;
  hence thesis by Th67;
end;

theorem Th69:
  for G1 being _Graph, V being non empty Subset of the_Vertices_of G1
  for G2 being inducedSubgraph of G1, V
  for G3 being LGraphComplement of G1, G4 being inducedSubgraph of G3, V
  holds G4 is LGraphComplement of G2
proof
  let G1 be _Graph, V be non empty Subset of the_Vertices_of G1;
  let G2 be inducedSubgraph of G1, V;
  let G3 be LGraphComplement of G1, G4 be inducedSubgraph of G3, V;
  A1: V is non empty Subset of the_Vertices_of G3 by Def7;
  then A2: the_Vertices_of G4 = V by GLIB_000:def 37
    .= the_Vertices_of G2 by GLIB_000:def 37;
  A3: the_Edges_of G4 misses the_Edges_of G2
  proof
    assume the_Edges_of G4 meets the_Edges_of G2;
    then consider e being object such that
      A4: e in the_Edges_of G4 & e in the_Edges_of G2 by XBOOLE_0:3;
    A5: e in the_Edges_of G1 \/ the_Edges_of G3 by A4, XBOOLE_0:def 3;
    the_Edges_of G3 misses the_Edges_of G1 by Def7;
    hence contradiction by A4, A5, XBOOLE_0:5;
  end;
  now
    let v,w be Vertex of G2;
    hereby
      given e2 being object such that
        A6: e2 Joins v,w,G2;
      A7: e2 Joins v,w,G1 by A6, GLIB_000:72;
      given e4 being object such that
        A8: e4 Joins v,w,G4;
      e4 Joins v,w,G3 by A8, GLIB_000:72;
      hence contradiction by A7, Th64;
    end;
    assume A9: not ex e4 being object st e4 Joins v,w,G4;
    ex e1 being object st e1 Joins v,w,G1
    proof
      assume A10: not ex e1 being object st e1 Joins v,w,G1;
      the_Vertices_of G2 c= the_Vertices_of G1;
      then v is Vertex of G1 & w is Vertex of G1 by TARSKI:def 3;
      then consider e3 being object such that
        A11: e3 Joins v,w,G3 by A10, Def7;
      the_Vertices_of G2 = V by GLIB_000:def 37;
      then e3 in G3.edgesBetween(V) by A11, GLIB_000:32;
      then e3 in the_Edges_of G4 & e3 is set by A1, GLIB_000:def 37;
      then e3 Joins v,w,G4 by A11, GLIB_000:73;
      hence contradiction by A9;
    end;
    then consider e1 being object such that
      A12: e1 Joins v,w,G1;
    take e1;
    the_Vertices_of G2 = V by GLIB_000:def 37;
    then e1 in G1.edgesBetween(V) by A12, GLIB_000:32;
    then e1 in the_Edges_of G2 & e1 is set by GLIB_000:def 37;
    hence e1 Joins v,w,G2 by A12, GLIB_000:73;
  end;
  hence thesis by A2, A3, Def7;
end;

theorem
  for G1 being _Graph, V being proper Subset of the_Vertices_of G1
  for G2 being removeVertices of G1, V
  for G3 being LGraphComplement of G1, G4 being removeVertices of G3, V
  holds G4 is LGraphComplement of G2
proof
  let G1 be _Graph, V be proper Subset of the_Vertices_of G1;
  let G2 be removeVertices of G1, V;
  let G3 be LGraphComplement of G1, G4 be removeVertices of G3, V;
  the_Vertices_of G1 \ V is non empty Subset of the_Vertices_of G1 &
    the_Vertices_of G1 \ V = the_Vertices_of G3 \ V
    by Def7, XBOOLE_1:105, GLIBPRE0:6;
  hence thesis by Th69;
end;

:: involutiveness of graph complement (LC case)
theorem
  for G1 being non-multi _Graph, G2 being LGraphComplement of G1
  holds G1 is LGraphComplement of G2
proof
  let G1 be non-multi _Graph, G2 be LGraphComplement of G1;
  A1: the_Vertices_of G1 = the_Vertices_of G2 &
    the_Edges_of G1 misses the_Edges_of G2 by Def7;
  now
    let v,w be Vertex of G2;
    v is Vertex of G1 & w is Vertex of G1 by Def7;
    hence (ex e2 being object st e2 Joins v,w,G2) iff
      (not ex e1 being object st e1 Joins v,w,G1) by Def7;
  end;
  hence thesis by A1, Def7;
end;

theorem Th72:
  for G1 being _Graph, G2 being LGraphComplement of G1
  holds G1.order() = G2.order() by Def7;

theorem Th73:
  for G1 being _Graph, G2 being LGraphComplement of G1 holds
    (G1 is _trivial iff G2 is _trivial) &
    (G1 is loopfull iff G2 is loopless) &
    (G1 is loopless iff G2 is loopfull)
proof
  let G1 be _Graph, G2 be LGraphComplement of G1;
  hereby
    assume G1 is _trivial;
    then 1 = G1.order() by GLIB_000:26
      .= G2.order() by Th72;
    hence G2 is _trivial by GLIB_000:26;
  end;
  hereby
    assume G2 is _trivial;
    then 1 = G2.order() by GLIB_000:26
      .= G1.order() by Th72;
    hence G1 is _trivial by GLIB_000:26;
  end;
  hereby
    assume A1: G1 is loopfull;
    now
      let v be object;
      given e2 being object such that
        A2: e2 Joins v,v,G2;
      v in the_Vertices_of G2 by A2, GLIB_000:13;
      then v in the_Vertices_of G1 by Def7;
      then consider e1 being object such that
        A3: e1 Joins v,v,G1 by A1;
      thus contradiction by A2, A3, Th64;
    end;
    hence G2 is loopless by GLIB_000:18;
  end;
  hereby
    assume A4: G2 is loopless;
    now
      let v be Vertex of G1;
      assume not ex e1 being object st e1 Joins v,v,G1;
      then ex e2 being object st e2 Joins v,v,G2 by Def7;
      hence contradiction by A4, GLIB_000:18;
    end;
    hence G1 is loopfull;
  end;
  hereby
    assume A5: G1 is loopless;
    now
      let v be Vertex of G2;
      A6: v is Vertex of G1 by Def7;
      assume not ex e2 being object st e2 Joins v,v,G2;
      then ex e1 being object st e1 Joins v,v,G1 by A6, Def7;
      hence contradiction by A5, GLIB_000:18;
    end;
    hence G2 is loopfull;
  end;
  hereby
    assume A7: G2 is loopfull;
    now
      let v be object;
      given e1 being object such that
        A8: e1 Joins v,v,G1;
      v in the_Vertices_of G1 by A8, GLIB_000:13;
      then v in the_Vertices_of G2 by Def7;
      then consider e2 being object such that
        A9: e2 Joins v,v,G2 by A7;
      thus contradiction by A8, A9, Th64;
    end;
    hence G1 is loopless by GLIB_000:18;
  end;
end;

registration
  let G be _trivial _Graph;
  cluster -> _trivial for LGraphComplement of G;
  coherence by Th73;
end;

registration
  let G be non _trivial _Graph;
  cluster -> non _trivial for LGraphComplement of G;
  coherence by Th73;
end;

registration
  let G be loopfull _Graph;
  cluster -> loopless for LGraphComplement of G;
  coherence by Th73;
end;

registration
  let G be non loopfull _Graph;
  cluster -> non loopless for LGraphComplement of G;
  coherence by Th73;
end;

registration
  let G be loopless _Graph;
  cluster -> loopfull for LGraphComplement of G;
  coherence by Th73;
end;

registration
  let G be non loopless _Graph;
  cluster -> non loopfull for LGraphComplement of G;
  coherence by Th73;
end;

theorem Th74:
  for G1 being _Graph, G2 being LGraphComplement of G1
  st the_Edges_of G1 = G1.loops() holds G2 is complete
proof
  let G1 be _Graph, G2 be LGraphComplement of G1;
  assume A1: the_Edges_of G1 = G1.loops();
  now
    let v,w be Vertex of G2;
    A2: v is Vertex of G1 & w is Vertex of G1 by Def7;
    assume A3: v <> w;
    not ex e1 being object st e1 Joins v,w,G1
    proof
      given e1 being object such that
        A4: e1 Joins v,w,G1;
      not e1 in G1.loops() by A3, A4, GLIB_009:46;
      hence contradiction by A1, A4, GLIB_000:def 13;
    end;
    then consider e2 being object such that
      A5: e2 Joins v,w,G2 by A2, Def7;
    thus v,w are_adjacent by A5, CHORD:def 3;
  end;
  hence thesis by CHORD:def 6;
end;

registration
  let G be edgeless _Graph;
  cluster -> complete for LGraphComplement of G;
  coherence
  proof
    let G2 be LGraphComplement of G;
    the_Edges_of G = {} & G.loops() = {};
    hence thesis by Th74;
  end;
end;

theorem Th75:
  for G1 being complete _Graph, G2 being LGraphComplement of G1
  holds the_Edges_of G2 = G2.loops()
proof
  let G1 be complete _Graph, G2 be LGraphComplement of G1;
  now
    let e be object;
    set v = (the_Source_of G2).e, w = (the_Target_of G2).e;
    assume e in the_Edges_of G2;
    then A1: e Joins v,w,G2 by GLIB_000:def 13;
    v = w
    proof
      assume A2: v <> w;
      v is Vertex of G2 & w is Vertex of G2 by A1, GLIB_000:13;
      then reconsider v0=v, w0=w as Vertex of G1 by Def7;
      ex e0 being object st e0 Joins v0,w0,G1 by A2, CHORD:def 3, CHORD:def 6;
      hence contradiction by A1, Th64;
    end;
    hence e in G2.loops() by A1, GLIB_009:def 2;
  end;
  then the_Edges_of G2 c= G2.loops() by TARSKI:def 3;
  hence thesis by XBOOLE_0:def 10;
end;

registration
  let G be complete loopfull _Graph;
  cluster -> edgeless for LGraphComplement of G;
  coherence
  proof
    let G2 be LGraphComplement of G;
    the_Edges_of G2 = G2.loops() by Th75
      .= {};
    hence thesis;
  end;
end;

registration
  let G be non connected _Graph;
  cluster -> connected for LGraphComplement of G;
  coherence
  proof
    let G2 be LGraphComplement of G;
    consider w1, w2 being Vertex of G such that
      A1: for W being Walk of G holds not W is_Walk_from w1,w2
      by GLIB_002:def 1;
    not ex e being object st e Joins w1,w2,G
    proof
      given e being object such that
        A2: e Joins w1,w2,G;
      G.walkOf(w1,e,w2) is_Walk_from w1,w2 by A2, GLIB_001:15;
      hence contradiction by A1;
    end;
    then consider e being object such that
      A3: e Joins w1,w2,G2 by Def7;
    now
      let v1,v2 be Vertex of G2;
      reconsider u1=v1, u2=v2 as Vertex of G by Def7;
      per cases;
      suppose A4: (ex e1 being object st e1 Joins v1,w1,G) &
          (ex e2 being object st e2 Joins v2,w2,G);
        then consider e1 being object such that
          A5: e1 Joins v1,w1,G;
        consider e2 being object such that
          A6: e2 Joins v2,w2,G by A4;
        not ex e3 being object st e3 Joins u1,w2,G
        proof
          given e3 being object such that
            A7: e3 Joins u1,w2,G;
          set W2 = G.walkOf(v1,e3,w2);
          A8: W2 is_Walk_from v1,w2 by A7, GLIB_001:15;
          set W1 = G.walkOf(w1,e1,v1);
          e1 Joins w1,v1,G by A5, GLIB_000:14;
          then W1 is_Walk_from w1,v1 by GLIB_001:15;
          then W1.append(W2) is_Walk_from w1,w2 by A8, GLIB_001:31;
          hence contradiction by A1;
        end;
        then consider e3 being object such that
          A9: e3 Joins u1,w2,G2 by Def7;
        not ex e4 being object st e4 Joins w1,u2,G
        proof
          given e4 being object such that
            A10: e4 Joins w1,u2,G;
          set W1 = G.walkOf(w1,e4,u2);
          A11: W1 is_Walk_from w1,v2 by A10, GLIB_001:15;
          set W2 = G.walkOf(v2,e2,w2);
          W2 is_Walk_from v2,w2 by A6, GLIB_001:15;
          then W1.append(W2) is_Walk_from w1,w2 by A11, GLIB_001:31;
          hence contradiction by A1;
        end;
        then consider e4 being object such that
          A12: e4 Joins w1,u2,G2 by Def7;
        set W1 = G2.walkOf(v1,e3,w2), W2 = G2.walkOf(w2,e,w1),
          W3 = G2.walkOf(w1,e4,v2);
        reconsider W = W1.append(W2).append(W3) as Walk of G2;
        take W;
        A13: W1 is_Walk_from v1,w2 by A9, GLIB_001:15;
        e Joins w2,w1,G2 by A3, GLIB_000:14;
        then W2 is_Walk_from w2,w1 by GLIB_001:15;
        then A14: W1.append(W2) is_Walk_from v1,w1 by A13, GLIB_001:31;
        W3 is_Walk_from w1,v2 by A12, GLIB_001:15;
        hence W is_Walk_from v1,v2 by A14, GLIB_001:31;
      end;
      suppose A15: (not ex e1 being object st e1 Joins v1,w1,G) &
          (ex e2 being object st e2 Joins v2,w2,G);
        then consider e2 being object such that
          A16: e2 Joins v2,w2,G;
        consider e3 being object such that
          A17: e3 Joins u1,w1,G2 by A15, Def7;
        not ex e4 being object st e4 Joins w1,u2,G
        proof
          given e4 being object such that
            A18: e4 Joins w1,u2,G;
          set W1 = G.walkOf(w1,e4,u2);
          A19: W1 is_Walk_from w1,v2 by A18, GLIB_001:15;
          set W2 = G.walkOf(v2,e2,w2);
          W2 is_Walk_from v2,w2 by A16, GLIB_001:15;
          then W1.append(W2) is_Walk_from w1,w2 by A19, GLIB_001:31;
          hence contradiction by A1;
        end;
        then consider e4 being object such that
          A20: e4 Joins w1,u2,G2 by Def7;
        set W1 = G2.walkOf(v1,e3,w1), W2 = G2.walkOf(w1,e4,v2);
        reconsider W = W1.append(W2) as Walk of G2;
        take W;
        A21: W1 is_Walk_from v1,w1 by A17, GLIB_001:15;
        W2 is_Walk_from w1,v2 by A20, GLIB_001:15;
        hence W is_Walk_from v1,v2 by A21, GLIB_001:31;
      end;
      suppose A22: (ex e1 being object st e1 Joins v1,w1,G) &
          (not ex e2 being object st e2 Joins v2,w2,G);
        then consider e1 being object such that
          A23: e1 Joins v1,w1,G;
        not ex e3 being object st e3 Joins u1,w2,G
        proof
          given e3 being object such that
            A24: e3 Joins u1,w2,G;
          set W2 = G.walkOf(v1,e3,w2);
          A25: W2 is_Walk_from v1,w2 by A24, GLIB_001:15;
          set W1 = G.walkOf(w1,e1,v1);
          e1 Joins w1,v1,G by A23, GLIB_000:14;
          then W1 is_Walk_from w1,v1 by GLIB_001:15;
          then W1.append(W2) is_Walk_from w1,w2 by A25, GLIB_001:31;
          hence contradiction by A1;
        end;
        then consider e3 being object such that
          A26: e3 Joins u1,w2,G2 by Def7;
        consider e4 being object such that
          A27: e4 Joins u2,w2,G2 by A22, Def7;
        set W1 = G2.walkOf(v1,e3,w2), W2 = G2.walkOf(w2,e4,v2);
        reconsider W = W1.append(W2) as Walk of G2;
        take W;
        A28: W1 is_Walk_from v1,w2 by A26, GLIB_001:15;
        e4 Joins w2,v2,G2 by A27, GLIB_000:14;
        then W2 is_Walk_from w2,v2 by GLIB_001:15;
        hence W is_Walk_from v1,v2 by A28, GLIB_001:31;
      end;
      suppose A29: (not ex e1 being object st e1 Joins v1,w1,G) &
          (not ex e2 being object st e2 Joins v2,w2,G);
        then consider e3 being object such that
          A30: e3 Joins u1,w1,G2 by Def7;
        consider e4 being object such that
          A31: e4 Joins u2,w2,G2 by A29, Def7;
        set W1 = G2.walkOf(v1,e3,w1), W2 = G2.walkOf(w1,e,w2),
          W3 = G2.walkOf(w2,e4,v2);
        reconsider W = W1.append(W2).append(W3) as Walk of G2;
        take W;
        A32: W1 is_Walk_from v1,w1 by A30, GLIB_001:15;
        W2 is_Walk_from w1,w2 by A3, GLIB_001:15;
        then A33: W1.append(W2) is_Walk_from v1,w2 by A32, GLIB_001:31;
        e4 Joins w2,v2,G2 by A31, GLIB_000:14;
        then W3 is_Walk_from w2,v2 by GLIB_001:15;
        hence W is_Walk_from v1,v2 by A33, GLIB_001:31;
      end;
    end;
    hence thesis by GLIB_002:def 1;
  end;
end;

theorem
  for G1 being _Graph, G2 being LGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2 st v1 = v2 holds
    (v1 is isolated implies v2 is non isolated) &
    (v1 is endvertex implies v2 is non endvertex)
proof
  let G1 be _Graph, G2 be LGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2;
  hereby
    assume v1 is isolated;
    then not ex e1 being object st e1 Joins v1,v1,G1 by GLIBPRE0:21;
    then consider e2 being object such that
      A2: e2 Joins v1,v1,G2 by Def7;
    thus v2 is non isolated by A1, A2, GLIBPRE0:21;
  end;
  hereby
    assume v1 is endvertex;
    then not ex e1 being object st e1 Joins v1,v1,G1 by GLIBPRE0:24;
    then consider e2 being object such that
      A3: e2 Joins v1,v1,G2 by Def7;
    thus v2 is non endvertex by A1, A3, GLIBPRE0:24;
  end;
end;

theorem Th77:
  for G1 being _Graph, G2 being LGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2 st v1 = v2
  holds v2.allNeighbors() = the_Vertices_of G2 \ v1.allNeighbors()
proof
  let G1 be _Graph, G2 be LGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2;
  now
    let x be object;
    hereby
      assume x in v2.allNeighbors();
      then consider e being object such that
        A2: e Joins v2,x,G2 by GLIB_000:71;
      A3: x in the_Vertices_of G2 by A2, GLIB_000:13;
      then reconsider w = x as Vertex of G1 by Def7;
      not ex e0 being object st e0 Joins v1,w,G1 by A1, A2, Def7;
      then not x in v1.allNeighbors() by GLIB_000:71;
      hence x in the_Vertices_of G2 \ v1.allNeighbors() by A3, XBOOLE_0:def 5;
    end;
    assume x in the_Vertices_of G2 \ v1.allNeighbors();
    then A4: x in the_Vertices_of G2 & not x in v1.allNeighbors()
      by XBOOLE_0:def 5;
    then reconsider w = x as Vertex of G1 by Def7;
    not ex e0 being object st e0 Joins v1,w,G1 by A4, GLIB_000:71;
    then consider e being object such that
      A5: e Joins v1,w,G2 by Def7;
    thus x in v2.allNeighbors() by A1, A5, GLIB_000:71;
  end;
  hence v2.allNeighbors() = the_Vertices_of G2 \ v1.allNeighbors() by TARSKI:2;
end;

theorem
  for G1 being _Graph, G2 being LGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & v1 is isolated
  holds v2.allNeighbors() = the_Vertices_of G2
proof
  let G1 be _Graph, G2 be LGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & v1 is isolated;
  then v1.allNeighbors() = {} by GLIB_008:7;
  hence v2.allNeighbors() = the_Vertices_of G2 \ {} by A1, Th77
    .= the_Vertices_of G2;
end;

begin :: Directed Graph Complement without Loops

definition
  let G be _Graph;
  mode DGraphComplement of G -> Dsimple _Graph means
  :Def8:
  ex G9 being DLGraphComplement of G st it is removeLoops of G9;
  existence
  proof
    set G1 = the DLGraphComplement of G;
    take the removeLoops of G1;
    thus thesis;
  end;
end;

theorem Th79:
  for G1, G2, G3 being _Graph, G4 being DGraphComplement of G1
  st G1 == G2 & G3 == G4 holds G3 is DGraphComplement of G2
proof
  let G1, G2, G3 be _Graph, G4 be DGraphComplement of G1;
  assume A1: G1 == G2 & G3 == G4;
  consider G9 being DLGraphComplement of G1 such that
    A2: G4 is removeLoops of G9 by Def8;
  G9 is DLGraphComplement of G2 & G3 is removeLoops of G9
    by A1, A2, Th45, GLIB_009:59;
  hence thesis by Def8;
end;

registration
  let G be _Graph;
  cluster plain for DGraphComplement of G;
  existence
  proof
    set G1 = the DGraphComplement of G;
    set G2 = G1 | _GraphSelectors;
    G1 == G1 & G1 == G2 by GLIB_009:9;
    then reconsider G2 as DGraphComplement of G by Th79;
    take G2;
    thus thesis;
  end;
end;

theorem Th80:
  for G1 being _Graph, G2 being Dsimple _Graph
  holds G2 is DGraphComplement of G1 iff
    the_Vertices_of G2 = the_Vertices_of G1 &
    the_Edges_of G2 misses the_Edges_of G1 &
    for v,w being Vertex of G1 st v <> w holds
      (ex e1 being object st e1 DJoins v,w,G1) iff
      (not ex e2 being object st e2 DJoins v,w,G2)
proof
  let G1 be _Graph, G2 be Dsimple _Graph;
  :: the first direction is straight forward
  hereby
    assume G2 is DGraphComplement of G1;
    then consider G9 being DLGraphComplement of G1 such that
      A1: G2 is removeLoops of G9 by Def8;
    thus the_Vertices_of G2 = the_Vertices_of G9 by A1, GLIB_000:def 33
      .= the_Vertices_of G1 by Def6;
    A2: the_Edges_of G2 c= the_Edges_of G9 by A1, GLIB_000:def 32;
    the_Edges_of G9 misses the_Edges_of G1 by Def6;
    hence the_Edges_of G2 misses the_Edges_of G1 by A2, XBOOLE_1:63;
    let v,w be Vertex of G1;
    assume A3: v <> w;
    hereby
      given e1 being object such that
        A4: e1 DJoins v,w,G1;
      given e2 being object such that
        A5: e2 DJoins v,w,G2;
      e2 DJoins v,w,G9 by A1, A5, GLIB_000:72;
      hence contradiction by A4, Th46;
    end;
    assume A6: not ex e2 being object st e2 DJoins v,w,G2;
    not ex e9 being object st e9 DJoins v,w,G9
    proof
      given e9 being object such that
        A7: e9 DJoins v,w,G9;
      A8: e9 in the_Edges_of G9 by A7, GLIB_000:def 14;
      e9 Joins v,w,G9 by A7, GLIB_000:16;
      then not e9 in G9.loops() by A3, GLIB_009:46;
      then e9 in the_Edges_of G9 \ G9.loops() by A8, XBOOLE_0:def 5;
      then A9: e9 in the_Edges_of G2 by A1, GLIB_000:53;
      e9 DJoins v,w,G2 by A1, A7, A9, GLIB_000:73;
      hence contradiction by A6;
    end;
    hence ex e1 being object st e1 DJoins v,w,G1 by Def6;
  end;
  :: for the second direction we need to add loops to G2 to get a G9
  :: but the loops must be distinct from both the edges of G1 and of G2,
  :: so some construction is needed (except if G1 is already loopfull)
  assume that A10: the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 misses the_Edges_of G1 and
    A11: for v,w being Vertex of G1 st v <> w holds
      (ex e1 being object st e1 DJoins v,w,G1) iff
      (not ex e2 being object st e2 DJoins v,w,G2);
  per cases;
  suppose A12: G1 is non loopfull;
    defpred P[object] means not ex e being object st e Joins $1,$1,G1;
    consider V being Subset of the_Vertices_of G2 such that
      A13: for x being set holds x in V iff x in the_Vertices_of G2 & P[x]
      from SUBSET_1:sch 1;
    A14: V is non empty by A10, A12, A13;
    set E = the set of all [{the_Edges_of G1,the_Edges_of G2},v]
      where v is Element of V;
    deffunc F(object) = $1`2;
    consider f being Function such that
      A15: dom f = E & for x being object st x in E holds f.x = F(x)
      from FUNCT_1:sch 3;
    now
      let x1,x2 be object;
      assume A16: x1 in dom f & x2 in dom f & f.x1 = f.x2;
      then consider v1 being Element of V such that
        A17: x1 = [{the_Edges_of G1,the_Edges_of G2},v1] by A15;
      consider v2 being Element of V such that
        A18: x2 = [{the_Edges_of G1,the_Edges_of G2},v2] by A15, A16;
      v1 = [{the_Edges_of G1,the_Edges_of G2},v1]`2
        .= f.x1 by A15, A16, A17
        .= [{the_Edges_of G1,the_Edges_of G2},v2]`2 by A15, A16, A18
        .= v2;
      hence x1 = x2 by A17, A18;
    end;
    then reconsider f as one-to-one Function by FUNCT_1:def 4;
    now
      let y be object;
      hereby
        assume y in rng f;
        then consider x being object such that
          A19: x in dom f & f.x = y by FUNCT_1:def 3;
        consider v being Element of V such that
          A20: x = [{the_Edges_of G1,the_Edges_of G2},v] by A15, A19;
        y = [{the_Edges_of G1,the_Edges_of G2},v]`2 by A15, A19, A20
          .= v;
        hence y in V by A14;
      end;
      set x = [{the_Edges_of G1,the_Edges_of G2},y];
      assume y in V;
      then A21: x in E;
      then f.x = [{the_Edges_of G1,the_Edges_of G2},y]`2 by A15
        .= y;
      hence y in rng f by A15, A21, FUNCT_1:3;
    end;
    then A22: rng f = V by TARSKI:2;
    A23: E misses the_Edges_of G1
    proof
      assume E meets the_Edges_of G1;
      then consider e being object such that
        A24: e in E & e in the_Edges_of G1 by XBOOLE_0:3;
      reconsider e as set by TARSKI:1;
      consider v being Element of V such that
        A25: e = [{the_Edges_of G1,the_Edges_of G2},v] by A24;
      A26: e = {{{the_Edges_of G1,the_Edges_of G2}, v},
        {{the_Edges_of G1,the_Edges_of G2}}} by A25, TARSKI:def 5;
      A27: the_Edges_of G1 in
        {the_Edges_of G1, the_Edges_of G2} by TARSKI:def 2;
      A28: {the_Edges_of G1, the_Edges_of G2} in
        {{the_Edges_of G1, the_Edges_of G2}} by TARSKI:def 1;
      {{the_Edges_of G1, the_Edges_of G2}} in e by A26, TARSKI:def 2;
      hence contradiction by A24, A27, A28, XREGULAR:8;
    end;
    A29: E misses the_Edges_of G2
    proof
      assume E meets the_Edges_of G2;
      then consider e being object such that
        A30: e in E & e in the_Edges_of G2 by XBOOLE_0:3;
      reconsider e as set by TARSKI:1;
      consider v being Element of V such that
        A31: e = [{the_Edges_of G1,the_Edges_of G2},v] by A30;
      A32: e = {{{the_Edges_of G1,the_Edges_of G2}, v},
        {{the_Edges_of G1,the_Edges_of G2}}} by A31, TARSKI:def 5;
      A33: the_Edges_of G2 in
        {the_Edges_of G1, the_Edges_of G2} by TARSKI:def 2;
      A34: {the_Edges_of G1, the_Edges_of G2} in
        {{the_Edges_of G1, the_Edges_of G2}} by TARSKI:def 1;
      {{the_Edges_of G1, the_Edges_of G2}} in e by A32, TARSKI:def 2;
      hence contradiction by A30, A33, A34,  XREGULAR:8;
    end;
    set s = the_Source_of G2 +* f;
    now
      thus dom s = dom the_Source_of G2 \/ dom f by FUNCT_4:def 1
        .= the_Edges_of G2 \/ E by A15, FUNCT_2:def 1;
      A35: rng s c= rng the_Source_of G2 \/ rng f by FUNCT_4:17;
      rng the_Source_of G2 \/ rng f c= the_Vertices_of G2 by A22, XBOOLE_1:8;
      hence rng s c= the_Vertices_of G2 by A35, XBOOLE_1:1;
    end;
    then reconsider s as Function of the_Edges_of G2 \/ E, the_Vertices_of G2
      by FUNCT_2:2;
    set t = the_Target_of G2 +* f;
    now
      thus dom t = dom the_Target_of G2 \/ dom f by FUNCT_4:def 1
        .= the_Edges_of G2 \/ E by A15, FUNCT_2:def 1;
      A36: rng t c= rng the_Target_of G2 \/ rng f by FUNCT_4:17;
      rng the_Target_of G2 \/ rng f c= the_Vertices_of G2 by A22, XBOOLE_1:8;
      hence rng t c= the_Vertices_of G2 by A36, XBOOLE_1:1;
    end;
    then reconsider t as Function of the_Edges_of G2 \/ E, the_Vertices_of G2
      by FUNCT_2:2;
    set G9 = createGraph(the_Vertices_of G2,the_Edges_of G2 \/ E,s,t);
    :: show that G9 is addLoops
    now
      :: for that first show that G9 is Supergraph
      now
        thus the_Vertices_of G2 c= the_Vertices_of G9;
        thus the_Edges_of G2 c= the_Edges_of G9 by XBOOLE_1:7;
        let e be set;
        assume A37: e in the_Edges_of G2;
        then e in the_Edges_of G2 \/ E by XBOOLE_0:def 3;
        then A38: not e in dom f by A15, A29, A37, XBOOLE_0:5;
        hence (the_Source_of G2).e = (the_Source_of G2 +* f).e by FUNCT_4:11
          .= (the_Source_of G9).e;
        thus (the_Target_of G2).e = (the_Target_of G2 +* f).e
            by A38, FUNCT_4:11
          .= (the_Target_of G9).e;
      end;
      hence G9 is Supergraph of G2 by GLIB_006:def 9;
      thus the_Vertices_of G9 = the_Vertices_of G2;
      reconsider E as set;
      reconsider f as one-to-one Function;
      take E, f;
      thus E misses the_Edges_of G2 by A29;
      thus the_Edges_of G9 = the_Edges_of G2 \/ E;
      thus dom f = E by A15;
      thus rng f = V by A22;
      thus the_Source_of G9 = the_Source_of G2 +* f;
      thus the_Target_of G9 = the_Target_of G2 +* f;
    end;
    then A39: G9 is addLoops of G2, V by Def5;
    then G2 == the removeLoops of G9 by Th26;
    then A40: G2 is removeLoops of G9 by GLIB_009:59;
    A41: G9 is non-Dmulti by A39;
    :: show that G9 is DLGraphComplement
    now
      thus the_Vertices_of G9 = the_Vertices_of G1 by A10;
      thus the_Edges_of G9 misses the_Edges_of G1 by A10, A23, XBOOLE_1:70;
      let v,w be Vertex of G1;
      hereby
        given e1 being object such that
          A43: e1 DJoins v,w,G1;
        given e2 being object such that
          A44: e2 DJoins v,w,G9;
        per cases by A39, A44, GLIB_006:71;
        suppose A45: e2 DJoins v,w,G2;
          then v <> w by GLIB_009:17;
          hence contradiction by A11, A43, A45;
        end;
        suppose A46: not e2 in the_Edges_of G2;
          e2 in the_Edges_of G9 by A44, GLIB_000:def 14;
          then A47: e2 in E by A46, XBOOLE_0:def 3;
          then consider u being Element of V such that
            A48: e2 = [{the_Edges_of G1,the_Edges_of G2},u];
          A49: not ex e being object st e Joins u,u,G1 by A13, A14;
          A50: v = (the_Source_of G9).e2 by A44, GLIB_000:def 14
             .= s.e2
             .= f.e2 by A15, A47, FUNCT_4:13
             .= [{the_Edges_of G1,the_Edges_of G2},u]`2 by A15, A47, A48
             .= u;
          A51: w = (the_Target_of G9).e2 by A44, GLIB_000:def 14
             .= t.e2
             .= f.e2 by A15, A47, FUNCT_4:13
             .= [{the_Edges_of G1,the_Edges_of G2},u]`2 by A15, A47, A48
             .= u;
          e1 Joins v,w,G1 by A43, GLIB_000:16;
          hence contradiction by A49, A50, A51;
        end;
      end;
      assume A52: not ex e2 being object st e2 DJoins v,w,G9;
      assume A53: not ex e1 being object st e1 DJoins v,w,G1;
      per cases;
      suppose A54: v <> w;
        not ex e2 being object st e2 DJoins v,w,G2 by A39, A52, GLIB_006:70;
        hence contradiction by A11, A53, A54;
      end;
      suppose A55: v = w;
        set e = [{the_Edges_of G1,the_Edges_of G2},v];
        A56: not ex e1 being object st e1 Joins v,v,G1
        proof
          given e1 being object such that
            A57: e1 Joins v,v,G1;
          e1 DJoins v,v,G1 by A57, GLIB_000:16;
          hence contradiction by A53, A55;
        end;
        v in V by A10, A13, A56;
        then A58: e in E;
        then A59: e in the_Edges_of G9 by XBOOLE_0:def 3;
        A60: (the_Source_of G9).e = s.e
          .= f.e by A15, A58, FUNCT_4:13
          .= e`2 by A15, A58
          .= v;
        (the_Target_of G9).e = t.e
          .= f.e by A15, A58, FUNCT_4:13
          .= e`2 by A15, A58
          .= v;
        hence contradiction by A52, A55, A59, A60, GLIB_000:def 14;
      end;
    end;
    then G9 is DLGraphComplement of G1 by A41, Def6;
    hence thesis by A40, Def8;
  end;
  suppose A61: G1 is loopfull;
    now
      let v,w be Vertex of G1;
      hereby
        given e1 being object such that
          A62: e1 DJoins v,w,G1;
        per cases;
        suppose v <> w;
          hence not ex e2 being object st e2 DJoins v,w,G2 by A11, A62;
        end;
        suppose v = w;
          hence not ex e2 being object st e2 DJoins v,w,G2 by GLIB_009:17;
        end;
      end;
      assume A63: not ex e2 being object st e2 DJoins v,w,G2;
      per cases;
      suppose v <> w;
        hence ex e1 being object st e1 DJoins v,w,G1 by A11, A63;
      end;
      suppose v = w;
        hence ex e1 being object st e1 DJoins v,w,G1 by A61, Th1;
      end;
    end;
    then A64: G2 is DLGraphComplement of G1 by A10, Def6;
    G2 is removeLoops of G2 by GLIB_009:58;
    hence thesis by A64, Def8;
  end;
end;

theorem Th81:
  for G1 being _Graph, G2 being DGraphComplement of G1, e1,e2,v,w being object
  holds e1 DJoins v,w,G1 implies not e2 DJoins v,w,G2
proof
  let G1 be _Graph, G2 be DGraphComplement of G1;
  let e1,e2,v,w be object;
  assume A1: e1 DJoins v,w,G1;
  per cases;
  suppose A2: v <> w;
    e1 Joins v,w,G1 by A1, GLIB_000:16;
    then v is Vertex of G1 & w is Vertex of G1 by GLIB_000:13;
    hence thesis by A1, A2, Th80;
  end;
  suppose v = w;
    hence thesis by GLIB_009:17;
  end;
end;

theorem Th82:
  for G1 being _Graph, G2 being DSimpleGraph of G1
  for G3 being DGraphComplement of G1
  holds G3 is DGraphComplement of G2
proof
  let G1 be _Graph, G2 be DSimpleGraph of G1;
  let G3 be DGraphComplement of G1;
  consider E being RepDEdgeSelection of G1 such that
    A1: G2 is inducedSubgraph of G1, the_Vertices_of G1, E\G1.loops()
    by GLIB_009:def 10;
  the_Vertices_of G1 c= the_Vertices_of G1 &
    the_Edges_of G1 = G1.edgesBetween(the_Vertices_of G1) by GLIB_000:34;
  then A2: the_Vertices_of G2 = the_Vertices_of G1 &
    the_Edges_of G2 = E \ G1.loops() by A1, GLIB_000:def 37;
  then A3: the_Vertices_of G3 = the_Vertices_of G2 by Th80;
  the_Edges_of G3 misses the_Edges_of G1 by Th80;
  then A4: the_Edges_of G3 misses the_Edges_of G2 by XBOOLE_1:63;
  now
    let v,w be Vertex of G2;
    assume A5: v <> w;
    A6: v is Vertex of G1 & w is Vertex of G1 by GLIB_000:def 33;
    reconsider v1=v, w1=w as Vertex of G1 by GLIB_000:def 33;
    hereby
      given e2 being object such that
        A7: e2 DJoins v,w,G2;
      A8: e2 DJoins v,w,G1 by A7, GLIB_000:72;
      given e3 being object such that
        A9: e3 DJoins v,w,G3;
      thus contradiction by A8, A9, Th81;
    end;
    assume not ex e3 being object st e3 DJoins v,w,G3;
    then consider e1 being object such that
      A10: e1 DJoins v,w,G1 by A6, A5, Th80;
    consider e2 being object such that
      A11: e2 DJoins v,w,G1 & e2 in E and
      for e9 being object st e9 DJoins v,w,G1 & e9 in E holds e9 = e2
      by A10, GLIB_009:def 6;
    take e2;
    e2 Joins v,w,G1 by A11, GLIB_000:16;
    then not e2 in G1.loops() by A5, GLIB_009:46;
    then e2 in the_Edges_of G2 by A2, A11, XBOOLE_0:def 5;
    hence e2 DJoins v,w,G2 by A11, GLIB_000:73;
  end;
  hence thesis by A3, A4, Th80;
end;

theorem Th83:
  for G1, G2 being _Graph
  for G3 being DSimpleGraph of G1, G4 being DSimpleGraph of G2
  for G5 being DGraphComplement of G1, G6 being DGraphComplement of G2
  st G4 is G3-Disomorphic holds G6 is G5-Disomorphic
proof
  let G1, G2 be _Graph;
  let G3 be DSimpleGraph of G1, G4 be DSimpleGraph of G2;
  let G5 be DGraphComplement of G1, G6 be DGraphComplement of G2;
  A1: G5 is DGraphComplement of G3 & G6 is DGraphComplement of G4 by Th82;
  assume G4 is G3-Disomorphic;
  then consider f being directed PVertexMapping of G3, G4 such that
    A2: f is Disomorphism by GLIB_011:50;
  A3: the_Vertices_of G3 = the_Vertices_of G5 &
    the_Vertices_of G4 = the_Vertices_of G6 by A1, Th80;
  then reconsider g = f as PartFunc of the_Vertices_of G5, the_Vertices_of G6;
  now
    let v,w,e be object;
    assume A4: v in dom g & w in dom g & e DJoins v,w,G5;
    then A5: v <> w by GLIB_009:17;
    then A6: g.v <> g.w by A2, A4, FUNCT_1:def 4;
    A7: not ex e3 being object st e3 DJoins v,w,G3 by A1, A3, A4, A5, Th80;
    thus ex e6 being object st e6 DJoins g.v,g.w,G6
    proof
      assume A8: not ex e6 being object st e6 DJoins g.v,g.w,G6;
      g.v in rng f & g.w in rng f by A4, FUNCT_1:3;
      then consider e4 being object such that
        A9: e4 DJoins g.v,g.w,G4 by A1, A6, A8, Th80;
      consider e3 being object such that
        A10: e3 DJoins v,w,G3 by A2, A4, A9, GLIB_011:def 4;
      thus contradiction by A7, A10;
    end;
  end;
  then reconsider g as directed PVertexMapping of G5, G6 by GLIB_011:4;
  now
    let v,w,e6 be object;
    assume A11: v in dom g & w in dom g & e6 DJoins g.v,g.w,G6;
    A12: g.v <> g.w by A11, GLIB_009:17;
    g.v in rng f & g.w in rng f by A11, FUNCT_1:3;
    then A13: not ex e4 being object st e4 DJoins g.v,g.w,G4
      by A1, A11, A12, Th80;
    thus ex e5 being object st e5 DJoins v,w,G5
    proof
      assume not ex e5 being object st e5 DJoins v,w,G5;
      then consider e3 being object such that
        A14: e3 DJoins v,w,G3 by A1, A3, A11, A12, Th80;
      consider e4 being object such that
        A15: e4 DJoins f.v,f.w,G4 by A11, A14, GLIB_011:def 2;
      thus contradiction by A13, A15;
    end;
  end;
  then g is Dcontinuous by GLIB_011:def 4;
  hence thesis by A2, A3, GLIB_011:50;
end;

theorem Th84:
  for G1 being _Graph, G2 being G1-Disomorphic _Graph
  for G3 being DGraphComplement of G1, G4 being DGraphComplement of G2
  holds G4 is G3-Disomorphic
proof
  let G1 be _Graph, G2 be G1-Disomorphic _Graph;
  let G3 be DGraphComplement of G1, G4 be DGraphComplement of G2;
  set G5 = the DSimpleGraph of G1;
  set G6 = the DSimpleGraph of G2;
  G6 is G5-Disomorphic by GLIB_010:174;
  hence thesis by Th83;
end;

theorem Th85:
  for G1 being _Graph, G2, G3 being DGraphComplement of G1
  holds G3 is G2-Disomorphic
proof
  let G1 be _Graph, G2, G3 be DGraphComplement of G1;
  G1 is G1-Disomorphic by GLIB_010:53;
  hence thesis by Th84;
end;

theorem
  for G1 being _Graph, G2 being reverseEdgeDirections of G1
  for G3 being DGraphComplement of G1, G4 being reverseEdgeDirections of G3
  holds G4 is DGraphComplement of G2
proof
  let G1 be _Graph, G2 be reverseEdgeDirections of G1;
  let G3 be DGraphComplement of G1, G4 be reverseEdgeDirections of G3;
  A1: the_Vertices_of G4 = the_Vertices_of G3 by GLIB_007:4
    .= the_Vertices_of G1 by Th80
    .= the_Vertices_of G2 by GLIB_007:4;
  the_Edges_of G3 misses the_Edges_of G1 by Th80;
  then the_Edges_of G4 misses the_Edges_of G1 by GLIB_007:4;
  then A2: the_Edges_of G4 misses the_Edges_of G2 by GLIB_007:4;
  now
    let v,w be Vertex of G2;
    assume A3: v <> w;
    A4: v is Vertex of G1 & w is Vertex of G1 by GLIB_007:4;
    hereby
      given e2 being object such that
        A5: e2 DJoins v,w,G2;
      e2 in the_Edges_of G2 by A5, GLIB_000:def 14;
      then e2 in the_Edges_of G1 by GLIB_007:4;
      then A6: e2 DJoins w,v,G1 by A5, GLIB_007:7;
      given e4 being object such that
        A7: e4 DJoins v,w,G4;
      e4 in the_Edges_of G4 by A7, GLIB_000:def 14;
      then e4 in the_Edges_of G3 by GLIB_007:4;
      then e4 DJoins w,v,G3 by A7, GLIB_007:7;
      hence contradiction by A6, Th81;
    end;
    assume A8: not ex e4 being object st e4 DJoins v,w,G4;
    not ex e3 being object st e3 DJoins w,v,G3
    proof
      given e3 being object such that
        A9: e3 DJoins w,v,G3;
      e3 in the_Edges_of G3 by A9, GLIB_000:def 14;
      then e3 DJoins v,w,G4 by A9, GLIB_007:7;
      hence contradiction by A8;
    end;
    then consider e1 being object such that
      A10: e1 DJoins w,v,G1 by A3, A4, Th80;
    take e1;
    e1 in the_Edges_of G1 by A10, GLIB_000:def 14;
    hence e1 DJoins v,w,G2 by A10, GLIB_007:7;
  end;
  hence thesis by A1, A2, Th80;
end;

theorem Th87:
  for G1 being _Graph, V being non empty Subset of the_Vertices_of G1
  for G2 being inducedSubgraph of G1, V
  for G3 being DGraphComplement of G1, G4 being inducedSubgraph of G3, V
  holds G4 is DGraphComplement of G2
proof
  let G1 be _Graph, V be non empty Subset of the_Vertices_of G1;
  let G2 be inducedSubgraph of G1, V;
  let G3 be DGraphComplement of G1, G4 be inducedSubgraph of G3, V;
  A1: V is non empty Subset of the_Vertices_of G3 by Th80;
  then A2: the_Vertices_of G4 = V by GLIB_000:def 37
    .= the_Vertices_of G2 by GLIB_000:def 37;
  A3: the_Edges_of G4 misses the_Edges_of G2
  proof
    assume the_Edges_of G4 meets the_Edges_of G2;
    then consider e being object such that
      A4: e in the_Edges_of G4 & e in the_Edges_of G2 by XBOOLE_0:3;
    A5: e in the_Edges_of G1 \/ the_Edges_of G3 by A4, XBOOLE_0:def 3;
    the_Edges_of G3 misses the_Edges_of G1 by Th80;
    hence contradiction by A4, A5, XBOOLE_0:5;
  end;
  now
    let v,w be Vertex of G2;
    assume A6: v <> w;
    hereby
      given e2 being object such that
        A7: e2 DJoins v,w,G2;
      A8: e2 DJoins v,w,G1 by A7, GLIB_000:72;
      given e4 being object such that
        A9: e4 DJoins v,w,G4;
      e4 DJoins v,w,G3 by A9, GLIB_000:72;
      hence contradiction by A8, Th81;
    end;
    assume A10: not ex e4 being object st e4 DJoins v,w,G4;
    ex e1 being object st e1 DJoins v,w,G1
    proof
      assume A11: not ex e1 being object st e1 DJoins v,w,G1;
      the_Vertices_of G2 c= the_Vertices_of G1;
      then v is Vertex of G1 & w is Vertex of G1 by TARSKI:def 3;
      then consider e3 being object such that
        A12: e3 DJoins v,w,G3 by A6, A11, Th80;
      A13: e3 Joins v,w,G3 by A12, GLIB_000:16;
      the_Vertices_of G2 = V by GLIB_000:def 37;
      then e3 in G3.edgesBetween(V) by A13, GLIB_000:32;
      then e3 in the_Edges_of G4 & e3 is set by A1, GLIB_000:def 37;
      then e3 DJoins v,w,G4 by A12, GLIB_000:73;
      hence contradiction by A10;
    end;
    then consider e1 being object such that
      A14: e1 DJoins v,w,G1;
    take e1;
    A15: e1 Joins v,w,G1 by A14, GLIB_000:16;
    the_Vertices_of G2 = V by GLIB_000:def 37;
    then e1 in G1.edgesBetween(V) by A15, GLIB_000:32;
    then e1 in the_Edges_of G2 & e1 is set by GLIB_000:def 37;
    hence e1 DJoins v,w,G2 by A14, GLIB_000:73;
  end;
  hence thesis by A2, A3, Th80;
end;

theorem
  for G1 being _Graph, V being proper Subset of the_Vertices_of G1
  for G2 being removeVertices of G1, V
  for G3 being DGraphComplement of G1, G4 being removeVertices of G3, V
  holds G4 is DGraphComplement of G2
proof
  let G1 be _Graph, V be proper Subset of the_Vertices_of G1;
  let G2 be removeVertices of G1, V;
  let G3 be DGraphComplement of G1, G4 be removeVertices of G3, V;
  the_Vertices_of G1 \ V is non empty Subset of the_Vertices_of G1 &
    the_Vertices_of G1 \ V = the_Vertices_of G3 \ V
    by Th80, XBOOLE_1:105, GLIBPRE0:6;
  hence thesis by Th87;
end;

:: involutiveness of graph complement (DC case)
theorem
  for G1 being Dsimple _Graph, G2 being DGraphComplement of G1
  holds G1 is DGraphComplement of G2
proof
  let G1 be Dsimple _Graph, G2 be DGraphComplement of G1;
  A1: the_Vertices_of G1 = the_Vertices_of G2 &
    the_Edges_of G1 misses the_Edges_of G2 by Th80;
  now
    let v,w be Vertex of G2;
    assume A2: v <> w;
    v is Vertex of G1 & w is Vertex of G1 by Th80;
    hence (ex e2 being object st e2 DJoins v,w,G2) iff
      (not ex e1 being object st e1 DJoins v,w,G1) by A2, Th80;
  end;
  hence thesis by A1, Th80;
end;

theorem Th90:
  for G1 being _Graph, G2 being DGraphComplement of G1
  holds G1.order() = G2.order() by Th80;

theorem Th91:
  for G1 being _Graph, G2 being DGraphComplement of G1
  holds G1 is _trivial iff G2 is _trivial
proof
  let G1 be _Graph, G2 be DGraphComplement of G1;
  hereby
    assume G1 is _trivial;
    then 1 = G1.order() by GLIB_000:26
      .= G2.order() by Th90;
    hence G2 is _trivial by GLIB_000:26;
  end;
  hereby
    assume G2 is _trivial;
    then 1 = G2.order() by GLIB_000:26
      .= G1.order() by Th90;
    hence G1 is _trivial by GLIB_000:26;
  end;
end;

registration
  let G be _trivial _Graph;
  cluster -> _trivial for DGraphComplement of G;
  coherence by Th91;
end;

registration
  let G be non _trivial _Graph;
  cluster -> non _trivial for DGraphComplement of G;
  coherence by Th91;
end;

theorem Th92:
  for G1 being _Graph, G2 being DGraphComplement of G1
  st the_Edges_of G1 = G1.loops() holds G2 is complete
proof
  let G1 be _Graph, G2 be DGraphComplement of G1;
  assume A1: the_Edges_of G1 = G1.loops();
  now
    let v,w be Vertex of G2;
    A2: v is Vertex of G1 & w is Vertex of G1 by Th80;
    assume A3: v <> w;
    not ex e1 being object st e1 DJoins v,w,G1
    proof
      given e1 being object such that
        A4: e1 DJoins v,w,G1;
      e1 Joins v,w,G1 by A4, GLIB_000:16;
      hence contradiction by A1, A3, A4, GLIB_009:46, GLIB_000:def 14;
    end;
    then consider e2 being object such that
      A5: e2 DJoins v,w,G2 by A2, A3, Th80;
    e2 Joins v,w,G2 by A5, GLIB_000:16;
    hence v,w are_adjacent by CHORD:def 3;
  end;
  hence thesis by CHORD:def 6;
end;

registration
  let G be edgeless _Graph;
  cluster -> complete for DGraphComplement of G;
  coherence
  proof
    let G2 be DGraphComplement of G;
    the_Edges_of G = {} & G.loops() = {};
    hence thesis by Th92;
  end;
end;

registration
  let G be _trivial edgeless _Graph;
  cluster -> edgeless for DGraphComplement of G;
  coherence;
end;

registration
  let G be non connected _Graph;
  cluster -> connected for DGraphComplement of G;
  coherence
  proof
    let G2 be DGraphComplement of G;
    consider G9 being DLGraphComplement of G such that
      A1: G2 is removeLoops of G9 by Def8;
    thus thesis by A1;
  end;
end;

theorem
  for G1 being non _trivial _Graph, G2 being DGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2 st v1 = v2
  holds v1 is isolated implies v2 is non isolated
proof
  let G1 be non _trivial _Graph, G2 be DGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2;
  assume A2: v1 is isolated;
  set v9 = the Element of the_Vertices_of G1 \ {v1};
  the_Vertices_of G1 \ {v1} <> {} by GLIB_000:20;
  then A3: v9 in the_Vertices_of G1 \ {v1};
  then reconsider v9 as Vertex of G1;
  A4: v9 <> v1 by A3, ZFMISC_1:56;
  not ex e being object st e DJoins v1,v9,G1 by A2, GLIBPRE0:22;
  then ex e being object st e DJoins v1,v9,G2 by A4, Th80;
  hence v2 is non isolated by A1, GLIBPRE0:22;
end;

theorem
  for G1 being _Graph, G2 being DGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & 3 c= G1.order()
  holds v1 is endvertex implies v2 is non endvertex
proof
  let G1 be _Graph, G2 be DGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & 3 c= G1.order();
  assume v1 is endvertex;
  then consider u,w being Vertex of G1 such that
    A2: u<>v1 & w<>v1 & u <> w & u,v1 are_adjacent & not v1,w are_adjacent
    by A1, GLIBPRE0:97;
  not ex e being object st e DJoins v1,w,G1
  proof
    given e being object such that
      A3: e DJoins v1,w,G1;
    e Joins v1,w,G1 by A3, GLIB_000:16;
    hence contradiction by A2, CHORD:def 3;
  end;
  then consider e1 being object such that
    A4: e1 DJoins v1,w,G2 by A2, Th80;
  not ex e being object st e DJoins w,v1,G1
  proof
    given e being object such that
      A5: e DJoins w,v1,G1;
    e Joins v1,w,G1 by A5, GLIB_000:16;
    hence contradiction by A2, CHORD:def 3;
  end;
  then consider e2 being object such that
    A6: e2 DJoins w,v1,G2 by A2, Th80;
  A7: e1 <> e2 by A2, A4, A6, GLIB_009:6;
  reconsider w as Vertex of G2 by Th80;
  reconsider e1, e2 as set by TARSKI:1;
  e1 Joins v2,w,G2 & e2 Joins v2,w,G2 by A1, A4, A6, GLIB_000:16;
  then e1 in v2.edgesInOut() & e2 in v2.edgesInOut() by GLIB_000:64;
  then A8: {e1,e2} c= v2.edgesInOut() by ZFMISC_1:32;
  assume v2 is endvertex;
  then consider e9 being object such that
    A9: v2.edgesInOut() = {e9} & not e9 Joins v2,v2,G2 by GLIB_000:def 51;
  e1 = e9 & e2 = e9 by A8, A9, ZFMISC_1:20;
  hence contradiction by A7;
end;

theorem Th95:
  for G1 being _Graph, G2 being DGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 holds
    v2.inNeighbors() = the_Vertices_of G2 \ (v1.inNeighbors() \/ {v2}) &
    v2.outNeighbors() = the_Vertices_of G2 \ (v1.outNeighbors() \/ {v2})
proof
  let G1 be _Graph, G2 be DGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2;
  consider G9 being DLGraphComplement of G1 such that
    A2: G2 is removeLoops of G9 by Def8;
  reconsider v9 = v1 as Vertex of G9 by Def6;
  thus v2.inNeighbors() = v9.inNeighbors() \ {v2} by A1, A2, GLIBPRE0:65
    .= (the_Vertices_of G9 \ v1.inNeighbors()) \ {v2} by Th60
    .= the_Vertices_of G9 \ (v1.inNeighbors() \/ {v2}) by XBOOLE_1:41
    .= the_Vertices_of G2 \ (v1.inNeighbors() \/ {v2}) by A2, GLIB_000:53;
  thus v2.outNeighbors() = v9.outNeighbors() \ {v2} by A1, A2, GLIBPRE0:65
    .= (the_Vertices_of G9 \ v1.outNeighbors()) \ {v2} by Th60
    .= the_Vertices_of G9 \ (v1.outNeighbors() \/ {v2}) by XBOOLE_1:41
    .= the_Vertices_of G2 \ (v1.outNeighbors() \/ {v2}) by A2, GLIB_000:53;
end;

theorem
  for G1 being _Graph, G2 being DGraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & v1 is isolated holds
    v2.inNeighbors() = the_Vertices_of G2 \ {v2} &
    v2.outNeighbors() = the_Vertices_of G2 \ {v2} &
    v2.allNeighbors() = the_Vertices_of G2 \ {v2}
proof
  let G1 be _Graph, G2 be DGraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & v1 is isolated;
  then v1.allNeighbors() = {} by GLIB_008:7;
  then A2: v1.inNeighbors() = {} & v1.outNeighbors() = {};
  thus A3: v2.inNeighbors() = the_Vertices_of G2 \ ({}\/{v2}) by A1, A2, Th95
    .= the_Vertices_of G2 \ {v2};
  thus v2.outNeighbors() = the_Vertices_of G2 \ ({} \/ {v2}) by A1, A2, Th95
    .= the_Vertices_of G2 \ {v2};
  hence thesis by A3;
end;

begin :: Undirected Graph Complement without Loops

definition
  let G be _Graph;
  mode GraphComplement of G -> simple _Graph means
  :Def9:
  ex G9 being LGraphComplement of G st it is removeLoops of G9;
  existence
  proof
    set G1 = the LGraphComplement of G;
    take the removeLoops of G1;
    thus thesis;
  end;
end;

theorem Th97:
  for G1, G2, G3 being _Graph, G4 being GraphComplement of G1
  st G1 == G2 & G3 == G4 holds G3 is GraphComplement of G2
proof
  let G1, G2, G3 be _Graph, G4 be GraphComplement of G1;
  assume A1: G1 == G2 & G3 == G4;
  consider G9 being LGraphComplement of G1 such that
    A2: G4 is removeLoops of G9 by Def9;
  G9 is LGraphComplement of G2 & G3 is removeLoops of G9
    by A1, A2, Th62, GLIB_009:59;
  hence thesis by Def9;
end;

registration
  let G be _Graph;
  cluster plain for GraphComplement of G;
  existence
  proof
    set G1 = the GraphComplement of G;
    set G2 = G1 | _GraphSelectors;
    G1 == G1 & G1 == G2 by GLIB_009:9;
    then reconsider G2 as GraphComplement of G by Th97;
    take G2;
    thus thesis;
  end;
end;

theorem Th98:
  for G1 being _Graph, G2 being simple _Graph
  holds G2 is GraphComplement of G1 iff
    the_Vertices_of G2 = the_Vertices_of G1 &
    the_Edges_of G2 misses the_Edges_of G1 &
    for v,w being Vertex of G1 st v <> w holds
      (ex e1 being object st e1 Joins v,w,G1) iff
      (not ex e2 being object st e2 Joins v,w,G2)
proof
  let G1 be _Graph, G2 be simple _Graph;
  :: the first direction is straight forward
  hereby
    assume G2 is GraphComplement of G1;
    then consider G9 being LGraphComplement of G1 such that
      A1: G2 is removeLoops of G9 by Def9;
    thus the_Vertices_of G2 = the_Vertices_of G9 by A1, GLIB_000:def 33
      .= the_Vertices_of G1 by Def7;
    A2: the_Edges_of G2 c= the_Edges_of G9 by A1, GLIB_000:def 32;
    the_Edges_of G9 misses the_Edges_of G1 by Def7;
    hence the_Edges_of G2 misses the_Edges_of G1 by A2, XBOOLE_1:63;
    let v,w be Vertex of G1;
    assume A3: v <> w;
    hereby
      given e1 being object such that
        A4: e1 Joins v,w,G1;
      given e2 being object such that
        A5: e2 Joins v,w,G2;
      e2 Joins v,w,G9 by A1, A5, GLIB_000:72;
      hence contradiction by A4, Th64;
    end;
    assume A6: not ex e2 being object st e2 Joins v,w,G2;
    not ex e9 being object st e9 Joins v,w,G9
    proof
      given e9 being object such that
        A7: e9 Joins v,w,G9;
      A8: e9 in the_Edges_of G9 by A7, GLIB_000:def 13;
      not e9 in G9.loops() by A3, A7, GLIB_009:46;
      then e9 in the_Edges_of G9 \ G9.loops() by A8, XBOOLE_0:def 5;
      then A9: e9 in the_Edges_of G2 by A1, GLIB_000:53;
      e9 Joins v,w,G2 by A1, A7, A9, GLIB_000:73;
      hence contradiction by A6;
    end;
    hence ex e1 being object st e1 Joins v,w,G1 by Def7;
  end;
  :: for the second direction we need to add loops to G2 to get a G9
  :: but the loops must be distinct from both the edges of G1 and of G2,
  :: so some construction is needed (except if G1 is already loopfull)
  assume that A10: the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 misses the_Edges_of G1 and
    A11: for v,w being Vertex of G1 st v <> w holds
      (ex e1 being object st e1 Joins v,w,G1) iff
      (not ex e2 being object st e2 Joins v,w,G2);
  per cases;
  suppose A12: G1 is non loopfull;
    defpred P[object] means not ex e being object st e Joins $1,$1,G1;
    consider V being Subset of the_Vertices_of G2 such that
      A13: for x being set holds x in V iff x in the_Vertices_of G2 & P[x]
      from SUBSET_1:sch 1;
    A14: V is non empty by A10, A12, A13;
    set E = the set of all [{the_Edges_of G1,the_Edges_of G2},v]
      where v is Element of V;
    deffunc F(object) = $1`2;
    consider f being Function such that
      A15: dom f = E & for x being object st x in E holds f.x = F(x)
      from FUNCT_1:sch 3;
    now
      let x1,x2 be object;
      assume A16: x1 in dom f & x2 in dom f & f.x1 = f.x2;
      then consider v1 being Element of V such that
        A17: x1 = [{the_Edges_of G1,the_Edges_of G2},v1] by A15;
      consider v2 being Element of V such that
        A18: x2 = [{the_Edges_of G1,the_Edges_of G2},v2] by A15, A16;
      v1 = [{the_Edges_of G1,the_Edges_of G2},v1]`2
        .= f.x1 by A15, A16, A17
        .= [{the_Edges_of G1,the_Edges_of G2},v2]`2 by A15, A16, A18
        .= v2;
      hence x1 = x2 by A17, A18;
    end;
    then reconsider f as one-to-one Function by FUNCT_1:def 4;
    now
      let y be object;
      hereby
        assume y in rng f;
        then consider x being object such that
          A19: x in dom f & f.x = y by FUNCT_1:def 3;
        consider v being Element of V such that
          A20: x = [{the_Edges_of G1,the_Edges_of G2},v] by A15, A19;
        y = [{the_Edges_of G1,the_Edges_of G2},v]`2 by A15, A19, A20
          .= v;
        hence y in V by A14;
      end;
      set x = [{the_Edges_of G1,the_Edges_of G2},y];
      assume y in V;
      then A21: x in E;
      then f.x = [{the_Edges_of G1,the_Edges_of G2},y]`2 by A15
        .= y;
      hence y in rng f by A15, A21, FUNCT_1:3;
    end;
    then A22: rng f = V by TARSKI:2;
    A23: E misses the_Edges_of G1
    proof
      assume E meets the_Edges_of G1;
      then consider e being object such that
        A24: e in E & e in the_Edges_of G1 by XBOOLE_0:3;
      reconsider e as set by TARSKI:1;
      consider v being Element of V such that
        A25: e = [{the_Edges_of G1,the_Edges_of G2},v] by A24;
      A26: e = {{{the_Edges_of G1,the_Edges_of G2}, v},
        {{the_Edges_of G1,the_Edges_of G2}}} by A25, TARSKI:def 5;
      A27: the_Edges_of G1 in
        {the_Edges_of G1, the_Edges_of G2} by TARSKI:def 2;
      A28: {the_Edges_of G1, the_Edges_of G2} in
        {{the_Edges_of G1, the_Edges_of G2}} by TARSKI:def 1;
      {{the_Edges_of G1, the_Edges_of G2}} in e by A26, TARSKI:def 2;
      hence contradiction by A24, A27, A28, XREGULAR:8;
    end;
    A29: E misses the_Edges_of G2
    proof
      assume E meets the_Edges_of G2;
      then consider e being object such that
        A30: e in E & e in the_Edges_of G2 by XBOOLE_0:3;
      reconsider e as set by TARSKI:1;
      consider v being Element of V such that
        A31: e = [{the_Edges_of G1,the_Edges_of G2},v] by A30;
      A32: e = {{{the_Edges_of G1,the_Edges_of G2}, v},
        {{the_Edges_of G1,the_Edges_of G2}}} by A31, TARSKI:def 5;
      A33: the_Edges_of G2 in
        {the_Edges_of G1, the_Edges_of G2} by TARSKI:def 2;
      A34: {the_Edges_of G1, the_Edges_of G2} in
        {{the_Edges_of G1, the_Edges_of G2}} by TARSKI:def 1;
      {{the_Edges_of G1, the_Edges_of G2}} in e by A32, TARSKI:def 2;
      hence contradiction by A30, A33, A34,  XREGULAR:8;
    end;
    set s = the_Source_of G2 +* f;
    now
      thus dom s = dom the_Source_of G2 \/ dom f by FUNCT_4:def 1
        .= the_Edges_of G2 \/ E by A15, FUNCT_2:def 1;
      A35: rng s c= rng the_Source_of G2 \/ rng f by FUNCT_4:17;
      rng the_Source_of G2 \/ rng f c= the_Vertices_of G2 by A22, XBOOLE_1:8;
      hence rng s c= the_Vertices_of G2 by A35, XBOOLE_1:1;
    end;
    then reconsider s as Function of the_Edges_of G2 \/ E, the_Vertices_of G2
      by FUNCT_2:2;
    set t = the_Target_of G2 +* f;
    now
      thus dom t = dom the_Target_of G2 \/ dom f by FUNCT_4:def 1
        .= the_Edges_of G2 \/ E by A15, FUNCT_2:def 1;
      A36: rng t c= rng the_Target_of G2 \/ rng f by FUNCT_4:17;
      rng the_Target_of G2 \/ rng f c= the_Vertices_of G2 by A22, XBOOLE_1:8;
      hence rng t c= the_Vertices_of G2 by A36, XBOOLE_1:1;
    end;
    then reconsider t as Function of the_Edges_of G2 \/ E, the_Vertices_of G2
      by FUNCT_2:2;
    set G9 = createGraph(the_Vertices_of G2,the_Edges_of G2 \/ E,s,t);
    :: show that G9 is addLoops
    now
      :: for that first show that G9 is Supergraph
      now
        thus the_Vertices_of G2 c= the_Vertices_of G9;
        thus the_Edges_of G2 c= the_Edges_of G9 by XBOOLE_1:7;
        let e be set;
        assume A37: e in the_Edges_of G2;
        then e in the_Edges_of G2 \/ E by XBOOLE_0:def 3;
        then A38: not e in dom f by A15, A29, A37, XBOOLE_0:5;
        hence (the_Source_of G2).e = (the_Source_of G2 +* f).e by FUNCT_4:11
          .= (the_Source_of G9).e;
        thus (the_Target_of G2).e = (the_Target_of G2 +* f).e
            by A38, FUNCT_4:11
          .= (the_Target_of G9).e;
      end;
      hence G9 is Supergraph of G2 by GLIB_006:def 9;
      thus the_Vertices_of G9 = the_Vertices_of G2;
      reconsider E as set;
      reconsider f as one-to-one Function;
      take E, f;
      thus E misses the_Edges_of G2 by A29;
      thus the_Edges_of G9 = the_Edges_of G2 \/ E;
      thus dom f = E by A15;
      thus rng f = V by A22;
      thus the_Source_of G9 = the_Source_of G2 +* f;
      thus the_Target_of G9 = the_Target_of G2 +* f;
    end;
    then A39: G9 is addLoops of G2, V by Def5;
    then G2 == the removeLoops of G9 by Th26;
    then A40: G2 is removeLoops of G9 by GLIB_009:59;
    A41: G9 is non-multi by A39;
    :: show that G9 is LGraphComplement
    now
      thus the_Vertices_of G9 = the_Vertices_of G1 by A10;
      thus the_Edges_of G9 misses the_Edges_of G1 by A10, A23, XBOOLE_1:70;
      let v,w be Vertex of G1;
      hereby
        given e1 being object such that
          A43: e1 Joins v,w,G1;
        given e2 being object such that
          A44: e2 Joins v,w,G9;
        per cases by A39, A44, GLIB_006:72;
        suppose A45: e2 Joins v,w,G2;
          then v <> w by GLIB_000:18;
          hence contradiction by A11, A43, A45;
        end;
        suppose A46: not e2 in the_Edges_of G2;
          e2 in the_Edges_of G9 by A44, GLIB_000:def 13;
          then A47: e2 in E by A46, XBOOLE_0:def 3;
          then consider u being Element of V such that
            A48: e2 = [{the_Edges_of G1,the_Edges_of G2},u];
          A49: not ex e being object st e Joins u,u,G1 by A13, A14;
          A50: (the_Source_of G9).e2 = s.e2
             .= f.e2 by A15, A47, FUNCT_4:13
             .= [{the_Edges_of G1,the_Edges_of G2},u]`2 by A15, A47, A48
             .= u;
          (the_Target_of G9).e2 = t.e2
             .= f.e2 by A15, A47, FUNCT_4:13
             .= [{the_Edges_of G1,the_Edges_of G2},u]`2 by A15, A47, A48
             .= u;
          then v = u & w = u by A44, A50, GLIB_000:def 13;
          hence contradiction by A43, A49;
        end;
      end;
      assume A51: not ex e2 being object st e2 Joins v,w,G9;
      assume A52: not ex e1 being object st e1 Joins v,w,G1;
      per cases;
      suppose A53: v <> w;
        not ex e2 being object st e2 Joins v,w,G2 by A39, A51, GLIB_006:70;
        hence contradiction by A11, A52, A53;
      end;
      suppose A54: v = w;
        set e = [{the_Edges_of G1,the_Edges_of G2},v];
        A55: not ex e1 being object st e1 Joins v,v,G1 by A52, A54;
        v in V by A10, A13, A55;
        then A56: e in E;
        then A57: e in the_Edges_of G9 by XBOOLE_0:def 3;
        A58: (the_Source_of G9).e = s.e
          .= f.e by A15, A56, FUNCT_4:13
          .= e`2 by A15, A56
          .= v;
        (the_Target_of G9).e = t.e
          .= f.e by A15, A56, FUNCT_4:13
          .= e`2 by A15, A56
          .= v;
        then e Joins v,w,G9 by A54, A57, A58, GLIB_000:def 13;
        hence contradiction by A51;
      end;
    end;
    then G9 is LGraphComplement of G1 by A41, Def7;
    hence thesis by A40, Def9;
  end;
  suppose A59: G1 is loopfull;
    now
      let v,w be Vertex of G1;
      hereby
        given e1 being object such that
          A60: e1 Joins v,w,G1;
        per cases;
        suppose v <> w;
          hence not ex e2 being object st e2 Joins v,w,G2 by A11, A60;
        end;
        suppose v = w;
          hence not ex e2 being object st e2 Joins v,w,G2 by GLIB_000:18;
        end;
      end;
      assume A61: not ex e2 being object st e2 Joins v,w,G2;
      per cases;
      suppose v <> w;
        hence ex e1 being object st e1 Joins v,w,G1 by A11, A61;
      end;
      suppose v = w;
        hence ex e1 being object st e1 Joins v,w,G1 by A59;
      end;
    end;
    then A62: G2 is LGraphComplement of G1 by A10, Def7;
    G2 is removeLoops of G2 by GLIB_009:58;
    hence thesis by A62, Def9;
  end;
end;

theorem Th99:
  for G1 being _Graph, G2 being simple _Graph
  holds G2 is GraphComplement of G1 iff
    the_Vertices_of G2 = the_Vertices_of G1 &
    the_Edges_of G2 misses the_Edges_of G1 &
    for v1,w1 being Vertex of G1, v2,w2 being Vertex of G2
    st v1 = v2 & w1 = w2 & v1 <> w1
    holds v1,w1 are_adjacent iff not v2,w2 are_adjacent
proof
  let G1 be _Graph, G2 be simple _Graph;
  hereby
    assume A1: G2 is GraphComplement of G1;
    hence the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 misses the_Edges_of G1 by Th98;
    let v1,w1 be Vertex of G1, v2,w2 be Vertex of G2;
    assume A2: v1 = v2 & w1 = w2 & v1 <> w1;
    hereby
      assume v1,w1 are_adjacent;
      then ex e1 being object st e1 Joins v1,w1,G1 by CHORD:def 3;
      then not ex e2 being object st e2 Joins v1,w1,G2 by A1, A2, Th98;
      hence not v2,w2 are_adjacent by A2, CHORD:def 3;
    end;
    assume not v2,w2 are_adjacent;
    then not ex e2 being object st e2 Joins v1,w1,G2 by A2, CHORD:def 3;
    then ex e1 being object st e1 Joins v1,w1,G1 by A1, A2, Th98;
    hence v1,w1 are_adjacent by CHORD:def 3;
  end;
  assume that A3: the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 misses the_Edges_of G1 and
    A4: for v1,w1 being Vertex of G1, v2,w2 being Vertex of G2
      st v1 = v2 & w1 = w2 & v1 <> w1
      holds v1,w1 are_adjacent iff not v2,w2 are_adjacent;
  now
    let v1,w1 be Vertex of G1;
    assume A5: v1 <> w1;
    reconsider v2=v1, w2=w1 as Vertex of G2 by A3;
    hereby
      assume ex e1 being object st e1 Joins v1,w1,G1;
      then v1,w1 are_adjacent by CHORD:def 3;
      then not v2,w2 are_adjacent by A5, A4;
      hence not ex e2 being object st e2 Joins v1,w1,G2 by CHORD:def 3;
    end;
    assume not ex e2 being object st e2 Joins v1,w1,G2;
    then not v2,w2 are_adjacent by CHORD:def 3;
    then v1,w1 are_adjacent by A5, A4;
    hence ex e1 being object st e1 Joins v1,w1,G1 by CHORD:def 3;
  end;
  hence thesis by A3, Th98;
end;

theorem Th100:
  for G1 being _Graph, G2 being GraphComplement of G1, e1,e2,v,w being object
  holds e1 Joins v,w,G1 implies not e2 Joins v,w,G2
proof
  let G1 be _Graph, G2 be GraphComplement of G1, e1,e2,v,w be object;
  assume A1: e1 Joins v,w,G1;
  per cases;
  suppose A2: v <> w;
    v in the_Vertices_of G1 & w in the_Vertices_of G1 by A1, GLIB_000:13;
    hence thesis by A1, A2, Th98;
  end;
  suppose v = w;
    hence thesis by GLIB_000:18;
  end;
end;

theorem Th101:
  for G1 being _Graph, G2 being SimpleGraph of G1
  for G3 being GraphComplement of G1 holds G3 is GraphComplement of G2
proof
  let G1 be _Graph, G2 be SimpleGraph of G1, G3 be GraphComplement of G1;
  consider E being RepEdgeSelection of G1 such that
    A1: G2 is inducedSubgraph of G1, the_Vertices_of G1, E\G1.loops()
    by GLIB_009:def 9;
  the_Vertices_of G1 c= the_Vertices_of G1 &
    the_Edges_of G1 = G1.edgesBetween(the_Vertices_of G1) by GLIB_000:34;
  then A2: the_Vertices_of G2 = the_Vertices_of G1 &
    the_Edges_of G2 = E \ G1.loops() by A1, GLIB_000:def 37;
  then A3: the_Vertices_of G3 = the_Vertices_of G2 by Th98;
  the_Edges_of G3 misses the_Edges_of G1 by Th98;
  then A4: the_Edges_of G3 misses the_Edges_of G2 by XBOOLE_1:63;
  now
    let v,w be Vertex of G2;
    assume A5: v <> w;
    A6: v is Vertex of G1 & w is Vertex of G1 by GLIB_000:def 33;
    reconsider v1=v, w1=w as Vertex of G1 by GLIB_000:def 33;
    hereby
      given e2 being object such that
        A7: e2 Joins v,w,G2;
      A8: e2 Joins v,w,G1 by A7, GLIB_000:72;
      given e3 being object such that
        A9: e3 Joins v,w,G3;
      thus contradiction by A8, A9, Th100;
    end;
    assume not ex e3 being object st e3 Joins v,w,G3;
    then consider e1 being object such that
      A10: e1 Joins v,w,G1 by A6, A5, Th98;
    consider e2 being object such that
      A11: e2 Joins v,w,G1 & e2 in E and
      for e9 being object st e9 Joins v,w,G1 & e9 in E holds e9 = e2
      by A10, GLIB_009:def 5;
    take e2;
    not e2 in G1.loops() by A5, A11, GLIB_009:46;
    then e2 in the_Edges_of G2 by A2, A11, XBOOLE_0:def 5;
    hence e2 Joins v,w,G2 by A11, GLIB_000:73;
  end;
  hence thesis by A3, A4, Th98;
end;

theorem Th102:
  for G1, G2 being _Graph
  for G3 being SimpleGraph of G1, G4 being SimpleGraph of G2
  for G5 being GraphComplement of G1, G6 being GraphComplement of G2
  st G4 is G3-isomorphic holds G6 is G5-isomorphic
proof
  let G1, G2 be _Graph;
  let G3 be SimpleGraph of G1, G4 be SimpleGraph of G2;
  let G5 be GraphComplement of G1, G6 be GraphComplement of G2;
  A1: G5 is GraphComplement of G3 & G6 is GraphComplement of G4 by Th101;
  assume G4 is G3-isomorphic;
  then consider f being PVertexMapping of G3, G4 such that
    A2: f is isomorphism by GLIB_011:49;
  A3: the_Vertices_of G3 = the_Vertices_of G5 &
    the_Vertices_of G4 = the_Vertices_of G6 by A1, Th98;
  then reconsider g = f as PartFunc of the_Vertices_of G5, the_Vertices_of G6;
  now
    let v,w,e be object;
    assume A4: v in dom g & w in dom g & e Joins v,w,G5;
    then A5: v <> w by GLIB_000:18;
    then A6: g.v <> g.w by A2, A4, FUNCT_1:def 4;
    A7: not ex e3 being object st e3 Joins v,w,G3
      by A1, A3, A4, A5, Th98;
    thus ex e6 being object st e6 Joins g.v,g.w,G6
    proof
      assume A8: not ex e6 being object st e6 Joins g.v,g.w,G6;
      g.v in rng f & g.w in rng f by A4, FUNCT_1:3;
      then consider e4 being object such that
        A9: e4 Joins g.v,g.w,G4 by A1, A6, A8, Th98;
      consider e3 being object such that
        A10: e3 Joins v,w,G3 by A2, A4, A9, GLIB_011:2;
      thus contradiction by A7, A10;
    end;
  end;
  then reconsider g as PVertexMapping of G5, G6 by GLIB_011:1;
  now
    let v,w,e6 be object;
    assume A11: v in dom g & w in dom g & e6 Joins g.v,g.w,G6;
    then A12: g.v <> g.w by GLIB_000:18;
    A13: v in the_Vertices_of G3 & w in the_Vertices_of G3 by A3, A11;
    g.v in rng f & g.w in rng f by A11, FUNCT_1:3;
    then A14: not ex e4 being object st e4 Joins g.v,g.w,G4
      by A1, A11, A12, Th98;
    thus ex e5 being object st e5 Joins v,w,G5
    proof
      assume not ex e5 being object st e5 Joins v,w,G5;
      then consider e3 being object such that
        A15: e3 Joins v,w,G3 by A1, A12, A13, Th98;
      consider e4 being object such that
        A16: e4 Joins f.v,f.w,G4 by A11, A15, GLIB_011:1;
      thus contradiction by A14, A16;
    end;
  end;
  then g is continuous by GLIB_011:2;
  hence thesis by A2, A3, GLIB_011:49;
end;

theorem Th103:
  for G1 being _Graph, G2 being G1-isomorphic _Graph
  for G3 being GraphComplement of G1, G4 being GraphComplement of G2
  holds G4 is G3-isomorphic
proof
  let G1 be _Graph, G2 be G1-isomorphic _Graph;
  let G3 be GraphComplement of G1, G4 be GraphComplement of G2;
  set G5 = the SimpleGraph of G1;
  set G6 = the SimpleGraph of G2;
  G6 is G5-isomorphic by GLIB_010:172;
  hence thesis by Th102;
end;

theorem Th104:
  for G1 being _Graph, G2, G3 being GraphComplement of G1
  holds G3 is G2-isomorphic
proof
  let G1 be _Graph, G2, G3 be GraphComplement of G1;
  G1 is G1-isomorphic by GLIB_010:53;
  hence thesis by Th103;
end;

theorem Th105:
  for G1 being _Graph, v being object, V being Subset of the_Vertices_of G1
  for G2 being addAdjVertexAll of G1,v,V
  for G3 being GraphComplement of G1
  st not v in the_Vertices_of G1 & the_Edges_of G2 misses the_Edges_of G3
  ex G4 being addAdjVertexAll of G3,v,the_Vertices_of G1 \ V
  st G4 is GraphComplement of G2
proof
  let G1 be _Graph, v be object, V be Subset of the_Vertices_of G1;
  let G2 be addAdjVertexAll of G1,v,V;
  let G3 be GraphComplement of G1;
  assume A1: not v in the_Vertices_of G1 &
    the_Edges_of G2 misses the_Edges_of G3;
  consider E0 being set such that
    card V = card E0 & E0 misses the_Edges_of G1 and
    the_Edges_of G2 = the_Edges_of G1 \/ E0 and
    A2: for v1 being object st v1 in V ex e1 being object st e1 in E0 &
      e1 Joins v1,v,G2 &
      for e2 being object st e2 Joins v1,v,G2 holds e1 = e2
    by A1, GLIB_007:def 4;
  per cases;
  suppose A3: the_Vertices_of G1 \ V <> {};
    :: construct G4
    set E = the set of all [{the_Edges_of G2,the_Edges_of G3},w]
      where w is Element of the_Vertices_of G1 \ V;
    deffunc S(object) = $1`2;
    consider h being Function such that
      A4: dom h = E & for x being object st x in E holds h.x = S(x)
      from FUNCT_1:sch 3;
    :: recognize the source
    set s = the_Source_of G3 +* h;
    A5: dom s = dom the_Source_of G3 \/ dom h by FUNCT_4:def 1
      .= the_Edges_of G3 \/ E by A4, FUNCT_2:def 1;
    now
      let y be object;
      hereby
        set x = [{the_Edges_of G2,the_Edges_of G3},y];
        assume y in the_Vertices_of G1 \ V;
        then A6: x in E;
        then h.x = x`2 by A4
          .= y;
        hence y in rng h by A4, A6, FUNCT_1:def 3;
      end;
      assume y in rng h;
      then consider x being object such that
        A7: x in dom h & h.x = y by FUNCT_1:def 3;
      reconsider x as set by TARSKI:1;
      consider w being Element of the_Vertices_of G1 \ V such that
        A8: x = [{the_Edges_of G2,the_Edges_of G3},w] by A4, A7;
      h.x = x`2 by A4, A7
        .= w by A8;
      hence y in the_Vertices_of G1 \ V by A3, A7;
    end;
    then A9: rng h = the_Vertices_of G1 \ V by TARSKI:2
      .= the_Vertices_of G3 \ V by Th98;
    then A10: rng the_Source_of G3 \/rng h c= the_Vertices_of G3 by XBOOLE_1:8;
    rng s c= rng the_Source_of G3 \/ rng h by FUNCT_4:17;
    then A11: rng s c= the_Vertices_of G3 by A10, XBOOLE_1:1;
    the_Vertices_of G3 c= the_Vertices_of G3 \/ {v} by XBOOLE_1:7;
    then reconsider s as Function of the_Edges_of G3 \/ E,
      the_Vertices_of G3 \/ {v} by A5, A11, XBOOLE_1:1, FUNCT_2:2;
    :: recognize the target
    set t = the_Target_of G3 +* (E --> v);
    A12: dom t = dom the_Target_of G3 \/ dom(E-->v) by FUNCT_4:def 1
      .= the_Edges_of G3 \/ E by FUNCT_2:def 1;
    the_Vertices_of G3 c= the_Vertices_of G3 \/ {v} by XBOOLE_1:7;
    then A13: rng the_Target_of G3 c= the_Vertices_of G3 \/ {v}
      by XBOOLE_1:1;
    A14: {v} c= the_Vertices_of G3 \/ {v} by XBOOLE_1:7;
    A15: rng t c= rng the_Target_of G3 \/ rng(E --> v) by FUNCT_4:17;
    rng(E --> v) c= the_Vertices_of G3 \/ {v} by A14, XBOOLE_1:1;
    then rng the_Target_of G3 \/ rng(E --> v) c= the_Vertices_of G3 \/ {v}
      by A13, XBOOLE_1:8;
    then reconsider t as Function of the_Edges_of G3 \/ E,
      the_Vertices_of G3 \/ {v} by A12, A15, XBOOLE_1:1, FUNCT_2:2;
    :: E misses all other edges
    A16: E misses the_Edges_of G3
    proof
      assume E meets the_Edges_of G3;
      then consider e being object such that
        A17: e in E & e in the_Edges_of G3 by XBOOLE_0:3;
      reconsider e as set by TARSKI:1;
      consider w being Element of the_Vertices_of G1 \ V such that
        A18: e = [{the_Edges_of G2,the_Edges_of G3},w] by A17;
      A19: the_Edges_of G3 in {the_Edges_of G2, the_Edges_of G3}
        by TARSKI:def 2;
      A20: {the_Edges_of G2, the_Edges_of G3} in
        {{the_Edges_of G2, the_Edges_of G3}} by TARSKI:def 1;
      e = { { {the_Edges_of G2, the_Edges_of G3}, w },
        {{the_Edges_of G2, the_Edges_of G3}} } by A18, TARSKI:def 5;
      then {{the_Edges_of G2, the_Edges_of G3}} in e by TARSKI:def 2;
      hence contradiction by A17, A19, A20, XREGULAR:8;
    end;
    A21: E misses the_Edges_of G2
    proof
      assume E meets the_Edges_of G2;
      then consider e being object such that
        A22: e in E & e in the_Edges_of G2 by XBOOLE_0:3;
      reconsider e as set by TARSKI:1;
      consider w being Element of the_Vertices_of G1 \ V such that
        A23: e = [{the_Edges_of G2,the_Edges_of G3},w] by A22;
      A24: the_Edges_of G2 in {the_Edges_of G2, the_Edges_of G3}
        by TARSKI:def 2;
      A25: {the_Edges_of G2, the_Edges_of G3} in
        {{the_Edges_of G2, the_Edges_of G3}} by TARSKI:def 1;
      e = { { {the_Edges_of G2, the_Edges_of G3}, w },
        {{the_Edges_of G2, the_Edges_of G3}} } by A23, TARSKI:def 5;
      then {{the_Edges_of G2, the_Edges_of G3}} in e by TARSKI:def 2;
      hence contradiction by A22, A24, A25, XREGULAR:8;
    end;
    :: show supergraph property
    set G4 =
      createGraph(the_Vertices_of G3 \/ {v}, the_Edges_of G3 \/ E, s, t);
    now
      thus the_Vertices_of G3 c= the_Vertices_of G4 by XBOOLE_1:7;
      thus the_Edges_of G3 c= the_Edges_of G4 by XBOOLE_1:7;
      let e be set;
      assume A26: e in the_Edges_of G3;
      then e in the_Edges_of G3 \/ E by XBOOLE_0:def 3;
      then A27: not e in E by A16, A26, XBOOLE_0:5;
      then A28: not e in dom(E --> v);
      thus (the_Source_of G3).e = s.e by A4, A27, FUNCT_4:11
        .= (the_Source_of G4).e;
      thus (the_Target_of G3).e = t.e by A28, FUNCT_4:11
        .= (the_Target_of G4).e;
    end;
    then reconsider G4 as Supergraph of G3 by GLIB_006:def 9;
    :: show addAdjVertexAll property
    the_Vertices_of G1 \ V c= the_Vertices_of G1;
    then A29: the_Vertices_of G1 \ V c= the_Vertices_of G3 &
      not v in the_Vertices_of G3 by A1, Th98;
    now
      thus the_Vertices_of G4 = the_Vertices_of G3 \/ {v};
      hereby
        let e be object;
        thus not e Joins v,v,G4
        proof
          assume A30: e Joins v,v,G4;
          then per cases by GLIB_006:72;
          suppose e Joins v,v,G3;
            then v in the_Vertices_of G3 by GLIB_000:13;
            hence contradiction by A1, Th98;
          end;
          suppose A31: not e in the_Edges_of G3;
            e in the_Edges_of G4 by A30, GLIB_000:def 13;
            then e in the_Edges_of G3 \/ E;
            then A32: e in E by A16, A31, XBOOLE_0:5;
            then consider w being Element of the_Vertices_of G1\V such that
              A33: e = [{the_Edges_of G2,the_Edges_of G3},w];
            (the_Source_of G4).e = s.e
              .= h.e by A4, A32, FUNCT_4:13
              .= [{the_Edges_of G2,the_Edges_of G3},w]`2 by A4, A32, A33
              .= w;
            then v = w by A30, GLIB_000:def 13;
            then v in the_Vertices_of G1 \ V by A3;
            hence contradiction by A1;
          end;
        end;
        let v1 be object;
        hereby
          assume A34: not v1 in the_Vertices_of G1 \ V;
          assume A35: e Joins v1,v,G4;
          then per cases by GLIB_006:72;
          suppose e Joins v1,v,G3;
            then v in the_Vertices_of G3 by GLIB_000:13;
            hence contradiction by A1, Th98;
          end;
          suppose A36: not e in the_Edges_of G3;
            e in the_Edges_of G4 by A35, GLIB_000:def 13;
            then e in the_Edges_of G3 \/ E;
            then A37: e in E by A36, XBOOLE_0:def 3;
            then consider w being Element of the_Vertices_of G1\V such that
              A38: e = [{the_Edges_of G2,the_Edges_of G3},w];
            (the_Source_of G4).e = s.e
              .= h.e by A4, A37, FUNCT_4:13
              .= [{the_Edges_of G2,the_Edges_of G3},w]`2 by A4, A37, A38
              .= w;
            then per cases by A35, GLIB_000:def 13;
            suppose w = v;
              then v in the_Vertices_of G1 \ V by A3;
              hence contradiction by A1;
            end;
            suppose w = v1;
              hence contradiction by A3, A34;
            end;
          end;
        end;
        let v2 be object;
        assume A39: v1 <> v & v2 <> v & e DJoins v1,v2,G4;
        e in the_Edges_of G3
        proof
          assume A40: not e in the_Edges_of G3;
          e in the_Edges_of G4 by A39, GLIB_000:def 14;
          then e in the_Edges_of G3 \/ E;
          then A41: e in E by A40, XBOOLE_0:def 3;
          then A42: e in dom(E --> v);
          (the_Target_of G4).e = t.e
            .= (E --> v).e by A42, FUNCT_4:13
            .= v by A41, FUNCOP_1:7;
          hence contradiction by A39, GLIB_000:def 14;
        end;
        hence e DJoins v1,v2,G3 by A39, GLIB_006:71;
      end;
      take E;
      now
        let x1,x2 be object;
        assume A43: x1 in dom h & x2 in dom h & h.x1 = h.x2;
        then consider w1 being Element of the_Vertices_of G1\V such that
          A44: x1 = [{the_Edges_of G2,the_Edges_of G3},w1] by A4;
        consider w2 being Element of the_Vertices_of G1\V such that
          A45: x2 = [{the_Edges_of G2,the_Edges_of G3},w2] by A4, A43;
        w1 = [{the_Edges_of G2,the_Edges_of G3},w1]`2
          .= h.x1 by A4, A43, A44
          .= [{the_Edges_of G2,the_Edges_of G3},w2]`2 by A4, A43, A45
          .= w2;
        hence x1 = x2 by A44, A45;
      end;
      then A46: h is one-to-one by FUNCT_1:def 4;
      thus card(the_Vertices_of G1 \ V)
         = card(the_Vertices_of G3 \ V) by Th98
        .= card E by A4, A9, A46, CARD_1:70;
      thus E misses the_Edges_of G3 by A16;
      thus the_Edges_of G4 = the_Edges_of G3 \/ E;
      let v1 be object;
      assume A47: v1 in the_Vertices_of G1 \ V;
      set e1 = [{the_Edges_of G2,the_Edges_of G3},v1];
      take e1;
      thus A48: e1 in E by A47;
      then e1 in the_Edges_of G3 \/ E by XBOOLE_0:def 3;
      then A49: e1 in the_Edges_of G4;
      A50: e1 in dom(E --> v) by A48;
      A51: (the_Source_of G4).e1 = s.e1
        .= h.e1 by A4, A48, FUNCT_4:13
        .= e1`2 by A4, A48
        .= v1;
      (the_Target_of G4).e1 = t.e1
        .= (E --> v).e1 by A50, FUNCT_4:13
        .= v by A48, FUNCOP_1:7;
      hence e1 Joins v1,v,G4 by A49, A51, GLIB_000:def 13;
      let e2 be object;
      assume A52: e2 Joins v1,v,G4;
      not e2 Joins v1,v,G3
      proof
        assume e2 Joins v1,v,G3;
        then v in the_Vertices_of G3 by GLIB_000:13;
        hence contradiction by A1, Th98;
      end;
      then A53: not e2 in the_Edges_of G3 by A52, GLIB_006:72;
      e2 in the_Edges_of G4 by A52, GLIB_000:def 13;
      then e2 in the_Edges_of G3 \/ E;
      then A54: e2 in E by A53, XBOOLE_0:def 3;
      then consider w being Element of the_Vertices_of G1\V such that
        A55: e2 = [{the_Edges_of G2,the_Edges_of G3},w];
      (the_Source_of G4).e2 = s.e2
        .= h.e2 by A4, A54, FUNCT_4:13
        .= [{the_Edges_of G2,the_Edges_of G3},w]`2 by A4, A54, A55
        .= w;
      then A56: v = w or v1 = w by A52, GLIB_000:def 13;
      v1 = w
      proof
        assume v1 <> w;
        then v in the_Vertices_of G1\V by A3, A56;
        hence contradiction by A1;
      end;
      hence e1 = e2 by A55;
    end;
    then reconsider G4 as addAdjVertexAll of G3, v, the_Vertices_of G1 \ V
      by A29, GLIB_007:def 4;
    take G4;
    :: show GraphComplement property
    now
      thus the_Vertices_of G4 = the_Vertices_of G3 \/ {v}
        .= the_Vertices_of G1 \/ {v} by Th98
        .= the_Vertices_of G2 by A1, GLIB_007:def 4;
      the_Edges_of G3 \/ E misses the_Edges_of G2 by A1, A21, XBOOLE_1:70;
      hence the_Edges_of G4 misses the_Edges_of G2;
      let u,w be Vertex of G2;
      assume A57: u <> w;
      hereby
        given e1 being object such that
          A58: e1 Joins u,w,G2;
        per cases by A58, GLIB_006:72;
        suppose A59: e1 Joins u,w,G1;
          then u is Vertex of G1 & w is Vertex of G1 by GLIB_000:13;
          then A60: not ex e2 being object st e2 Joins u,w,G3
            by A57, A59, Th98;
          u <> v & w <> v by A1, A59, GLIB_000:13;
          hence not ex e2 being object st e2 Joins u,w,G4
            by A29, A60, GLIB_007:49;
        end;
        suppose A61: not e1 in the_Edges_of G1;
          A62: the_Edges_of G2 = the_Edges_of G1 \/ G2.edgesBetween(V,{v})
            by A1, GLIB_007:59;
          e1 in the_Edges_of G2 by A58, GLIB_000:def 13;
          then e1 in G2.edgesBetween(V,{v}) by A61, A62, XBOOLE_0:def 3;
          then e1 SJoins V,{v},G2 by GLIB_000:def 30;
          then (the_Source_of G2).e1 in V &
            (the_Target_of G2).e1 in {v} or
            (the_Source_of G2).e1 in {v} &
            (the_Target_of G2).e1 in V by GLIB_000:def 15;
          then A63: u in V & w in {v} or u in {v} & w in V
            by A58, GLIB_000:def 13;
          then A64: u = v & w in V or u in V & w = v by TARSKI:def 1;
          thus not ex e2 being object st e2 Joins u,w,G4
          proof
            given e2 being object such that
              A65: e2 Joins u,w,G4;
            A66: not e2 in the_Edges_of G3
            proof
              assume e2 in the_Edges_of G3;
              then e2 Joins u,w,G3 by A65, GLIB_006:72;
              then v in the_Vertices_of G3 by A64, GLIB_000:13;
              hence contradiction by A1, Th98;
            end;
            e2 in the_Edges_of G4 by A65, GLIB_000:def 13;
            then e2 in the_Edges_of G3 \/ E;
            then A67: e2 in E by A66, XBOOLE_0:def 3;
            then consider x being Element of the_Vertices_of G1\V such that
              A68: e2 = [{the_Edges_of G2, the_Edges_of G3},x];
            (the_Source_of G4).e2 = s.e2
              .= h.e2 by A4, A67, FUNCT_4:13
              .= [{the_Edges_of G2, the_Edges_of G3},x]`2 by A4, A67, A68
              .= x;
            then (the_Source_of G4).e2 in the_Vertices_of G1 &
              not (the_Source_of G4).e2 in V by A3, XBOOLE_0:def 5;
            then per cases by A65, GLIB_000:def 13;
            suppose u in the_Vertices_of G1 & not u in V;
              hence contradiction by A1, A63, TARSKI:def 1;
            end;
            suppose w in the_Vertices_of G1 & not w in V;
              hence contradiction by A1, A63, TARSKI:def 1;
            end;
          end;
        end;
      end;
      assume A69: not ex e2 being object st e2 Joins u,w,G4;
      A70: not ex e2 being object st e2 Joins u,w,G3 by A69, GLIB_006:70;
      per cases;
      suppose A71: u = v;
        A72: not w in {v} by A57, A71, TARSKI:def 1;
        w in V
        proof
          assume A73: not w in V;
          the_Vertices_of G2 = the_Vertices_of G1 \/ {v}
            by A1, GLIB_007:def 4;
          then w in the_Vertices_of G1 by A72, XBOOLE_0:def 3;
          then A74: w in the_Vertices_of G1\V by A73, XBOOLE_0:def 5;
          set e1 = [{the_Edges_of G2,the_Edges_of G3},w];
          A75: e1 in E by A74;
          then A76: e1 in dom(E --> v);
          e1 in the_Edges_of G3 \/ E by A75, XBOOLE_0:def 3;
          then A77: e1 in the_Edges_of G4;
          A78: (the_Source_of G4).e1 = s.e1
            .= h.e1 by A4, A75, FUNCT_4:13
            .= [{the_Edges_of G2,the_Edges_of G3},w]`2 by A4, A75
            .= w;
          (the_Target_of G4).e1 = t.e1
            .= (E --> v).e1 by A76, FUNCT_4:13
            .= v by A75, FUNCOP_1:7;
          then e1 Joins v,w,G4 by A77, A78, GLIB_000:def 13;
          hence contradiction by A69, A71;
        end;
        then consider e1 being object such that
          A79: e1 in E0 & e1 Joins w,v,G2 and
          for e2 being object st e2 Joins w,v,G2 holds e1 = e2 by A2;
        take e1;
        thus e1 Joins u,w,G2 by A71, A79, GLIB_000:14;
      end;
      suppose A80: w = v;
        A81: not u in {v} by A57, A80, TARSKI:def 1;
        u in V
        proof
          assume A82: not u in V;
          the_Vertices_of G2 = the_Vertices_of G1 \/ {v}
            by A1, GLIB_007:def 4;
          then u in the_Vertices_of G1 by A81, XBOOLE_0:def 3;
          then A83: u in the_Vertices_of G1\V by A82, XBOOLE_0:def 5;
          set e1 = [{the_Edges_of G2,the_Edges_of G3},u];
          A84: e1 in E by A83;
          then A85: e1 in dom(E --> v);
          e1 in the_Edges_of G3 \/ E by A84, XBOOLE_0:def 3;
          then A86: e1 in the_Edges_of G4;
          A87: (the_Source_of G4).e1 = s.e1
            .= h.e1 by A4, A84, FUNCT_4:13
            .= [{the_Edges_of G2,the_Edges_of G3},u]`2 by A4, A84
            .= u;
          (the_Target_of G4).e1 = t.e1
            .= (E --> v).e1 by A85, FUNCT_4:13
            .= v by A84, FUNCOP_1:7;
          then e1 Joins u,v,G4 by A86, A87, GLIB_000:def 13;
          hence contradiction by A69, A80;
        end;
        then consider e1 being object such that
          A88: e1 in E0 & e1 Joins u,v,G2 and
          for e2 being object st e2 Joins u,v,G2 holds e1 = e2 by A2;
        take e1;
        thus e1 Joins u,w,G2 by A80, A88;
      end;
      suppose u <> v & w <> v;
        then A89: not u in {v} & not w in {v} by TARSKI:def 1;
        the_Vertices_of G2 = the_Vertices_of G1 \/ {v}
          by A1, GLIB_007:def 4;
        then u is Vertex of G1 & w is Vertex of G1 by A89, XBOOLE_0:def 3;
        then consider e1 being object such that
          A90: e1 Joins u,w,G1 by A57, A70, Th98;
        take e1;
        thus e1 Joins u,w,G2 by A90, GLIB_006:70;
      end;
    end;
    hence thesis by Th98;
  end;
  suppose A91: the_Vertices_of G1 \ V = {};
    take G4 = the addAdjVertexAll of G3,v,the_Vertices_of G1 \ V;
    A92: G4 is addVertex of G3, v by A91, GLIB_007:55;
    now
      thus the_Vertices_of G4
         = the_Vertices_of G3 \/ {v} by A92, GLIB_006:def 10
        .= the_Vertices_of G1 \/ {v} by Th98
        .= the_Vertices_of G2 by A1, GLIB_007:def 4;
      the_Edges_of G3 = the_Edges_of G4 by A92, GLIB_006:def 10;
      hence the_Edges_of G4 misses the_Edges_of G2 by A1;
      let u,w be Vertex of G2;
      assume A93: u <> w;
      hereby
        given e1 being object such that
          A94: e1 Joins u,w,G2;
        per cases by A94, GLIB_006:72;
        suppose A95: e1 Joins u,w,G1;
          then u is Vertex of G1 & w is Vertex of G1 by GLIB_000:13;
          then not ex e2 being object st e2 Joins u,w,G3 by A93, A95, Th98;
          hence not ex e2 being object st e2 Joins u,w,G4 by A92, GLIB_006:87;
        end;
        suppose A96: not e1 in the_Edges_of G1;
          A97: the_Edges_of G2 = the_Edges_of G1 \/ G2.edgesBetween(V,{v})
            by A1, GLIB_007:59;
          e1 in the_Edges_of G2 by A94, GLIB_000:def 13;
          then e1 in G2.edgesBetween(V,{v}) by A96, A97, XBOOLE_0:def 3;
          then e1 SJoins V,{v},G2 by GLIB_000:def 30;
          then (the_Source_of G2).e1 in V &
            (the_Target_of G2).e1 in {v} or
            (the_Source_of G2).e1 in {v} &
            (the_Target_of G2).e1 in V by GLIB_000:def 15;
          then u in V & w in {v} or u in {v} & w in V
            by A94, GLIB_000:def 13;
          then u in V & w = v or u = v & w in V by TARSKI:def 1;
          then not u in the_Vertices_of G3 or not w in the_Vertices_of G3
            by A1, Th98;
          then not ex e2 being object st e2 Joins u,w,G3 by GLIB_000:13;
          hence not ex e2 being object st e2 Joins u,w,G4 by A92, GLIB_006:87;
        end;
      end;
      assume not ex e2 being object st e2 Joins u,w,G4;
      then A98: not ex e2 being object st e2 Joins u,w,G3
        by A92, GLIB_006:87;
      A99: the_Vertices_of G2 = the_Vertices_of G1\/{v} by A1, GLIB_007:def 4;
      the_Vertices_of G1 c= V by A91, XBOOLE_1:37;
      then A100: V = the_Vertices_of G1 by XBOOLE_0:def 10;
      per cases;
      suppose A101: u = v;
        then not w in {v} by A93, TARSKI:def 1;
        then w in the_Vertices_of G1 by A99, XBOOLE_0:def 3;
        then consider e1 being object such that
          A102: e1 in E0 & e1 Joins w,v,G2 and
          for e2 being object st e2 Joins w,v,G2 holds e1 = e2
          by A2, A100;
        take e1;
        thus e1 Joins u,w,G2 by A101, A102, GLIB_000:14;
      end;
      suppose A103: w = v;
        then not u in {v} by A93, TARSKI:def 1;
        then u in the_Vertices_of G1 by A99, XBOOLE_0:def 3;
        then consider e1 being object such that
          A104: e1 in E0 & e1 Joins u,v,G2 and
          for e2 being object st e2 Joins u,v,G2 holds e1 = e2
          by A2, A100;
        take e1;
        thus e1 Joins u,w,G2 by A103, A104;
      end;
      suppose u <> v & w <> v;
        then not u in {v} & not w in {v} by TARSKI:def 1;
        then u is Vertex of G1 & w is Vertex of G1 by A99, XBOOLE_0:def 3;
        then consider e1 being object such that
          A105: e1 Joins u,w,G1 by A93, A98, Th98;
        take e1;
        thus e1 Joins u,w,G2 by A105, GLIB_006:70;
      end;
    end;
    hence thesis by Th98;
  end;
end;

theorem
  for G1 being _Graph, v being object, G2 being addVertex of G1,v
  for G3 being GraphComplement of G1 st not v in the_Vertices_of G1
  ex G4 being addAdjVertexAll of G3,v st G4 is GraphComplement of G2
proof
  let G1 be _Graph, v be object, G2 be addVertex of G1, v;
  let G3 be GraphComplement of G1;
  assume A1: not v in the_Vertices_of G1;
  the_Edges_of G1 misses the_Edges_of G3 by Th98;
  then A2: the_Edges_of G2 misses the_Edges_of G3 by GLIB_006:def 10;
  {} is Subset of the_Vertices_of G1 &
    G2 is addAdjVertexAll of G1,v,{} by XBOOLE_1:2, GLIBPRE0:53;
  then consider G4 being addAdjVertexAll of G3,v,the_Vertices_of G1 \ {}
    such that A3: G4 is GraphComplement of G2 by A1, A2, Th105;
  reconsider G4 as addAdjVertexAll of G3,v by Th98;
  take G4;
  thus thesis by A3;
end;

theorem
  for G1 being _Graph, v being object, G2 being addAdjVertexAll of G1,v
  for G3 being GraphComplement of G1, G4 being addVertex of G3,v
  st not v in the_Vertices_of G1 & the_Edges_of G2 misses the_Edges_of G3
  holds G4 is GraphComplement of G2
proof
  let G1 be _Graph, v be object, G2 be addAdjVertexAll of G1, v;
  let G3 be GraphComplement of G1, G4 be addVertex of G3, v;
  assume A1: not v in the_Vertices_of G1 &
    the_Edges_of G2 misses the_Edges_of G3;
  the_Vertices_of G1 c= the_Vertices_of G1;
  then consider G9 being
      addAdjVertexAll of G3,v,the_Vertices_of G1 \ the_Vertices_of G1 such that
    A2: G9 is GraphComplement of G2 by A1, Th105;
  the_Vertices_of G1 \ the_Vertices_of G1 = {} by XBOOLE_1:37;
  then G9 is addVertex of G3,v by GLIB_007:55;
  then G4 == G9 by GLIB_006:77;
  hence thesis by A2, Th97;
end;

theorem Th108:
  for G1 being _Graph, V being non empty Subset of the_Vertices_of G1
  for G2 being inducedSubgraph of G1, V
  for G3 being GraphComplement of G1, G4 being inducedSubgraph of G3, V
  holds G4 is GraphComplement of G2
proof
  let G1 be _Graph, V be non empty Subset of the_Vertices_of G1;
  let G2 be inducedSubgraph of G1, V;
  let G3 be GraphComplement of G1, G4 be inducedSubgraph of G3, V;
  A1: V is non empty Subset of the_Vertices_of G3 by Th98;
  then A2: the_Vertices_of G4 = V by GLIB_000:def 37
    .= the_Vertices_of G2 by GLIB_000:def 37;
  A3: the_Edges_of G4 misses the_Edges_of G2
  proof
    assume the_Edges_of G4 meets the_Edges_of G2;
    then consider e being object such that
      A4: e in the_Edges_of G4 & e in the_Edges_of G2 by XBOOLE_0:3;
    A5: e in the_Edges_of G1 \/ the_Edges_of G3 by A4, XBOOLE_0:def 3;
    the_Edges_of G3 misses the_Edges_of G1 by Th98;
    hence contradiction by A4, A5, XBOOLE_0:5;
  end;
  now
    let v,w be Vertex of G2;
    assume A6: v <> w;
    hereby
      given e2 being object such that
        A7: e2 Joins v,w,G2;
      A8: e2 Joins v,w,G1 by A7, GLIB_000:72;
      given e4 being object such that
        A9: e4 Joins v,w,G4;
      e4 Joins v,w,G3 by A9, GLIB_000:72;
      hence contradiction by A8, Th100;
    end;
    assume A10: not ex e4 being object st e4 Joins v,w,G4;
    ex e1 being object st e1 Joins v,w,G1
    proof
      assume A11: not ex e1 being object st e1 Joins v,w,G1;
      the_Vertices_of G2 c= the_Vertices_of G1;
      then v is Vertex of G1 & w is Vertex of G1 by TARSKI:def 3;
      then consider e3 being object such that
        A12: e3 Joins v,w,G3 by A6, A11, Th98;
      the_Vertices_of G2 = V by GLIB_000:def 37;
      then e3 in G3.edgesBetween(V) by A12, GLIB_000:32;
      then e3 in the_Edges_of G4 & e3 is set by A1, GLIB_000:def 37;
      then e3 Joins v,w,G4 by A12, GLIB_000:73;
      hence contradiction by A10;
    end;
    then consider e1 being object such that
      A13: e1 Joins v,w,G1;
    take e1;
    the_Vertices_of G2 = V by GLIB_000:def 37;
    then e1 in G1.edgesBetween(V) by A13, GLIB_000:32;
    then e1 in the_Edges_of G2 & e1 is set by GLIB_000:def 37;
    hence e1 Joins v,w,G2 by A13, GLIB_000:73;
  end;
  hence thesis by A2, A3, Th98;
end;

theorem
  for G1 being _Graph, V being proper Subset of the_Vertices_of G1
  for G2 being removeVertices of G1, V
  for G3 being GraphComplement of G1, G4 being removeVertices of G3, V
  holds G4 is GraphComplement of G2
proof
  let G1 be _Graph, V be proper Subset of the_Vertices_of G1;
  let G2 be removeVertices of G1, V;
  let G3 be GraphComplement of G1, G4 be removeVertices of G3, V;
  the_Vertices_of G1 \ V is non empty Subset of the_Vertices_of G1 &
    the_Vertices_of G1 \V = the_Vertices_of G3 \ V
    by Th98, XBOOLE_1:105, GLIBPRE0:6;
  hence thesis by Th108;
end;

:: involutiveness of graph complement (C case)
theorem Th110:
  for G1 being simple _Graph, G2 being GraphComplement of G1
  holds G1 is GraphComplement of G2
proof
  let G1 be simple _Graph, G2 be GraphComplement of G1;
  A1: the_Vertices_of G1 = the_Vertices_of G2 &
    the_Edges_of G1 misses the_Edges_of G2 by Th98;
  now
    let v,w be Vertex of G2;
    assume A2: v <> w;
    v is Vertex of G1 & w is Vertex of G1 by Th98;
    hence (ex e2 being object st e2 Joins v,w,G2) iff
      (not ex e1 being object st e1 Joins v,w,G1) by A2, Th98;
  end;
  hence thesis by A1, Th98;
end;

theorem Th111:
  for G1 being _Graph, G2 being GraphComplement of G1
  holds G1.order() = G2.order() by Th98;

theorem Th112:
  for G1 being _Graph, G2 being GraphComplement of G1 holds
    (G1 is _trivial iff G2 is _trivial)
proof
  let G1 be _Graph, G2 be GraphComplement of G1;
  hereby
    assume G1 is _trivial;
    then 1 = G1.order() by GLIB_000:26
      .= G2.order() by Th111;
    hence G2 is _trivial by GLIB_000:26;
  end;
  hereby
    assume G2 is _trivial;
    then 1 = G2.order() by GLIB_000:26
      .= G1.order() by Th111;
    hence G1 is _trivial by GLIB_000:26;
  end;
end;

registration
  let G be _trivial _Graph;
  cluster -> _trivial for GraphComplement of G;
  coherence by Th112;
end;

registration
  let G be non _trivial _Graph;
  cluster -> non _trivial for GraphComplement of G;
  coherence by Th112;
end;

theorem Th113:
  for G1 being _Graph, G2 being GraphComplement of G1 holds
    (G1 is complete iff G2 is edgeless) &
    (the_Edges_of G1 = G1.loops() iff G2 is complete)
proof
  let G1 be _Graph, G2 be GraphComplement of G1;
  hereby
    assume A1: G1 is complete;
    now
      let v2,w2 be Vertex of G2;
      assume A2: v2 <> w2;
      reconsider v1=v2, w1=w2 as Vertex of G1 by Th99;
      v1,w1 are_adjacent by A1, A2, CHORD:def 6;
      hence not v2,w2 are_adjacent by A2, Th99;
    end;
    hence G2 is edgeless by GLIBPRE0:62;
  end;
  hereby
    assume A3: G2 is edgeless;
    now
      let v1,w1 be Vertex of G1;
      assume A4: v1 <> w1;
      reconsider v2=v1, w2=w1 as Vertex of G2 by Th99;
      not v2,w2 are_adjacent by A3, A4, GLIBPRE0:62;
      hence v1,w1 are_adjacent by A4, Th99;
    end;
    hence G1 is complete by CHORD:def 6;
  end;
  hereby
    assume A5: the_Edges_of G1 = G1.loops();
    now
      let v2,w2 be Vertex of G2;
      assume A6: v2 <> w2;
      reconsider v1=v2, w1=w2 as Vertex of G1 by Th98;
      not ex e1 being object st e1 Joins v1,w1,G1
      proof
        given e1 being object such that
          A7: e1 Joins v1,w1,G1;
        e1 in G1.loops() by A5, A7, GLIB_000:def 13;
        then consider v9 being object such that
          A8: e1 Joins v9,v9,G1 by GLIB_009:def 2;
        v1 = v9 & w1 = v9 by A7, A8, GLIB_000:15;
        hence contradiction by A6;
      end;
      then ex e2 being object st e2 Joins v1,w1,G2 by A6, Th98;
      hence v2,w2 are_adjacent by CHORD:def 3;
    end;
    hence G2 is complete by CHORD:def 6;
  end;
  hereby
    assume A9: G2 is complete;
    now
      let e be object;
      assume A10: e in the_Edges_of G1;
      then reconsider v1=(the_Source_of G1).e, w1=(the_Target_of G1).e
        as Vertex of G1 by FUNCT_2:5;
      A11: e Joins v1,w1,G1 by A10, GLIB_000:def 13;
      then A12: v1,w1 are_adjacent by CHORD:def 3;
      reconsider v2=v1, w2=w1 as Vertex of G2 by Th99;
      assume not e in G1.loops();
      then A13: v1 <> w1 by A11, GLIB_009:def 2;
      then not v2,w2 are_adjacent by A12, Th99;
      hence contradiction by A9, A13, CHORD:def 6;
    end;
    then the_Edges_of G1 c= G1.loops() by TARSKI:def 3;
    hence the_Edges_of G1 = G1.loops() by XBOOLE_0:def 10;
  end;
  thus thesis;
end;

registration
  let G be complete _Graph;
  cluster -> edgeless for GraphComplement of G;
  coherence by Th113;
end;

registration
  let G be non complete _Graph;
  cluster -> non edgeless for GraphComplement of G;
  coherence by Th113;
end;

registration
  let G be edgeless _Graph;
  cluster -> complete for GraphComplement of G;
  coherence
  proof
    the_Edges_of G = {} & G.loops() = {};
    hence thesis by Th113;
  end;
end;

registration
  let G be non connected _Graph;
  cluster -> connected for GraphComplement of G;
  coherence
  proof
    let G2 be GraphComplement of G;
    consider G9 being LGraphComplement of G such that
      A1: G2 is removeLoops of G9 by Def9;
    thus thesis by A1;
  end;
end;

theorem
  for G1 being non _trivial _Graph, G2 being GraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 holds v1 is isolated implies v2 is non isolated
proof
  let G1 be non _trivial _Graph, G2 be GraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2;
  assume A2: v1 is isolated;
  set v9 = the Element of the_Vertices_of G1 \ {v1};
  the_Vertices_of G1 \ {v1} <> {} by GLIB_000:20;
  then A3: v9 in the_Vertices_of G1 \ {v1};
  then reconsider v9 as Vertex of G1;
  A4: v9 <> v1 by A3, ZFMISC_1:56;
  not ex e being object st e Joins v1,v9,G1 by A2, GLIBPRE0:21;
  then ex e being object st e Joins v1,v9,G2 by A4, Th98;
  hence v2 is non isolated by A1, GLIBPRE0:21;
end;

theorem Th115:
  for G1 being _Graph, G2 being GraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & G1.order() = 2 holds
    (v1 is endvertex implies v2 is isolated) &
    (v1 is isolated implies v2 is endvertex)
proof
  let G1 be _Graph, G2 be GraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & G1.order() = 2;
  then G2.order() = 2 by Th111;
  then consider u1, u2 being object such that
    A2: u1<>u2 & the_Vertices_of G2 = {u1,u2} by CARD_2:60;
  A3: the_Vertices_of G1 = the_Vertices_of G2 by Th98;
  then reconsider u1,u2 as Vertex of G1 by A2, TARSKI:def 2;
  hereby
    assume v1 is endvertex;
    then consider e1 being object such that
      A4: v1.edgesInOut() = {e1} & not e1 Joins v1,v1,G1 by GLIB_000:def 51;
    e1 in v1.edgesInOut() by A4, TARSKI:def 1;
    then consider v9 being Vertex of G1 such that
      A5: e1 Joins v1,v9,G1 by GLIB_000:64;
    A6: v1 <> v9 by A4, A5;
    v9 in the_Vertices_of G1;
    then v9 in the_Vertices_of G2 by Th98;
    then A7: v9 = u1 or v9 = u2 by A2, TARSKI:def 2;
    assume v2 is non isolated;
    then v2.edgesInOut() <> {} by GLIB_000:def 49;
    then consider e2 being object such that
      A8: e2 in v2.edgesInOut() by XBOOLE_0:def 1;
    consider u being Vertex of G2 such that
      A9: e2 Joins v2,u,G2 by A8, GLIB_000:64;
    per cases by A2, TARSKI:def 2;
    suppose v2=u1 & u=u1;
      hence contradiction by A9, GLIB_000:18;
    end;
    suppose v2=u1 & u=u2;
      hence contradiction by A1, A5, A6, A7, A9, Th100;
    end;
    suppose v2=u2 & u=u1;
      hence contradiction by A1, A5, A6, A7, A9, Th100;
    end;
    suppose v2=u2 & u=u2;
      hence contradiction by A9, GLIB_000:18;
    end;
  end;
  assume A10: v1 is isolated;
  per cases by A2, A3, TARSKI:def 2;
  suppose A11: v1 = u1;
    not ex e1 being object st e1 Joins v1,u2,G1 by A10, GLIBPRE0:21;
    then consider e2 being object such that
      A12: e2 Joins v1,u2,G2 by A2, A11, Th98;
    for e being object holds e in v2.edgesInOut() iff e = e2
    proof
      let e be object;
      hereby
        assume e in v2.edgesInOut();
        then consider v9 being Vertex of G2 such that
          A13: e Joins v2,v9,G2 by GLIB_000:64;
        v9 = u2
        proof
          assume v9 <> u2;
          then v9 = u1 by A2, TARSKI:def 2;
          hence contradiction by A1, A11, A13, GLIB_000:18;
        end;
        hence e = e2 by A1, A12, A13, GLIB_000:def 20;
      end;
      reconsider w = u2 as Vertex of G2 by A2, TARSKI:def 2;
      assume e = e2;
      then e Joins v2,w,G2 & e is set by A1, A12, TARSKI:1;
      hence e in v2.edgesInOut() by GLIB_000:64;
    end;
    then v2.edgesInOut() = {e2} by TARSKI:def 1;
    hence thesis by GLIB_000:18, GLIB_000:def 51;
  end;
  suppose A14: v1 = u2;
    not ex e1 being object st e1 Joins v1,u1,G1 by A10, GLIBPRE0:21;
    then consider e2 being object such that
      A15: e2 Joins v1,u1,G2 by A2, A14, Th98;
    for e being object holds e in v2.edgesInOut() iff e = e2
    proof
      let e be object;
      hereby
        assume e in v2.edgesInOut();
        then consider v9 being Vertex of G2 such that
          A16: e Joins v2,v9,G2 by GLIB_000:64;
        v9 = u1
        proof
          assume v9 <> u1;
          then v9 = u2 by A2, TARSKI:def 2;
          hence contradiction by A1, A14, A16, GLIB_000:18;
        end;
        hence e = e2 by A1, A15, A16, GLIB_000:def 20;
      end;
      reconsider w = u1 as Vertex of G2 by A2, TARSKI:def 2;
      assume e = e2;
      then e Joins v2,w,G2 & e is set by A1, A15, TARSKI:1;
      hence e in v2.edgesInOut() by GLIB_000:64;
    end;
    then v2.edgesInOut() = {e2} by TARSKI:def 1;
    hence thesis by GLIB_000:18, GLIB_000:def 51;
  end;
end;

theorem
  for G1 being simple _Graph, G2 being GraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & G1.order() = 2 holds
    (v1 is endvertex iff v2 is isolated) &
    (v1 is isolated iff v2 is endvertex)
proof
  let G1 be simple _Graph, G2 be GraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & G1.order() = 2;
  then G1 is GraphComplement of G2 & G2.order() = 2 by Th110, Th111;
  hence thesis by A1, Th115;
end;

:: in case G.order() = 3 we have the endvertices of P3 with complement K2+K1
theorem
  for G1 being _Graph, G2 being GraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & 4 c= G1.order()
  holds v1 is endvertex implies v2 is non endvertex
proof
  let G1 be _Graph, G2 be GraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & 4 c= G1.order();
  assume v1 is endvertex;
  then consider x,y,z being Vertex of G1 such that
    A2: v1 <> x & v1 <> y & v1 <> z & x <> y & x <> z & y <> z and
    A3: v1,x are_adjacent & not v1,y are_adjacent & not v1,z are_adjacent
    by A1, GLIBPRE0:98;
  reconsider u = y, w = z as Vertex of G2 by Th99;
  v2,u are_adjacent & v2,w are_adjacent by A1, A2, A3, Th99;
  hence v2 is non endvertex by A2, GLIBPRE0:96;
end;

theorem Th118:
  for G1 being _Graph, G2 being GraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2 st v1 = v2
  holds v2.allNeighbors() = the_Vertices_of G2 \ (v1.allNeighbors() \/ {v2})
proof
  let G1 be _Graph, G2 be GraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2;
  consider G9 being LGraphComplement of G1 such that
    A2: G2 is removeLoops of G9 by Def9;
  reconsider v9 = v1 as Vertex of G9 by Def7;
  thus v2.allNeighbors() = v9.allNeighbors() \ {v2} by A1, A2, GLIBPRE0:65
    .= (the_Vertices_of G9 \ v1.allNeighbors()) \ {v2} by Th77
    .= the_Vertices_of G9 \ (v1.allNeighbors() \/ {v2}) by XBOOLE_1:41
    .= the_Vertices_of G2 \ (v1.allNeighbors() \/ {v2}) by A2, GLIB_000:53;
end;

theorem
  for G1 being _Graph, G2 being GraphComplement of G1
  for v1 being Vertex of G1, v2 being Vertex of G2
  st v1 = v2 & v1 is isolated
  holds v2.allNeighbors() = the_Vertices_of G2 \ {v2}
proof
  let G1 be _Graph, G2 be GraphComplement of G1;
  let v1 be Vertex of G1, v2 be Vertex of G2;
  assume A1: v1 = v2 & v1 is isolated;
  then v1.allNeighbors() = {} by GLIB_008:7;
  hence v2.allNeighbors() = the_Vertices_of G2 \ ({} \/ {v2}) by A1, Th118
    .= the_Vertices_of G2 \ {v2};
end;

begin :: Self-complementary Graphs

definition
  let G be _Graph;
  attr G is self-DLcomplementary means
  for H being DLGraphComplement of G holds H is G-Disomorphic;
  attr G is self-Lcomplementary means
  for H being LGraphComplement of G holds H is G-isomorphic;
  attr G is self-Dcomplementary means
  for H being DGraphComplement of G holds H is G-Disomorphic;
  attr G is self-complementary means
  for H being GraphComplement of G holds H is G-isomorphic;
end;

theorem
  for G being _Graph holds G is self-DLcomplementary iff
    ex H being DLGraphComplement of G st H is G-Disomorphic
proof
  let G be _Graph;
  hereby
    assume A1: G is self-DLcomplementary;
    reconsider H = the DLGraphComplement of G as DLGraphComplement of G;
    take H;
    thus H is G-Disomorphic by A1;
  end;
  given H0 being DLGraphComplement of G such that
    A2: H0 is G-Disomorphic;
  let H be DLGraphComplement of G;
  H is H0-Disomorphic by Th50;
  hence H is G-Disomorphic by A2;
end;

theorem
  for G being _Graph holds G is self-Lcomplementary iff
    ex H being LGraphComplement of G st H is G-isomorphic
proof
  let G be _Graph;
  hereby
    assume A1: G is self-Lcomplementary;
    reconsider H = the LGraphComplement of G as LGraphComplement of G;
    take H;
    thus H is G-isomorphic by A1;
  end;
  given H0 being LGraphComplement of G such that
    A2: H0 is G-isomorphic;
  let H be LGraphComplement of G;
  H is H0-isomorphic by Th68;
  hence H is G-isomorphic by A2;
end;

theorem
  for G being _Graph holds G is self-Dcomplementary iff
    ex H being DGraphComplement of G st H is G-Disomorphic
proof
  let G be _Graph;
  hereby
    assume A1: G is self-Dcomplementary;
    reconsider H = the DGraphComplement of G as DGraphComplement of G;
    take H;
    thus H is G-Disomorphic by A1;
  end;
  given H0 being DGraphComplement of G such that
    A2: H0 is G-Disomorphic;
  let H be DGraphComplement of G;
  H is H0-Disomorphic by Th85;
  hence H is G-Disomorphic by A2;
end;

theorem
  for G being _Graph holds G is self-complementary iff
    ex H being GraphComplement of G st H is G-isomorphic
proof
  let G be _Graph;
  hereby
    assume A1: G is self-complementary;
    reconsider H = the GraphComplement of G as GraphComplement of G;
    take H;
    thus H is G-isomorphic by A1;
  end;
  given H0 being GraphComplement of G such that
    A2: H0 is G-isomorphic;
  let H be GraphComplement of G;
  H is H0-isomorphic by Th104;
  hence H is G-isomorphic by A2;
end;

registration
  cluster self-DLcomplementary -> non loopless non loopfull non-Dmulti
    connected for _Graph;
  coherence
  proof
    let G1 be _Graph;
    set G2 = the DLGraphComplement of G1;
    assume G1 is self-DLcomplementary;
    then G2 is G1-Disomorphic;
    then consider F being PGraphMapping of G1, G2 such that
      A1: F is Disomorphism by GLIB_010:def 24;
    thus thesis by A1, GLIB_010:89, GLIB_010:140, GLIBPRE0:81;
  end;
  cluster self-Lcomplementary -> non loopless non loopfull non-multi
    connected for _Graph;
  coherence
  proof
    let G1 be _Graph;
    set G2 = the LGraphComplement of G1;
    assume G1 is self-Lcomplementary;
    then G2 is G1-isomorphic;
    then consider F being PGraphMapping of G1, G2 such that
      A2: F is isomorphism by GLIB_010:def 23;
    thus thesis by A2, GLIB_010:89, GLIB_010:140;
  end;
  cluster self-Dcomplementary -> Dsimple connected for _Graph;
  coherence
  proof
    let G1 be _Graph;
    set G2 = the DGraphComplement of G1;
    assume G1 is self-Dcomplementary;
    then G2 is G1-Disomorphic;
    then consider F being PGraphMapping of G1, G2 such that
      A3: F is Disomorphism by GLIB_010:def 24;
    thus thesis by A3, GLIB_010:140, GLIBPRE0:81;
  end;
  cluster self-complementary -> simple connected for _Graph;
  coherence
  proof
    let G1 be _Graph;
    set G2 = the GraphComplement of G1;
    assume G1 is self-complementary;
    then G2 is G1-isomorphic;
    then consider F being PGraphMapping of G1, G2 such that
      A4: F is isomorphism by GLIB_010:def 23;
    thus thesis by A4, GLIB_010:89, GLIB_010:140;
  end;
end;

:: K2 with an added loop is self-DLcomplementary and
:: P4 with loops at the endvertices or the other two vertices
:: is self-Lcomplementary, but both won't be clustered here
:: hence no existence cluster for the attributes here
registration
  cluster _trivial edgeless -> self-Dcomplementary self-complementary
    for _Graph;
  coherence by GLIB_010:178;
  cluster self-Dcomplementary self-complementary -> _trivial edgeless
    for _Graph;
  coherence
  proof
    let G be _Graph;
    assume A1: G is self-Dcomplementary self-complementary;
    set H1 = the DGraphComplement of G, H2 = the GraphComplement of G;
    H1 is G-Disomorphic by A1;
    then consider F1 being PGraphMapping of G, H1 such that
      A2: F1 is Disomorphism by GLIB_010:def 24;
    H2 is G-isomorphic by A1;
    then consider F2 being PGraphMapping of G, H2 such that
      A3: F2 is isomorphism by GLIB_010:def 23;
    now
      let v1,v2 be Vertex of G;
      assume A4: v1 <> v2;
      assume A5: not v1,v2 are_adjacent;
      not ex e being object st e DJoins v1,v2,G
      proof
        given e being object such that
          A6: e DJoins v1,v2,G;
        e Joins v1,v2,G by A6, GLIB_000:16;
        hence contradiction by A5, CHORD:def 3;
      end;
      then consider e1 being object such that
        A7: e1 DJoins v1,v2,H1 by A4, Th80;
      not ex e being object st e DJoins v2,v1,G
      proof
        given e being object such that
          A8: e DJoins v2,v1,G;
        e Joins v1,v2,G by A8, GLIB_000:16;
        hence contradiction by A5, CHORD:def 3;
      end;
      then consider e2 being object such that
        A9: e2 DJoins v2,v1,H1 by A4, Th80;
      A10: e1 Joins v1,v2,H1 & e2 Joins v1,v2,H1 by A7, A9, GLIB_000:16;
      H1 is non-multi by A1, A2, GLIB_010:89;
      then e1 = e2 by A10, GLIB_000:def 20;
      hence contradiction by A4, A7, A9, GLIB_009:6;
    end;
    then G is complete by CHORD:def 6;
    hence thesis by A3, GLIB_010:89; :: the complement must be edgeless
  end;
  cluster self-DLcomplementary -> non _trivial non self-Lcomplementary
    non self-Dcomplementary non self-complementary for _Graph;
  coherence
  proof
    let G be _Graph;
    assume A11: G is self-DLcomplementary;
    hence A12: G is non _trivial;
    thus G is non self-Lcomplementary
    proof
      assume A13: G is self-Lcomplementary;
      set H1 = the DLGraphComplement of G, H2 = the LGraphComplement of G;
      H1 is G-Disomorphic by A11;
      then consider F1 being PGraphMapping of G, H1 such that
        A14: F1 is Disomorphism by GLIB_010:def 24;
      H2 is G-isomorphic by A13;
      then consider F2 being PGraphMapping of G, H2 such that
        A15: F2 is isomorphism by GLIB_010:def 23;
      now
        let v1,v2 be Vertex of G;
        assume A16: v1 <> v2;
        assume A17: not v1,v2 are_adjacent;
        not ex e being object st e DJoins v1,v2,G
        proof
          given e being object such that
            A18: e DJoins v1,v2,G;
          e Joins v1,v2,G by A18, GLIB_000:16;
          hence contradiction by A17, CHORD:def 3;
        end;
        then consider e1 being object such that
          A19: e1 DJoins v1,v2,H1 by Def6;
        not ex e being object st e DJoins v2,v1,G
        proof
          given e being object such that
            A20: e DJoins v2,v1,G;
          e Joins v1,v2,G by A20, GLIB_000:16;
          hence contradiction by A17, CHORD:def 3;
        end;
        then consider e2 being object such that
          A21: e2 DJoins v2,v1,H1 by Def6;
        A22: e1 Joins v1,v2,H1 & e2 Joins v1,v2,H1 by A19, A21, GLIB_000:16;
        H1 is non-multi by A13, A14, GLIB_010:89;
        then e1 = e2 by A22, GLIB_000:def 20;
        hence contradiction by A16, A19, A21, GLIB_009:6;
      end;
      then A23: G is complete by CHORD:def 6;
      then A24: the_Edges_of H2 = H2.loops() by Th75;
      consider v1, v2 being Vertex of G such that
        A25: v1 <> v2 by A12, GLIB_000:21;
      consider e being object such that
        A26: e Joins v1,v2,G by A23, A25, CHORD:def 6, CHORD:def 3;
      dom F2_E = the_Edges_of G & dom F2_V = the_Vertices_of G
        by A15, GLIB_010:def 11;
      then A27: e in dom F2_E & v1 in dom F2_V & v2 in dom F2_V
        by A26, GLIB_000:def 13;
      then A28: F2_E.e Joins F2_V.v1,F2_V.v2,H2 by A26, GLIB_010:4;
      F2_V.v1 <> F2_V.v2 by A15, A25, A27, FUNCT_1:def 4;
      then not F2_E.e in H2.loops() by A28, GLIB_009:46;
      hence contradiction by A24, A28, GLIB_000:def 13;
    end;
    thus thesis by A11;
  end;
  cluster self-Lcomplementary -> non _trivial non self-DLcomplementary
    non self-Dcomplementary non self-complementary for _Graph;
  coherence;
end;

registration
  cluster self-Dcomplementary self-complementary for _Graph;
  existence
  proof
    take the _trivial edgeless _Graph;
    thus thesis;
  end;
end;

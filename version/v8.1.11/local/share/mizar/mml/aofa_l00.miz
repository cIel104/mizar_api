:: Algebraic Approach to Algorithmic Logic
::  by Grzegorz Bancerek
::
:: Received September 15, 2014
:: Copyright (c) 2014-2021 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies FUNCT_1, PBOOLE, UNIALG_1, MSUALG_1, FINSEQ_1, MSUALG_6,
      FINSET_1, FUNCT_7, ORDINAL2, ARYTM_3, RELAT_1, CATALG_1, XBOOLE_0,
      FOMODEL2, ZFMISC_1, ORDINAL1, STRUCT_0, SUBSET_1, TARSKI, CARD_3,
      MARGREL1, CARD_1, FUNCOP_1, FUNCT_3, NUMBERS, ARYTM_1, NAT_1, FACIRC_1,
      XXREAL_0, ORDINAL4, FUNCT_2, INCPROJ, FUNCT_4, COMPUT_1, PARTFUN1,
      WELLORD1, MSAFREE, UNIALG_2, AOFA_000, AOFA_L00, MCART_1, AOFA_A00,
      GRAPHSP, QC_LANG1, ZF_LANG, FOMODEL1, SETLIM_2, REAL_1, INSTALG1,
      PUA2MSS1, MATROID0, ALGSPEC1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, ENUMSET1, MCART_1,
      MATROID0, XTUPLE_0, FUNCT_1, RELSET_1, FUNCT_2, BINOP_1, FINSET_1,
      FINSEQ_1, FINSEQ_2, FUNCOP_1, NUMBERS, XREAL_0, NAT_1, NAT_D, FUNCT_3,
      FUNCT_4, MARGREL1, FUNCT_7, ORDINAL1, ORDINAL2, PBOOLE, CARD_1, CARD_3,
      FINSEQ_4, XXREAL_0, XCMPLX_0, STRUCT_0, FACIRC_1, COMPUT_1, INSTALG1,
      CATALG_1, UNIALG_1, MSUALG_1, MSAFREE, PUA2MSS1, UNIALG_2, FREEALG,
      CIRCCOMB, CLOSURE2, MSUALG_6, ALGSPEC1, MSAFREE3, MSAFREE4, PARTFUN1,
      AOFA_000, AOFA_A00, MSAFREE5;
 constructors RELAT_1, FUNCT_1, XXREAL_0, FINSEQ_1, FINSEQ_3, ENUMSET1,
      FUNCOP_1, NAT_1, FUNCT_4, BINOP_1, FUNCT_7, ORDINAL1, XCMPLX_0, CARD_1,
      CARD_3, FINSEQ_4, FACIRC_1, STRUCT_0, UNIALG_1, MSUALG_1, INSTALG1,
      MSUALG_6, PBOOLE, MARGREL1, FUNCT_2, REALSET2, RELSET_1, COMPUT_1,
      AOFA_000, PUA2MSS1, FREEALG, UNIALG_2, ZFMISC_1, SUBSET_1, NUMBERS,
      FINSEQ_2, MSAFREE, MSAFREE3, CATALG_1, CLOSURE2, MSAFREE4, AOFA_A00,
      XTUPLE_0, ARYTM_1, NAT_D, ORDINAL2, CIRCCOMB, ALGSPEC1, MSAFREE5,
      RELSET_2;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FACIRC_1, NAT_1, FINSEQ_2, PBOOLE, STRUCT_0, FINSEQ_1, XXREAL_0,
      UNIALG_1, INSTALG1, CATALG_1, CARD_1, MSUALG_1, XREAL_0, RELAT_1,
      FUNCT_2, ZFMISC_1, FUNCT_4, XTUPLE_0, INDEX_1, MSAFREE4, AOFA_A00,
      MSUALG_9, CIRCCOMB, FOMODEL0, RAMSEY_1;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, FUNCT_1, PARTFUN1, FINSET_1, PBOOLE, STRUCT_0,
      UNIALG_1, MSUALG_1, PUA2MSS1, UNIALG_2, FREEALG, INSTALG1, ALGSPEC1,
      AOFA_000, AOFA_A00;
 equalities FUNCOP_1, PUA2MSS1, MSUALG_1, AOFA_000, AOFA_A00, TARSKI, XTUPLE_0,
      CARD_3, ORDINAL1, BINOP_1, UNIALG_2;
 expansions TARSKI, FINSEQ_1, UNIALG_1, PBOOLE, AOFA_A00, MSUALG_1, UNIALG_2,
      AOFA_000;
 theorems TARSKI, FINSEQ_3, FUNCT_7, FUNCT_1, RELAT_1, PBOOLE, FUNCT_2,
      FINSEQ_1, FINSET_1, FINSEQ_2, PARTFUN1, ZFMISC_1, ENUMSET1, XBOOLE_0,
      RELSET_2, FUNCOP_1, GRFUNC_1, XBOOLE_1, XXREAL_0, CARD_1, UNIALG_1,
      CARD_5, AOFA_000, FREEALG, CARD_3, SUBSET_1, MCART_1, AOFA_A00, XTUPLE_0,
      NAT_1, XREAL_1, ORDINAL1, MSAFREE2, INSTALG1, FUNCT_4, ORDINAL2,
      ORDINAL3, XREGULAR, MSUALG_6, MSUALG_1, AOFA_I00, MSAFREE4, PRALG_2,
      ALGSPEC1, CIRCCOMB, FUNCT_3;
 schemes FUNCT_1, BINOP_1, AOFA_A00;

begin :: Algorithmic language signature

reserve X,Y for set, x,y,z for object, i,j,n for natural number;

registration
  let f be non empty-yielding Function;
  cluster Union f -> non empty;
  coherence
  proof
    rng f c/= {{}} by RELAT_1:def 15;
    then consider x such that
A1: x in rng f & x nin {{}};
    reconsider x as set by TARSKI:1;
    x <> {} & x c= Union f by A1,TARSKI:def 1,ZFMISC_1:74;
    hence thesis;
  end;
end;

definition
  let I be set;
  let f be ManySortedSet of I;
  let i be set;
  let x;
  redefine func f+*(i,x) -> ManySortedSet of I;
  coherence
  proof
    dom(f+*(i,x)) = dom f = I by FUNCT_7:30,PARTFUN1:def 2;
    hence thesis by PARTFUN1:def 2,RELAT_1:def 18;
  end;
end;

registration
  let I be set;
  let f be non-empty ManySortedSet of I;
  let i be set;
  let x be non empty set;
  cluster f+*(i,x) -> non-empty;
  coherence;
end;

registration
  let S be non empty non void ManySortedSign;
  cluster non-empty for strict VarMSAlgebra over S;
  existence
  proof
    set X = the non-empty ManySortedSet of the carrier of S;
    set O = the ManySortedFunction of X# * the Arity of S,
    X * the ResultSort of S;
    set f = the ManySortedMSSet of X, X;
    take VarMSAlgebra(#X,O,f#);
    thus thesis;
  end;
end;

definition
  let f,g be Function;
  attr g is f-tolerating means
  f tolerates g;
end;

theorem Th1:
  for f,g being Function holds g is f-tolerating iff
  for x st x in dom f & x in dom g holds f.x = g.x
  proof
  let f,g be Function;
  thus g is f-tolerating implies
  for x st x in dom f & x in dom g holds f.x = g.x
  proof
    assume
A1: for x being object st x in dom f /\ dom g holds f.x = g.x;
    let x; assume x in dom f & x in dom g;
    then x in dom f /\ dom g by XBOOLE_0:def 4;
    hence thesis by A1;
  end;
  assume
A2: for x st x in dom f & x in dom g holds f.x = g.x;
    let x; assume x in dom f /\ dom g;
    then x in dom f & x in dom g by XBOOLE_0:def 4;
    hence thesis by A2;
end;

theorem Th2:
  for I,J being set for f being ManySortedSet of I
  for g being ManySortedSet of J holds g is f-tolerating iff
  for x st x in I & x in J holds f.x = g.x
  proof
    let I,J be set; let f be ManySortedSet of I;
    let g be ManySortedSet of J;
    dom f = I & dom g = J by PARTFUN1:def 2;
    hence thesis by Th1;
  end;

theorem Th3:
  for f,g being Function holds f tolerates g+*f
  proof
    let f,g be Function;
    let x; assume x in dom f /\ dom (g+*f);
    then x in dom f /\ (dom g \/ dom f) = dom f by FUNCT_4:def 1,XBOOLE_1:21;
    hence (g+*f).x = f.x by FUNCT_4:13;
  end;

registration
  let X,Y be Function;
  cluster Y+*X -> X-tolerating;
  coherence by Th3;
end;

registration
  let X be Function;
  let J be set;
  let Y be ManySortedSet of J;
  cluster Y+*(X|J) -> X-tolerating;
  coherence
  proof
    let x; assume
A1: x in dom X /\ dom (Y+*(X|J));
    then
A2: x in dom X & x in dom (Y+*(X|J)) = dom Y \/ dom (X|J)
    by XBOOLE_0:def 4,FUNCT_4:def 1;
    thus (Y+*(X|J)).x = (X|J).x by A2,RELAT_1:57,FUNCT_4:13
    .= X.x by A1,FUNCT_1:49;
  end;
end;

registration
  let J be set;
  let X be Function;
  cluster X-tolerating for ManySortedSet of J;
  existence
  proof
    set Y = the ManySortedSet of J;
    set Z = Y+*(X|J);
    reconsider Z as ManySortedSet of J;
    take Z; thus thesis;
  end;
end;

registration
  let J be set;
  let X be non-empty Function;
  cluster X-tolerating for non-empty ManySortedSet of J;
  existence
  proof
    set Y = the non-empty ManySortedSet of J;
    set Z = Y+*(X|J);
    reconsider Z as ManySortedSet of J;
    now
      let x; assume
A1:   x in J;
      per cases;
      suppose
A2:     x in dom X;
        then x in dom (X|J) by A1,RELAT_1:57;
        then Z.x = (X|J).x by FUNCT_4:13 .= X.x by A1,FUNCT_1:49;
        hence Z.x is non empty by A2,FUNCT_1:def 9;
      end;
      suppose x nin dom X;
        then x nin dom (X|J) by RELAT_1:57;
        then Z.x = Y.x by FUNCT_4:11;
        hence Z.x is non empty by A1;
      end;
    end;
    then reconsider Z as non-empty ManySortedSet of J by PBOOLE:def 13;
    take Z; thus thesis;
  end;
end;

registration
  let I be non empty set;
  let X be non empty-yielding ManySortedSet of I;
  cluster Union X -> non empty;
  coherence;
end;

theorem Th4:
  for S being non empty non void ManySortedSign
  for o being OperSymbol of S, r being SortSymbol of S,
      T being MSAlgebra over S holds
  o is_of_type {},r implies {} in Args(o,T)
  proof
    let S be non empty non void ManySortedSign;
    let o be OperSymbol of S;
    let r be SortSymbol of S;
    let T be MSAlgebra over S;
    assume A1: (the Arity of S).o = {} & (the ResultSort of S).o = r;
    Args(o,T) = product ((the Sorts of T)*the_arity_of o) by PRALG_2:3
    .= {{}} by A1,CARD_3:10;
    hence {} in Args(o,T) by TARSKI:def 1;
  end;

theorem Th5:
  for S being non empty non void ManySortedSign
  for o being OperSymbol of S, s,r being SortSymbol of S,
      T being MSAlgebra over S holds
  o is_of_type <*s*>,r & x in (the Sorts of T).s implies <*x*> in Args(o,T)
  proof
    let S be non empty non void ManySortedSign;
    let o be OperSymbol of S;
    let s,r be SortSymbol of S;
    let T be MSAlgebra over S;
    assume A1: (the Arity of S).o = <*s*> & (the ResultSort of S).o = r;
    assume A2: x in (the Sorts of T).s;
A3: dom the Sorts of T = the carrier of S by PARTFUN1:def 2;
    Args(o,T) = product ((the Sorts of T)*the_arity_of o) by PRALG_2:3
    .= product <*(the Sorts of T).s*> by A1,A3,FINSEQ_2:34;
    hence <*x*> in Args(o,T) by A2,FINSEQ_3:123;
  end;

Lm1:
  now
    let I be set;
    let A being ManySortedSet of I;
A1: dom A = I by PARTFUN1:def 2;
    rng A c= bool Union A
    proof
      let x; reconsider X = x as set by TARSKI:1;
      assume x in rng A;
      then X c= union rng A = Union A by ZFMISC_1:74;
      hence thesis;
    end;
    hence A is Function of I, bool Union A by A1,FUNCT_2:2;
  end;

theorem Th6:
  for S being non empty non void ManySortedSign
  for o being OperSymbol of S, s1,s2,r being SortSymbol of S,
      T being MSAlgebra over S holds
  o is_of_type <*s1,s2*>,r &
  x in (the Sorts of T).s1 & y in (the Sorts of T).s2
  implies <*x,y*> in Args(o,T)
  proof
    let S be non empty non void ManySortedSign;
    let o be OperSymbol of S;
    let s1,s2,r be SortSymbol of S;
    let A be MSAlgebra over S;
    assume A1: (the Arity of S).o = <*s1,s2*> & (the ResultSort of S).o = r;
    assume A2: x in (the Sorts of A).s1 & y in (the Sorts of A).s2;
    then reconsider x as Element of (the Sorts of A).s1;
    reconsider y as Element of (the Sorts of A).s2 by A2;
A3: the Sorts of A is Function of the carrier of S, bool Union the Sorts of A
    by Lm1;
    Args(o,A) = product ((the Sorts of A)*the_arity_of o) by PRALG_2:3
    .= product <*(the Sorts of A).s1,(the Sorts of A).s2*>
    by A1,A3,FINSEQ_2:36;
    hence thesis by A2,FINSEQ_3:124;
  end;

theorem
  for S being non empty non void ManySortedSign
  for o being OperSymbol of S, s1,s2,s3,r being SortSymbol of S,
      T being MSAlgebra over S holds
  o is_of_type <*s1,s2,s3*>,r & x in (the Sorts of T).s1 &
  y in (the Sorts of T).s2 & z in (the Sorts of T).s3
  implies <*x,y,z*> in Args(o,T)
  proof
    let S be non empty non void ManySortedSign;
    let o be OperSymbol of S;
    let s1,s2,s3,r be SortSymbol of S;
    let A be MSAlgebra over S;
    assume A1: (the Arity of S).o = <*s1,s2,s3*> & (the ResultSort of S).o = r;
    assume A2: x in (the Sorts of A).s1 & y in (the Sorts of A).s2 &
    z in (the Sorts of A).s3;
A3: the Sorts of A is Function of the carrier of S, bool Union the Sorts of A
    by Lm1;
    Args(o,A) = product ((the Sorts of A)*the_arity_of o) by PRALG_2:3
    .= product <*(the Sorts of A).s1,(the Sorts of A).s2,(the Sorts of A).s3*>
    by A1,A3,FINSEQ_2:37;
    hence <*x,y,z*> in Args(o,A) by A2,FINSEQ_3:125;
  end;

definition
  let S,E be Signature;
  attr E is S-extension means: Def2:
  S is Subsignature of E;
end;

registration
  let S be Signature;
  cluster -> S-extension for Extension of S;
  coherence by ALGSPEC1:def 5;
end;

theorem Th8:
  for S,E being non empty Signature st E is S-extension
  for a being SortSymbol of S holds a is SortSymbol of E
  proof
    let S,E be non empty Signature;
    assume S is Subsignature of E;
    then the carrier of S c= the carrier of E by INSTALG1:10;
    hence thesis;
  end;

theorem Th9:
  for S,E being non void Signature st E is S-extension
  for o being OperSymbol of S
  for a being set for r being Element of S for r1 being Element of E
  st r = r1 & o is_of_type a,r holds o is_of_type a,r1
  proof
    let S,E be non void Signature;
    assume S is Subsignature of E;
    then
A1: the carrier of S c= the carrier of E &
    the carrier' of S c= the carrier' of E &
    the ResultSort of S c= the ResultSort of E &
    the Arity of S c= the Arity of E by INSTALG1:10,11;
    let o be OperSymbol of S;
    let a be set;
    let r be Element of S;
    let r1 be Element of E;
    assume A2: r = r1;
    assume
A3: (the Arity of S).o = a & (the ResultSort of S).o = r;
    dom the Arity of S = the carrier' of S & o in the carrier' of S &
    dom the ResultSort of S = the carrier' of S by FUNCT_2:def 1;
    hence (the Arity of E).o = a & (the ResultSort of E).o = r1
    by A1,A2,A3,GRFUNC_1:2;
  end;

definition
  let X be Function;
  let J,Y be set;
  func X extended_by(Y,J) -> ManySortedSet of J equals (J-->Y)+*(X|J);
  coherence;
end;

registration
  let X be Function;
  let J,Y be set;
  cluster X extended_by(Y,J) -> X-tolerating;
  coherence;
end;

definition
  struct(ConnectivesSignature) PCLangSignature(#
    carrier -> set,
    carrier' -> set,
    Arity -> Function of the carrier', the carrier*,
    ResultSort -> Function of the carrier', the carrier,
    formula-sort -> (Element of the carrier),
    connectives -> (FinSequence of the carrier')
::   <* not-op, and-op, or-op, imp-op, iff-op, true *>
  #);
end;

definition
  let X be set; :: set of variable symbols
  struct(PCLangSignature) QCLangSignature over X(#
    carrier -> set,
    carrier' -> set,
    Arity -> Function of the carrier', the carrier*,
    ResultSort -> Function of the carrier', the carrier,
    formula-sort -> (Element of the carrier),
    connectives -> (FinSequence of the carrier'),
::   <* not-op, and-op, or-op, imp-op, iff-op, true *>
    quant-sort -> set,
    quantifiers -> Function of [:the quant-sort, X:], the carrier'
  #);
end;

definition
  let X be set;
  struct(QCLangSignature over X) AlgLangSignature over X(#
    carrier -> set,
    carrier' -> set,
    Arity -> Function of the carrier', the carrier*,
    ResultSort -> Function of the carrier', the carrier,
    formula-sort, program-sort -> (Element of the carrier),
    connectives -> (FinSequence of the carrier'),
::    <* not-op, and-op, or-op, imp-op, iff-op, true, alg-imp *>
    quant-sort -> set,
    quantifiers -> Function of [:the quant-sort, X:], the carrier'
  #);
end;

definition
  let n be Nat;
  let L be PCLangSignature;
  attr L is n PC-correct means:
Def4:
  len the connectives of L >= n+5 &
  (the connectives of L)|{n,n+1,n+2,n+3,n+4,n+5} is one-to-one &
  (the connectives of L).n is_of_type
  <*the formula-sort of L*>, the formula-sort of L &
  (the connectives of L).(n+5) is_of_type {}, the formula-sort of L &
  ((the connectives of L).(n+1) is_of_type
    <*the formula-sort of L, the formula-sort of L*>, the formula-sort of L
   & ... &
   (the connectives of L).(n+4) is_of_type
    <*the formula-sort of L, the formula-sort of L*>, the formula-sort of L);
end;

definition
  let X;
  let L be QCLangSignature over X;
  attr L is QC-correct means: Def5:
::  (ex q1,q2 being set st q1 <> q2 & the quant-sort of L = {q1,q2}) &
  the quant-sort of L = {1,2} &  :: { \for, \ex }
  the quantifiers of L is one-to-one &
  rng the quantifiers of L misses rng the connectives of L &
  for q,x being object st q in the quant-sort of L & x in X holds
  (the quantifiers of L).(q,x) is_of_type
    <*the formula-sort of L*>, the formula-sort of L;
end;

definition
  let n be Nat;
  let X be set;
  let L be AlgLangSignature over X;
  attr L is n AL-correct means:
Def6:
  the program-sort of L <> the formula-sort of L &
  len the connectives of L >= n+8 &
  ((the connectives of L).(n+6) is_of_type
  <*the program-sort of L,the formula-sort of L*>, the formula-sort of L
  & ... &
  (the connectives of L).(n+8) is_of_type
  <*the program-sort of L,the formula-sort of L*>, the formula-sort of L);
end;

registration
  let n;
  cluster n PC-correct -> non void for PCLangSignature;
  coherence;
end;

definition
  let X,Y be set such that
A1: Y c= X;
  func incl(Y,X) -> Function of Y,X equals :Def7: id Y;
  coherence
  proof
    dom id Y = Y & rng id Y = Y;
    hence thesis by A1,FUNCT_2:2;
  end;
end;

registration
  let n be non empty natural number;
  let X be set;
  cluster non void non empty n PC-correct QC-correct
  for QCLangSignature over X;
  existence
  proof
    set O = {0,1,2,3,4,5}\/[:{1,2},X:];
    set a = ({1,2,3,4}--><*0,0*>)\/(({0}\/[:{1,2},X:])--><*0*>)\/({5}-->{});
    set r = O-->0;
A1: dom ({1,2,3,4}--><*0,0*>) = {1,2,3,4} & dom({5}-->{}) = {5} &
    dom (({0}\/[:{1,2},X:])--><*0*>) = {0}\/[:{1,2},X:];
B1: [:{1,2},X:] misses {0,1,2,3,4,5}
    proof
      assume [:{1,2},X:] meets {0,1,2,3,4,5}; then
      consider x such that
A2:   x in {0,1,2,3,4,5} & x in [:{1,2},X:] by XBOOLE_0:3;
      thus contradiction by A2,ENUMSET1:def 4;
    end;
    {1,2,3,4} misses {0}\/[:{1,2},X:]
    proof
      assume {1,2,3,4} meets {0}\/[:{1,2},X:]; then
      consider x such that
A2:   x in {1,2,3,4} & x in {0}\/[:{1,2},X:] by XBOOLE_0:3;
      x in {0} or x in [:{1,2},X:] by A2,XBOOLE_0:def 3; then
      consider y,z such that
A3:   y in {1,2} & z in X & x = [y,z] by A2,ENUMSET1:def 2;
      thus contradiction by A2,A3,ENUMSET1:def 2;
    end; then
    reconsider aa = ({1,2,3,4}--><*0,0*>)\/(({0}\/[:{1,2},X:])--><*0*>)
    as Function by A1,GRFUNC_1:13;
A4: dom aa = {1,2,3,4} \/({0}\/[:{1,2},X:]) by A1,XTUPLE_0:23
    .= {0}\/{1,2,3,4}\/[:{1,2},X:] by XBOOLE_1:4
    .= {0,1,2,3,4}\/[:{1,2},X:] by ENUMSET1:7;
    {0,1,2,3,4}\/[:{1,2},X:] misses {5}
    proof
      assume {0,1,2,3,4}\/[:{1,2},X:] meets {5}; then
      consider x such that
A5:   x in {0,1,2,3,4}\/[:{1,2},X:] & x in {5} by XBOOLE_0:3;
      x = 5 by A5,TARSKI:def 1; then
      5 in {0,1,2,3,4} or 5 in [:{1,2},X:] by A5,XBOOLE_0:def 3;
      hence contradiction by ENUMSET1:def 3;
    end; then
    reconsider a as Function by A1,A4,GRFUNC_1:13;
A6: dom a = {0,1,2,3,4}\/[:{1,2},X:]\/{5} by A1,A4,XTUPLE_0:23
    .= {5}\/{0,1,2,3,4}\/[:{1,2},X:] by XBOOLE_1:4
    .= O by ENUMSET1:15;
    reconsider 00 = 0 as Element of {0} by TARSKI:def 1;
    <*00*> in {0}* & <*00,00*> in {0}* by FINSEQ_1:def 11; then
    rng ({1,2,3,4}--><*0,0*>) c= {0}* &
    rng (({0}\/[:{1,2},X:])--><*0*>) c= {0}* by ZFMISC_1:31; then
    rng ({1,2,3,4}--><*0,0*>) \/ rng (({0}\/[:{1,2},X:])--><*0*>) c= {0}* &
    <*>{0} in {0}* by FINSEQ_1:def 11,XBOOLE_1:8; then
    rng aa c= {0}* & rng({5}-->{}) c= {0}* by RELAT_1:12; then
    rng aa \/ rng({5}-->{}) c= {0}* by XBOOLE_1:8; then
    rng a c= {0}* by RELAT_1:12; then
    reconsider a as Function of O,{0}* by A6,FUNCT_2:2;
    reconsider r as Function of O,{0};
    0 in {0,1,2,3,4,5} & 1 in {0,1,2,3,4,5} & 2 in {0,1,2,3,4,5} &
    3 in {0,1,2,3,4,5} & 4 in {0,1,2,3,4,5} & 5 in {0,1,2,3,4,5}
    by ENUMSET1:def 4; then
    reconsider o0=0, o1=1, o2=2, o3=3, o4=4, o5=5 as Element of O
    by XBOOLE_0:def 3;
    set p = the n-'1 qua Nat-element FinSequence of {0,1,2,3,4,5};
B2: rng p c= {0,1,2,3,4,5} c= O by XBOOLE_1:7;
    then reconsider p as FinSequence of O by XBOOLE_1:1,FINSEQ_1:def 4;
    set c6 = <*o0,o1,o2,o3,o4,o5*>;
    reconsider c = p^c6 as FinSequence of O;
    rng c6 = {0,1,2,3,4,5} by AOFA_A00:21;
    then
B3: rng c = rng p \/ rng c6 c= {0,1,2,3,4,5}\/{0,1,2,3,4,5} = {0,1,2,3,4,5}
    by B2,XBOOLE_1:13,FINSEQ_1:31;
    n > 0;
    then
A7: n >= 0+1 by NAT_1:13;
A8: (i = 0 or ... or i = 5) implies c.(n+i) = i
    proof
      assume i = 0 or ... or i = 5;
      then i = 0 & c.(n+0) = c6.(0+1) or ... or i = 5 & c.(n+5) = c6.(5+1);
      hence thesis by AOFA_A00:20;
    end;
    take L=QCLangSignature(#{0},O,a,r,In(0,{0}),c,{1,2},incl([:{1,2},X:],O)#);
    thus the carrier' of L is non empty;
    thus the carrier of L is non empty;
    len c6 = 5+1 & len p = n-'1 by CARD_1:def 7;
    then len p+len c6 = n-'1+(1+5) = n-'1+1+5 & n is Real & 1 is Real;
    then len p+len c6 = n+5 by A7,XREAL_1:235;
    hence len the connectives of L >= n+5 by FINSEQ_1:22;
    set N = {n,n+1,n+2,n+3,n+4,n+5};
    thus (the connectives of L)|N is one-to-one
    proof
      let x,y; assume
A9:   x in dom ((the connectives of L)|N) &
      y in dom ((the connectives of L)|N) &
      ((the connectives of L)|N).x = ((the connectives of L)|N).y;
      then
A10:   x in N & y in N by RELAT_1:57;
      then
A11:   c.x = (c|N).x = c.y by A9,FUNCT_1:49;
A12:   (x = n+0 or ... or x = n+5) & (y = n+0 or ... or y = n+5)
      by A10,ENUMSET1:def 4;
      then consider i being Nat such that
A13:   0 <= i <= 5 & x = n+i;
      consider j being Nat such that
A14:   0 <= j <= 5 & y = n+j by A12;
      (i = 0 or ... or i = 5) & (j = 0 or ... or j = 5) by A13,A14;
      then c.x = i & c.y = j by A8,A13,A14;
      hence thesis by A11,A13,A14;
    end;
    thus (the connectives of L).n is_of_type
    <*the formula-sort of L*>, the formula-sort of L
    proof
      0 = 0 or ... or 0 = 5; then
A15:   c.(n+0) = 0 by A8;
      00 in {0}\/[:{1,2},X:] & <*0*> in {<*0*>}
      by XBOOLE_0:def 3,TARSKI:def 1; then
      [0,<*0*>] in ({0}\/[:{1,2},X:])--><*0*> by ZFMISC_1:106; then
      [0,<*0*>] in aa by XBOOLE_0:def 3; then
      [0,<*0*>] in a by XBOOLE_0:def 3;
      hence (the Arity of L).((the connectives of L).n) = <*00*>
      by A15,FUNCT_1:1
      .= <*the formula-sort of L*>;
      thus (the ResultSort of L).((the connectives of L).n) = 00
      .= the formula-sort of L;
    end;
    thus (the connectives of L).(n+5) is_of_type {}, the formula-sort of L
    proof
      0 = 5 or ... or 5 = 5; then
A16:   c.(n+5) = 5 by A8;
      5 in {5} & {} in {{}}
      by TARSKI:def 1; then
      [5,{}] in {5}-->{} by ZFMISC_1:106; then
      [5,{}] in a by XBOOLE_0:def 3;
      hence (the Arity of L).((the connectives of L).(n+5)) = {}
      by A16,FUNCT_1:1;
      thus (the ResultSort of L).((the connectives of L).(n+5)) = 00
      .= the formula-sort of L;
    end;
    thus (the connectives of L).(n+1) is_of_type
    <*the formula-sort of L, the formula-sort of L*>, the formula-sort of L
    & ... &
    (the connectives of L).(n+4) is_of_type
    <*the formula-sort of L, the formula-sort of L*>, the formula-sort of L
    proof
      let i; assume 1 <= i <= 4; then
A17:  i = 1 or ... or i = 4;
      i = 1 & c.(n+1) = 1 or ... or i = 4 & c.(n+4) = 4 by A17; then
      c.(n+i) in {1,2,3,4} & <*0,0*> in {<*0,0*>}
      by TARSKI:def 1,ENUMSET1:def 2; then
      [c.(n+i),<*0,0*>] in {1,2,3,4}--><*0,0*> by ZFMISC_1:106; then
      [c.(n+i),<*0,0*>] in aa by XBOOLE_0:def 3; then
      [c.(n+i),<*0,0*>] in a by XBOOLE_0:def 3;
      hence (the Arity of L).((the connectives of L).(n+i)) = <*00,0*>
      by FUNCT_1:1
      .= <*the formula-sort of L,00*>
      .= <*the formula-sort of L,the formula-sort of L*>;
      thus (the ResultSort of L).((the connectives of L).(n+i)) = 00
      .= the formula-sort of L;
    end;
    thus the quant-sort of L = {1,2};
A18: the quantifiers of L = id [:{1,2},X:] by Def7,XBOOLE_1:7;
    hence the quantifiers of L is one-to-one;
    rng the quantifiers of L c= [:{1,2},X:] by A18;
    hence rng the quantifiers of L misses rng the connectives of L
    by B1,B3,XBOOLE_1:64;
    hereby let q,x be object; assume
A19:   q in the quant-sort of L & x in X; then
A20:  [q,x] in [:the quant-sort of L,X:] by ZFMISC_1:87;
      (the quantifiers of L).(q,x) = [q,x] & <*0*> in {<*0*>}
      by A19,A18,FUNCT_1:18,TARSKI:def 1,ZFMISC_1:87; then
      (the quantifiers of L).(q,x) in {0}\/[:{1,2},X:] & <*0*> in {<*0*>}
      by A20,XBOOLE_0:def 3; then
      [(the quantifiers of L).(q,x),<*0*>] in {0}\/[:{1,2},X:]--><*0*>
      by ZFMISC_1:106; then
      [(the quantifiers of L).(q,x),<*0*>] in aa by XBOOLE_0:def 3; then
A21:  [(the quantifiers of L).(q,x),<*0*>] in a by XBOOLE_0:def 3;
      thus (the quantifiers of L).(q,x) is_of_type
      <*the formula-sort of L*>, the formula-sort of L
      proof
        thus (the Arity of L).((the quantifiers of L).(q,x)) = <*00*>
        by A21,FUNCT_1:1
        .= <*the formula-sort of L*>;
        thus (the ResultSort of L).((the quantifiers of L).(q,x)) = 00
        .= the formula-sort of L;
      end;
    end;
  end;
end;

registration
  let n be non empty natural number;
  cluster non void non empty n PC-correct for PCLangSignature;
  existence
  proof
    set X = the set;
    set S = the non void non empty n PC-correct QC-correct
    QCLangSignature over X;
    take S; thus thesis;
  end;
end;

registration
  let X be set;
  cluster non void non empty for strict AlgLangSignature over X;
  existence
  proof
    set C = the non empty set;
    set O = the non empty set;
    set ay = the Function of O,C*;
    set rs = the Function of O,C;
    set f = the Element of C;
    set p = the Element of C;
    set c = the FinSequence of O;
    set qs = {1,2};
    set q = the Function of [:qs, X:], O;
    take L = AlgLangSignature(#C,O,ay,rs,f,p,c,qs,q#);
    thus the carrier' of L is non empty;
    thus the carrier of L is non empty;
  end;
end;

registration
  cluster ordinal -> non pair for set;
  coherence
  proof
    let A be set; assume
A1: A is ordinal pair;
    then consider x,y such that
A2: A = [x,y] by XTUPLE_0:def 1;
    {} in A by A1,ORDINAL3:8;
    hence thesis by A2,TARSKI:def 2;
  end;
end;

theorem
  for a being ordinal number
  for n1,n2 being natural number st n1 <> n2 holds a+^n1 <> a+^n2
  by ORDINAL3:21;

registration
  let R be non empty Relation;
  cluster -> pair for Element of R;
  coherence;
end;

theorem Th11:
  for n being non empty natural number
  for X being non empty set
  for J being Signature
  ex S being strict non void non empty AlgLangSignature over X st
  S is n PC-correct QC-correct n AL-correct J-extension &
  (for i st i = 0 or ... or i = 8 holds
  (the connectives of S).(n+i) = (sup the carrier' of J)+^i) &
  (for x being Element of X holds
  (the quantifiers of S).(1,x) = [the carrier' of J,1,x] &
  (the quantifiers of S).(2,x) = [the carrier' of J,2,x]) &
  the formula-sort of S = sup the carrier of J &
  the program-sort of S = (sup the carrier of J)+^1 &
  the carrier of S = (the carrier of J) \/
  {the formula-sort of S, the program-sort of S} &
  for w being Ordinal st w = sup the carrier' of J holds
  the carrier' of S = (the carrier' of J) \/
  {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}\/
  [:{the carrier' of J},{1,2},X:]
  proof
    let n be non empty natural number;
    let X be non empty set;
    let J be Signature;
    set w = sup the carrier' of J;
    set u = sup the carrier of J;
    set O1 = {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}\/
    [:{the carrier' of J},{1,2},X:];
    set O = (the carrier' of J)\/O1;
    set a = ({w+^1,w+^2,w+^3,w+^4}--><*u+^0,u+^0*>)\/
    (({w+^0}\/[:{the carrier' of J},{1,2},X:])--><*u+^0*>)\/
    ({w+^5}-->{})\/({w+^6,w+^7,w+^8}--><*u+^1,u+^0*>);
    set ay = (the Arity of J)\/a;
    set r = O1-->u+^0;
    set rs = (the ResultSort of J)+*r;
A1: dom ({w+^1,w+^2,w+^3,w+^4}--><*u+^0,u+^0*>) = {w+^1,w+^2,w+^3,w+^4} &
    dom ({w+^6,w+^7,w+^8}--><*u+^1,u+^0*>) = {w+^6,w+^7,w+^8} &
    dom ({w+^5}-->{}) = {w+^5} &
    dom (({w+^0}\/[:{the carrier' of J},{1,2},X:])--><*u+^0*>)
    = {w+^0}\/[:{the carrier' of J},{1,2},X:];
B1: {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} misses
    [:{the carrier' of J},{1,2},X:]
    proof
      assume {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} meets
      [:{the carrier' of J},{1,2},X:]; then
      consider x such that
A2:   x in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} &
      x in [:{the carrier' of J},{1,2},X:]
      by XBOOLE_0:3;
A3:   x = w+^0 or x = w+^1 or x = w+^2 or x = w+^3 or x = w+^4 or x = w+^5 or
      x = w+^6 or x = w+^7 or x = w+^8 by A2,ENUMSET1:def 7;
      consider j being object, y,z such that
A5:   j in {the carrier' of J} & y in {1,2} & z in X & x = [j,y,z]
      by A2,MCART_1:68;
      thus contradiction by A3,A5;
    end;
    {w+^1,w+^2,w+^3,w+^4} misses {w+^0}\/[:{the carrier' of J},{1,2},X:]
    proof
      assume {w+^1,w+^2,w+^3,w+^4} meets
      {w+^0}\/[:{the carrier' of J},{1,2},X:]; then
      consider x such that
A2:   x in {w+^1,w+^2,w+^3,w+^4} & x in {w+^0}\/[:{the carrier' of J},{1,2},X:]
      by XBOOLE_0:3;
A3:   x = w+^1 or x = w+^2 or x = w+^3 or x = w+^4 by A2,ENUMSET1:def 2;
A4:   w+^0 <> w+^1 & w+^0 <> w+^2 & w+^0 <> w+^3 & w+^0 <> w+^4 by ORDINAL3:21;
      x in {w+^0} or x in [:{the carrier' of J},{1,2},X:]
      by A2,XBOOLE_0:def 3; then
      consider j being object, y,z such that
A5:   j in {the carrier' of J} & y in {1,2} & z in X & x = [j,y,z]
      by A3,A4,MCART_1:68,TARSKI:def 1;
      thus contradiction by A2,A5,ENUMSET1:def 2;
    end; then
    reconsider aa = ({w+^1,w+^2,w+^3,w+^4}--><*u+^0,u+^0*>)\/
    (({w+^0}\/[:{the carrier' of J},{1,2},X:])--><*u+^0*>)
    as Function by A1,GRFUNC_1:13;
A6: dom aa = {w+^1,w+^2,w+^3,w+^4} \/({w+^0}\/[:{the carrier' of J},{1,2},X:])
    by A1,XTUPLE_0:23
    .= {w+^0}\/{w+^1,w+^2,w+^3,w+^4}\/[:{the carrier' of J},{1,2},X:]
    by XBOOLE_1:4
    .= {w+^0,w+^1,w+^2,w+^3,w+^4}\/[:{the carrier' of J},{1,2},X:]
    by ENUMSET1:7;
    {w+^0,w+^1,w+^2,w+^3,w+^4}\/[:{the carrier' of J},{1,2},X:] misses {w+^5}
    proof
      assume {w+^0,w+^1,w+^2,w+^3,w+^4}\/[:{the carrier' of J},{1,2},X:]
      meets {w+^5}; then
      consider x such that
A7:   x in {w+^0,w+^1,w+^2,w+^3,w+^4}\/[:{the carrier' of J},{1,2},X:] &
      x in {w+^5} by XBOOLE_0:3;
A8:   w+^5 <> w+^0 & w+^5 <> w+^1 & w+^5 <> w+^2 & w+^5 <> w+^3 & w+^5 <> w+^4
      by ORDINAL3:21;
      x = w+^5 by A7,TARSKI:def 1; then
      w+^5 in {w+^0,w+^1,w+^2,w+^3,w+^4} or
      w+^5 in [:{the carrier' of J},{1,2},X:] by A7,XBOOLE_0:def 3; then
      ex j being object,y,z st j in {the carrier' of J} & y in {1,2} &
      z in X & w+^5 = [j,y,z] by A8,ENUMSET1:def 3,MCART_1:68;
      hence contradiction;
    end; then
    reconsider ab = aa\/({w+^5}-->{}) as Function by A1,A6,GRFUNC_1:13;
A9: dom ab = {w+^0,w+^1,w+^2,w+^3,w+^4}\/[:{the carrier' of J},{1,2},X:]\/
    {w+^5} by A1,A6,XTUPLE_0:23
    .= {w+^5}\/{w+^0,w+^1,w+^2,w+^3,w+^4}\/[:{the carrier' of J},{1,2},X:]
    by XBOOLE_1:4
    .= {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5}\/[:{the carrier' of J},{1,2},X:]
    by ENUMSET1:15;
    {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5}\/[:{the carrier' of J},{1,2},X:]
    misses {w+^6,w+^7,w+^8}
    proof
      assume {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5}\/[:{the carrier' of J},{1,2},X:]
      meets {w+^6,w+^7,w+^8}; then
      consider x such that
A10:   x in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5}\/[:{the carrier' of J},{1,2},X:] &
      x in {w+^6,w+^7,w+^8} by XBOOLE_0:3;
A11:   w+^6 <> w+^0 & w+^6 <> w+^1 & w+^6 <> w+^2 & w+^6 <> w+^3 & w+^6 <> w+^4
      & w+^6 <> w+^5
      by ORDINAL3:21;
A12:   w+^7 <> w+^0 & w+^7 <> w+^1 & w+^7 <> w+^2 & w+^7 <> w+^3 & w+^7 <> w+^4
      & w+^7 <> w+^5
      by ORDINAL3:21;
A13:   w+^8 <> w+^0 & w+^8 <> w+^1 & w+^8 <> w+^2 & w+^8 <> w+^3 & w+^8 <> w+^4
      & w+^8 <> w+^5
      by ORDINAL3:21;
      x = w+^6 or x = w+^7 or x = w+^8 by A10,ENUMSET1:def 1; then
      w+^6 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5} or
      w+^6 in [:{the carrier' of J},{1,2},X:] or
      w+^7 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5} or
      w+^7 in [:{the carrier' of J},{1,2},X:] or
      w+^8 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5} or
      w+^8 in [:{the carrier' of J},{1,2},X:] by A10,XBOOLE_0:def 3; then
      w+^6 in [:{the carrier' of J},{1,2},X:] or
      w+^7 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5} or
      w+^7 in [:{the carrier' of J},{1,2},X:] or
      w+^8 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5} or
      w+^8 in [:{the carrier' of J},{1,2},X:] by A11,ENUMSET1:def 4; then
      w+^6 in [:{the carrier' of J},{1,2},X:] or
      w+^7 in [:{the carrier' of J},{1,2},X:] or
      w+^8 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5} or
      w+^8 in [:{the carrier' of J},{1,2},X:] by A12,ENUMSET1:def 4; then
      (ex j being object,y,z st j in {the carrier' of J} & y in {1,2} &
      z in X & w+^6 = [j,y,z]) or
      (ex j being object,y,z st j in {the carrier' of J} & y in {1,2} &
      z in X & w+^7 = [j,y,z]) or
      (ex j being object,y,z st j in {the carrier' of J} & y in {1,2} &
      z in X & w+^8 = [j,y,z])
      by A13,ENUMSET1:def 4,MCART_1:68;
      hence contradiction;
    end; then
    reconsider a as Function by A1,A9,GRFUNC_1:13;
A14: dom a = {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5}\/[:{the carrier' of J},{1,2},X:]\/
    {w+^6,w+^7,w+^8} by A1,A9,XTUPLE_0:23
    .= {w+^6,w+^7,w+^8}\/{w+^0,w+^1,w+^2,w+^3,w+^4,w+^5}\/
    [:{the carrier' of J},{1,2},X:] by XBOOLE_1:4
    .= O1 by ENUMSET1:82;
    then
A15: dom ay = (dom the Arity of J) \/ dom a = O by XTUPLE_0:23,FUNCT_2:def 1;
A16: dom the Arity of J = the carrier' of J by FUNCT_2:def 1;
A17: O1 misses the carrier' of J
    proof
      assume O1 meets the carrier' of J;
      then consider x such that
A18:   x in O1 & x in the carrier' of J by XBOOLE_0:3;
      x in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} or
      x in [:{the carrier' of J},{1,2},X:] by A18,XBOOLE_0:def 3;
      then (x = w+^0 or ... or x = w+^8) or
      x in [:{the carrier' of J},{1,2},X:] by ENUMSET1:def 7;
      then(w+^0 in w or ... or w+^8 in w) & w = w+^0 or
      x in [:{the carrier' of J},{1,2},X:] by A18,ORDINAL2:19,27;
      then consider j,i,y being object such that
A19:  j in {the carrier' of J} & i in {1,2} & y in X & x = [j,i,y]
      by MCART_1:68,ORDINAL3:22;
      reconsider jiy = [j,i,y] as set;
      the carrier' of J = j & j in { j } & {j} in {{j,i},{j}} in {[j,i]} in jiy
      by A19,TARSKI:def 1,def 2;
      hence thesis by A18,A19,XREGULAR:9;
    end;
    then reconsider ay = (the Arity of J)\/a as Function
    by A14,A16,GRFUNC_1:13;
    set C = (the carrier of J)\/{u+^0,u+^1};
    u+^0 in {u+^0,u+^1} & u+^1 in {u+^0,u+^1} by TARSKI:def 2;
    then reconsider 00 = u+^0, 01 = u+^1 as Element of C by XBOOLE_0:def 3;
    <*00*> in C* & <*00,00*> in C* by FINSEQ_1:def 11; then
    rng ({w+^1,w+^2,w+^3,w+^4}--><*00,00*>) c= C* &
    rng (({w+^0}\/[:{the carrier' of J},{1,2},X:])--><*00*>) c= C*
    by ZFMISC_1:31; then
    rng ({w+^1,w+^2,w+^3,w+^4}--><*00,00*>) \/
    rng (({w+^0}\/[:{the carrier' of J},{1,2},X:])--><*00*>) c= C* &
    <*>C in C* by FINSEQ_1:def 11,XBOOLE_1:8; then
    rng aa c= C* & rng ({w+^5}-->{}) c= C*
    by RELAT_1:12; then
    rng aa \/ rng ({w+^5}-->{}) c= C* &
    <*01,00*> in C* by FINSEQ_1:def 11,XBOOLE_1:8; then
    rng ab c= C* & rng ({w+^6,w+^7,w+^8}--><*01,00*>) c= C*
    by ZFMISC_1:31,RELAT_1:12; then
    rng ab \/ rng ({w+^6,w+^7,w+^8}--><*01,00*>) c= C*
    by XBOOLE_1:8; then
A20: rng a c= C* by RELAT_1:12;
    rng the Arity of J c= (the carrier of J)* c= C* by XBOOLE_1:7,FINSEQ_1:62;
    then rng the Arity of J c= C*;
    then rng ay = (rng the Arity of J) \/ rng a c= C*
    by A20,XBOOLE_1:8,RELAT_1:12;
    then reconsider ay as Function of O,C* by A15,FUNCT_2:2;
    the carrier' of J <> {} implies the carrier of J <> {} by INSTALG1:def 1;
    then
A21: dom r = O1 & rng r = {00} & {00} c= C & dom the ResultSort of J
    = the carrier' of J & rng the ResultSort of J c= the carrier of J c= C
    by XBOOLE_1:7,ZFMISC_1:31,FUNCT_2:def 1;
    then rng the ResultSort of J c= C;
    then dom rs = O & rng rs c= {00}\/rng the ResultSort of J c= C
    by A21,XBOOLE_1:8,FUNCT_4:def 1,17;
    then dom rs = O & rng rs c= C;
    then reconsider rs as Function of O,C by FUNCT_2:2;
    w+^0 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} & ... &
    w+^8 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}
    by ENUMSET1:def 7; then
    w+^0 in O1 & ... & w+^8 in O1 by XBOOLE_0:def 3; then
    reconsider o0=w+^0, o1=w+^1, o2=w+^2, o3=w+^3, o4=w+^4, o5=w+^5,
    o6=w+^6, o7=w+^7, o8=w+^8 as Element of O by XBOOLE_0:def 3;
    set p = the n-'1 qua Nat-element FinSequence of
    {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8};
B2: rng p c= {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} c= O1 c= O
    by XBOOLE_1:7;
    then rng p c= {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} c= O;
    then reconsider p as FinSequence of O by XBOOLE_1:1,FINSEQ_1:def 4;
    set c9 = <*o0,o1,o2,o3,o4,o5,o6,o7*>^<*o8*>;
    n > 0;
    then
A22: n >= 0+1 by NAT_1:13;
    reconsider c = p^c9 as FinSequence of O;
    rng c9 = {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} by AOFA_A00:26;
    then
B3: rng c = rng p \/ rng c9 c= {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}\/
    {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}
    by B2,XBOOLE_1:13,FINSEQ_1:31;
A23: i = 0 or ... or i = 8 implies c.(n+i) = w+^i
    proof
      assume
      i = 0 or ... or i = 8;
      then
A24:  i = 0 & c.(n+0) = c9.(0+1) or ... or i = 8 & c.(n+8) = c9.(8+1);
      thus thesis by A24,AOFA_A00:29;
    end;
    deffunc Q(object) = [the carrier' of J,$1`1,$1`2];
    consider q being Function such that
A25: dom q = [:{1,2},X:] & for x st x in [:{1,2},X:] holds q.x = Q(x)
    from FUNCT_1:sch 3;
    rng q c= O
    proof
      let x; assume x in rng q;
      then consider y such that
A26:   y in dom q & x = q.y by FUNCT_1:def 3;
      consider i,z being object such that
A27:   i in {1,2} & z in X & y = [i,z] by A25,A26,ZFMISC_1:def 2;
      x = [the carrier' of J,y`1,y`2] & y`1 = i & y`2 = z &
      the carrier' of J in {the carrier' of J}
      by A25,A26,A27,TARSKI:def 1;
      then x in [:{the carrier' of J},{1,2},X:] by A27,MCART_1:69;
      then x in O1 by XBOOLE_0:def 3;
      hence x in O by XBOOLE_0:def 3;
    end;
    then reconsider q as Function of [:{1,2},X:], O by A25,FUNCT_2:2;
    set L = AlgLangSignature(#C,O,ay,rs,00,01,c,{1,2},q#);
    reconsider L as non empty non void strict AlgLangSignature over X;
    take L;
    len c9 = 8+1 & len p = n-'1 & n is Real & 1 is Real by CARD_1:def 7;
    then
A28: len p+len c9 = n-'1+1+8 = n+8 by A22,XREAL_1:235;
    then len the connectives of L = n+8 = n+5+3 by FINSEQ_1:22;
    hence len the connectives of L >= n+5 by NAT_1:12;
    set N = {n,n+1,n+2,n+3,n+4,n+5};
    thus (the connectives of L)|N is one-to-one
    proof
      let x,y; assume
A29:  x in dom ((the connectives of L)|N) &
      y in dom ((the connectives of L)|N) &
      ((the connectives of L)|N).x = ((the connectives of L)|N).y;
      then
A30:  x in N & y in N by RELAT_1:57;
      then
A31:  c.x = (c|N).x = c.y by A29,FUNCT_1:49;
A32:  (x = n+0 or ... or x = n+5) & (y = n+0 or ... or y = n+5)
      by A30,ENUMSET1:def 4;
      then consider i being Nat such that
A33:  0 <= i <= 5 & x = n+i;
      consider j being Nat such that
A34:  0 <= j <= 5 & y = n+j by A32;
      i <= 8 & j <= 8 by A33,A34,XXREAL_0:2;
      then (i = 0 or ... or i = 8) & (j = 0 or ... or j = 8);
      then c.x = w+^i & c.y = w+^j by A23,A33,A34;
      hence thesis by A31,A33,A34,ORDINAL3:21;
    end;
    thus (the connectives of L).n is_of_type
    <*the formula-sort of L*>, the formula-sort of L
    proof
      0 = 0 or ... or 0 = 8; then
A35:   c.(n+0) = w+^0 by A23;
A36:   w+^0 in {w+^0} & 00 in {00} by TARSKI:def 1; then
      w+^0 in {w+^0}\/[:{the carrier' of J},{1,2},X:] & <*00*> in {<*00*>}
      by XBOOLE_0:def 3,TARSKI:def 1; then
      [w+^0,<*00*>] in ({w+^0}\/[:{the carrier' of J},{1,2},X:])--><*00*>
      by ZFMISC_1:106; then
      [w+^0,<*00*>] in aa by XBOOLE_0:def 3; then
      [w+^0,<*00*>] in ab by XBOOLE_0:def 3; then
      [w+^0,<*00*>] in a by XBOOLE_0:def 3;
      then [w+^0,<*00*>] in ay by XBOOLE_0:def 3;
      hence (the Arity of L).((the connectives of L).n)
      = <*the formula-sort of L*> by A35,FUNCT_1:1;
      w+^0 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}
      by ENUMSET1:def 7; then
A37:   w+^0 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} \/
      [:{the carrier' of J},{1,2},X:] by XBOOLE_0:def 3; then
      [w+^0,00] in r by A36,ZFMISC_1:87;
      then r.(c.n) = 00 by A35,FUNCT_1:1;
      hence (the ResultSort of L).((the connectives of L).n)
      = the formula-sort of L by A35,A37,A21,FUNCT_4:13;
    end;
    thus (the connectives of L).(n+5) is_of_type {}, the formula-sort of L
    proof
      5 = 0 or ... or 5 = 8; then
A38:  c.(n+5) = w+^5 by A23;
      w+^5 in {w+^5} & {} in {{}}
      by TARSKI:def 1; then
      [w+^5,{}] in {w+^5}-->{} by ZFMISC_1:106; then
      [w+^5,{}] in ab by XBOOLE_0:def 3; then
      [w+^5,{}] in a by XBOOLE_0:def 3;
      then [w+^5,{}] in ay by XBOOLE_0:def 3;
      hence (the Arity of L).((the connectives of L).(n+5)) = {}
      by A38,FUNCT_1:1;
      w+^5 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}
      by ENUMSET1:def 7; then
A39:   w+^5 in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} \/
      [:{the carrier' of J},{1,2},X:] & 00 in {00}
      by TARSKI:def 1,XBOOLE_0:def 3; then
      [w+^5,00] in r by ZFMISC_1:87;
      then r.(w+^5) = 00 by FUNCT_1:1;
      hence (the ResultSort of L).((the connectives of L).(n+5))
      = the formula-sort of L by A39,A38,A21,FUNCT_4:13;
    end;
    thus (the connectives of L).(n+1) is_of_type
    <*the formula-sort of L, the formula-sort of L*>, the formula-sort of L
    & ... &
    (the connectives of L).(n+4) is_of_type
    <*the formula-sort of L, the formula-sort of L*>, the formula-sort of L
    proof
      let i; assume
A40:   1 <= i <= 4;
      then 0 <= i <= 8 by XXREAL_0:2;
      then
A41:   i = 0 or ... or i = 8; then
A42:   c.(n+i) = w+^i by A23;
      i = 1 or ... or i = 4 by A40; then
      c.(n+i) in {w+^1,w+^2,w+^3,w+^4} & <*00,00*> in {<*00,00*>}
      by A42,TARSKI:def 1,ENUMSET1:def 2; then
      [c.(n+i),<*00,00*>] in {w+^1,w+^2,w+^3,w+^4}--><*00,00*>
      by ZFMISC_1:106; then
      [c.(n+i),<*00,00*>] in aa by XBOOLE_0:def 3; then
      [c.(n+i),<*00,00*>] in ab by XBOOLE_0:def 3; then
      [c.(n+i),<*00,00*>] in a by XBOOLE_0:def 3;
      then [c.(n+i),<*00,00*>] in ay by XBOOLE_0:def 3;
      hence (the Arity of L).((the connectives of L).(n+i))
      = <*the formula-sort of L,the formula-sort of L*> by FUNCT_1:1;
      c.(n+i) in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}
      by A42,A41,ENUMSET1:def 7; then
A43:   c.(n+i) in O1 & 00 in {00} by TARSKI:def 1,XBOOLE_0:def 3; then
      [c.(n+i),00] in r by ZFMISC_1:106;
      then r.(c.(n+i)) = 00 by FUNCT_1:1;
      hence (the ResultSort of L).((the connectives of L).(n+i))
      = the formula-sort of L by A43,A21,FUNCT_4:13;
    end;
    thus the quant-sort of L = {1,2};
    thus the quantifiers of L is one-to-one
    proof let x,y; assume
A44:  x in dom the quantifiers of L & y in dom the quantifiers of L;
      then reconsider a = x, b = y as Element of [:{1,2},X:];
      assume (the quantifiers of L).x = (the quantifiers of L).y;
      then [the carrier' of J,x`1,x`2] = (the quantifiers of L).y by A44,A25
      .= [the carrier'of J,y`1,y`2] by A44,A25;
      then x`1 = y`1 & x`2 = y`2 by XTUPLE_0:3;
      then x = [a`1,a`2] = [b`1,b`2] = y;
      hence x = y;
    end;
    rng the quantifiers of L c= [:{the carrier' of J},{1,2},X:]
    proof
      let a be object; assume a in rng the quantifiers of L;
      then consider b being object such that
C1:   b in dom the quantifiers of L & a = (the quantifiers of L).b
      by FUNCT_1:def 3;
      reconsider b as Element of [:{1,2},X:] by C1;
      a = [the carrier' of J,b`1,b`2] & b`1 in {1,2} & b`2 in X &
      the carrier' of J in {the carrier' of J}
      by C1,A25,TARSKI:def 1,MCART_1:10;
      hence thesis by MCART_1:69;
    end;
    hence rng the quantifiers of L misses rng the connectives of L
    by B1,B3,XBOOLE_1:64;
    hereby let q,x be object; assume
A45:  q in the quant-sort of L & x in X;
A46:  (the quantifiers of L).(q,x) = [the carrier' of J,[q,x]`1,[q,x]`2] &
      <*00*> in {<*00*>} & [q,x]`1 = q & [q,x]`2 = x &
      the carrier'of J in {the carrier'of J}
      by A25,A45,TARSKI:def 1,ZFMISC_1:87; then
      (the quantifiers of L).(q,x) in
      [:{the carrier' of J},the quant-sort of L,X:] by A45,MCART_1:69;
      then (the quantifiers of L).(q,x) in
      {w+^0}\/[:{the carrier' of J},{1,2},X:] & <*00*> in {<*00*>}
      by XBOOLE_0:def 3,TARSKI:def 1; then
      [(the quantifiers of L).(q,x),<*00*>] in
      {w+^0}\/[:{the carrier' of J},{1,2},X:]--><*00*>
      by ZFMISC_1:106; then
      [(the quantifiers of L).(q,x),<*00*>] in aa by XBOOLE_0:def 3; then
      [(the quantifiers of L).(q,x),<*00*>] in ab by XBOOLE_0:def 3; then
      [(the quantifiers of L).(q,x),<*00*>] in a by XBOOLE_0:def 3;
      then
A47:  [(the quantifiers of L).(q,x),<*00*>] in ay by XBOOLE_0:def 3;
      thus (the quantifiers of L).(q,x) is_of_type
      <*the formula-sort of L*>, the formula-sort of L
      proof
        thus (the Arity of L).((the quantifiers of L).(q,x))
        = <*the formula-sort of L*> by A47,FUNCT_1:1;
        [the carrier' of J,q,x] in [:{the carrier' of J},{1,2},X:]
        by A46,A45,MCART_1:69;
        then
A48:    [the carrier' of J,q,x] in O1 by XBOOLE_0:def 3;
        then r.[the carrier' of J,q,x] = 00 &
        [the carrier' of J,q,x] in O by XBOOLE_0:def 3,FUNCOP_1:7;
        hence (the ResultSort of L).((the quantifiers of L).(q,x))
        = the formula-sort of L by A21,A46,A48,FUNCT_4:13;
      end;
    end;
    thus the program-sort of L <> the formula-sort of L by ORDINAL3:21;
    thus len the connectives of L >= n+8 by A28,FINSEQ_1:22;
    thus (the connectives of L).(n+6) is_of_type
    <*the program-sort of L,the formula-sort of L*>, the formula-sort of L
    & ... &
    (the connectives of L).(n+8) is_of_type
    <*the program-sort of L,the formula-sort of L*>, the formula-sort of L
    proof let i; assume
A49:  6 <= i <= 8;
A50:  i = 0 or ... or i = 8 by A49; then
A51:  c.(n+i) = w+^i by A23;
      i = 6 or ... or i = 8 by A49;
      then w+^i in {w+^6,w+^7,w+^8} & <*01,00*> in {<*01,00*>}
      by TARSKI:def 1,ENUMSET1:def 1; then
      [w+^i,<*01,00*>] in ({w+^6,w+^7,w+^8})--><*01,00*> by ZFMISC_1:106; then
      [w+^i,<*01,00*>] in a by XBOOLE_0:def 3;
      then [w+^i,<*01,00*>] in ay by XBOOLE_0:def 3;
      hence (the Arity of L).((the connectives of L).(n+i))
      = <*the program-sort of L,the formula-sort of L*> by A51,FUNCT_1:1;
      w+^i in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}
      by A50,ENUMSET1:def 7; then
A52:  w+^i in {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8} \/
      [:{the carrier' of J},{1,2},X:] by XBOOLE_0:def 3; then
      [w+^i,00] in r by ZFMISC_1:106;
      then r.(w+^i) = 00 by FUNCT_1:1;
      hence (the ResultSort of L).((the connectives of L).(n+i))
      = the formula-sort of L by A21,A52,A51,FUNCT_4:13;
    end;
    thus L is J-extension
    proof
      set f1 = id the carrier of J;
      set g1 = id the carrier'of J;
      thus dom f1 = the carrier of J & dom g1 = the carrier' of J;
      thus rng f1 c= the carrier of L & rng g1 c= the carrier' of L
      by XBOOLE_1:7;
      the carrier' of J <> {} implies the carrier of J <> {} by INSTALG1:def 1;
      then
A53:   dom the ResultSort of J = the carrier' of J & dom the Arity of J =
      the carrier' of J by FUNCT_2:def 1;
      rng the ResultSort of J c= the carrier of J;
      hence f1*the ResultSort of J = the ResultSort of J by RELAT_1:53
      .= (the ResultSort of L)|the carrier' of J by A17,A21,FUNCT_4:33
      .= (the ResultSort of L)*g1 by RELAT_1:65;
      let o be set, p be Function;
      assume
A54:   o in the carrier' of J;
      then reconsider x = o as Element of the carrier' of J;
      assume
A55:   p = (the Arity of J).o;
      dom the Arity of J = the carrier' of J by FUNCT_2:def 1;
      then reconsider q = p as Element of (the carrier of J)*
      by A55,A54,FUNCT_1:102;
      rng q c= the carrier of J;
      then f1*p = p & g1.x = x by RELAT_1:53;
      hence f1*p = (the Arity of L).(g1.o) by A53,A55,A54,GRFUNC_1:15;
    end;
    thus (i = 0 or ... or i = 8) implies
    (the connectives of L).(n+i) = (sup the carrier' of J)+^i by A23;
    hereby let x be Element of X;
      1 in {1,2} by TARSKI:def 2;
      then [1,x] in [:{1,2},X:] by ZFMISC_1:def 2;
      hence (the quantifiers of L).(1,x) = [the carrier'of J,[1,x]`1,[1,x]`2]
      by A25
      .= [the carrier' of J,1,x];
      2 in {1,2} by TARSKI:def 2;
      then [2,x] in [:{1,2},X:] by ZFMISC_1:def 2;
      hence (the quantifiers of L).(2,x) = [the carrier'of J,[2,x]`1,[2,x]`2]
      by A25
      .= [the carrier' of J,2,x];
    end;
    thus the formula-sort of L = sup the carrier of J &
    the program-sort of L = (sup the carrier of J)+^1 by ORDINAL2:27;
    thus the carrier of L = (the carrier of J) \/
    {the formula-sort of L, the program-sort of L};
    let w be Ordinal; assume w = sup the carrier' of J;
    hence the carrier' of L = (the carrier' of J) \/
    {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}\/
    [:{the carrier' of J},{1,2},X:] by XBOOLE_1:4;
  end;

registration
  let n be non empty natural number;
  let X be non empty set;
  let J be Signature;
  cluster J-extension n PC-correct QC-correct n AL-correct
  for non void non empty strict AlgLangSignature over X;
  existence
  proof
    consider S being strict non void non empty AlgLangSignature over X such
    that
A1: S is n PC-correct QC-correct n AL-correct J-extension and
    (for i st i = 0 or ... or i = 8 holds
    (the connectives of S).(n+i) = (sup the carrier' of J)+^i) &
    (for x being Element of X holds
    (the quantifiers of S).(1,x) = [the carrier' of J,1,x] &
    (the quantifiers of S).(2,x) = [the carrier' of J,2,x]) &
    the formula-sort of S = sup the carrier of J &
    the program-sort of S = (sup the carrier of J)+^1 &
    the carrier of S = (the carrier of J) \/
    {the formula-sort of S, the program-sort of S} &
    for w being Ordinal st w = sup the carrier' of J holds
    the carrier' of S = (the carrier' of J) \/
    {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}\/
    [:{the carrier' of J},{1,2},X:] by Th11;
    take S; thus thesis by A1;
  end;
end;

registration
  let X be non empty set;
  let n be non empty natural number;
  cluster n PC-correct QC-correct n AL-correct
  for non void non empty strict AlgLangSignature over X;
  existence
  proof
    set J = the non empty non void Signature;
    set S = the J-extension n PC-correct QC-correct n AL-correct
    non void non empty strict AlgLangSignature over X;
    take S; thus thesis;
  end;
end;

begin :: Language

definition
  let J be non empty non void Signature;
  let T be MSAlgebra over J;
  mode VariableSet of T -> set means: Def8:
  ex G being GeneratorSet of T st it = Union G;
  existence
  proof
    set G = the GeneratorSet of T;
    take X = Union G, G;
    thus thesis;
  end;
end;

definition
  let J be non empty non void Signature;
  let T be MSAlgebra over J;
  let X be GeneratorSet of T;
  redefine func Union X -> VariableSet of T;
  coherence by Def8;
end;

theorem
  for J being non empty non void Signature
  for T being MSAlgebra over J
  for X being VariableSet of T holds X c= Union the Sorts of T
  proof
    let J be non empty non void Signature;
    let T be MSAlgebra over J;
    let X be VariableSet of T;
    consider G being GeneratorSet of T such that
A1: X = Union G by Def8;
    let x; assume x in X; then
    consider y being object such that
A2: y in dom G & x in G.y by A1,CARD_5:2;
    y in the carrier of J by A2; then
A3: y in dom the Sorts of T by PARTFUN1:def 2;
    G c= the Sorts of T by PBOOLE:def 18; then
    G.y c= (the Sorts of T).y by A2;
    hence thesis by A2,A3,CARD_5:2;
  end;

definition
  let S be non empty non void Signature;
  let X be ManySortedSet of the carrier of S;
  let T be VarMSAlgebra over S;
  attr T is X-vf-yielding means
  the free-vars of T is ManySortedMSSet of the Sorts of T, X;
end;

definition
  let J be non empty set;
  let Q be ManySortedSet of J;
  let Y be set;
  let f be Function of [:Union Q, Y:],  Union Q;
  attr f is sort-preserving means: Def10:
  for j being Element of J holds f.:[:Q.j, Y:] c= Q.j;
end;

registration
  let J be non empty set;
  let Q be ManySortedSet of J;
  let Y be set;
  cluster sort-preserving for Function of [:Union Q, Y:],  Union Q;
  existence
  proof
    deffunc F(object, object) = (id Union Q).$1 qua set;
A1: for j,y being object st j in Union Q & y in Y holds F(j,y) in Union Q
    by FUNCT_1:17;
    consider F being Function of [:Union Q, Y:], Union Q such that
A2: for j,y being object st j in Union Q & y in Y holds F.(j,y) = F(j,y)
    from BINOP_1:sch 2(A1);
    take F;
    let j be Element of J;
    let x; assume x in F.:[:Q.j, Y:];
    then consider y such that
A3: y in dom F & y in [:Q.j, Y:] & x = F.y by FUNCT_1:def 6;
    consider a,b being object such that
A4: a in Q.j & b in Y & y = [a,b] by A3,ZFMISC_1:def 2;
    dom Q = J by PARTFUN1:def 2;
    then x = F.(a,b) = F(a,b) = a by A2,A3,A4,FUNCT_1:17,CARD_5:2;
    hence x in Q.j by A4;
  end;
end;

definition
  let J be non empty non void Signature;
  let X be ManySortedSet of the carrier of J;
  struct (MSAlgebra over J) SubstMSAlgebra over J,X (#
    Sorts -> (ManySortedSet of the carrier of J),
    Charact -> (ManySortedFunction of (the Sorts)# * the Arity of J,
      the Sorts * the ResultSort of J),
    subst-op -> sort-preserving Function of
      [:Union the Sorts, Union [|X, the Sorts|]:],  Union the Sorts
  #);
end;

theorem Th13:
  for I being set
  for X being ManySortedSet of I
  for S being ManySortedSubset of X
  for x holds S.x is Subset of X.x
  proof
    let I be set;
    let X be ManySortedSet of I;
    let S be ManySortedSubset of X;
    let x;
A1: S c= X by PBOOLE:def 18;
    x in dom S & dom S = I or x nin dom S by PARTFUN1:def 2; then
    S.x c= X.x or S.x = {} by A1,FUNCT_1:def 2;
    hence thesis by XBOOLE_1:2;
  end;

definition
  let J be non empty non void Signature;
  let X be non empty-yielding ManySortedSet of the carrier of J;
  let Q be SubstMSAlgebra over J,X such that
A1: X is ManySortedSubset of the Sorts of Q;
  let x be Element of Union X;
A2: x in Union X c= Union the Sorts of Q by A1,PBOOLE:def 18,MSAFREE4:1;
  func @(x,Q) -> Element of Union the Sorts of Q equals x;
  coherence by A2;
end;

definition
  let J be non empty non void Signature;
  let X be non empty-yielding ManySortedSet of the carrier of J;
  let Q be SubstMSAlgebra over J,X such that
A1: X is ManySortedSubset of the Sorts of Q;
  let j be SortSymbol of J such that
A2:(the Sorts of Q).j <> {};
  let A be Element of Q,j;
  let x be Element of Union X;
  let y be Element of Union X;
  given a being SortSymbol of J such that
A3: x in X.a & y in X.a;
  func A/(x,y) -> Element of Q,j equals: Def12: (the subst-op of Q).[A,[x,y]];
  coherence
  proof
    X.a is Subset of (the Sorts of Q).a by A1,Th13; then
A4: [x,y] in [:X.a, (the Sorts of Q).a:] by A3,ZFMISC_1:87;
A5: [|X, the Sorts of Q|].a = [:X.a, (the Sorts of Q).a:] by PBOOLE:def 16;
    dom [|X, the Sorts of Q|] = the carrier of J by PARTFUN1:def 2; then
A6: [x,y] in Union [|X, the Sorts of Q|] by A4,A5,CARD_5:2; then
A7: (the Sorts of Q).j is non empty &
    [A,[x,y]] in [:(the Sorts of Q).j, Union [|X, the Sorts of Q|]:]
    by A2,ZFMISC_1:87;
    dom the Sorts of Q = the carrier of J by PARTFUN1:def 2;
    then
A8: A in Union the Sorts of Q by A2,CARD_5:2;
    then [A,[x,y]] in [:Union the Sorts of Q, Union [|X, the Sorts of Q|]:]
    by A6,ZFMISC_1:87;
    then [A,[x,y]] in dom the subst-op of Q by A8,FUNCT_2:def 1;
    then (the subst-op of Q).[A,[x,y]] in
    (the subst-op of Q).:[:(the Sorts of Q).j, Union [|X, the Sorts of Q|]:]
    c= (the Sorts of Q).j by Def10,A7,FUNCT_1:def 6;
    hence thesis;
  end;
end;

definition
  let J be non empty non void Signature;
  let X be non empty-yielding ManySortedSet of the carrier of J;
  let Q be SubstMSAlgebra over J,X;
  let j be SortSymbol of J;
  let A be Element of Q,j such that
A1: (the Sorts of Q).j <> {};
  let x be Element of Union X;
  let t be Element of Union the Sorts of Q;
  given a be SortSymbol of J such that
A2: x in X.a & t in (the Sorts of Q).a;
  func A/(x,t) -> Element of Q,j equals: Def13: (the subst-op of Q).[A,[x,t]];
  coherence
  proof
A3: [x,t] in [:X.a, (the Sorts of Q).a:] by A2,ZFMISC_1:87;
A4: [|X, the Sorts of Q|].a = [:X.a, (the Sorts of Q).a:] by PBOOLE:def 16;
    dom [|X, the Sorts of Q|] = the carrier of J by PARTFUN1:def 2; then
A5: [x,t] in Union [|X, the Sorts of Q|] by A3,A4,CARD_5:2; then
A6: (the Sorts of Q).j is non empty &
    [A,[x,t]] in [:(the Sorts of Q).j, Union [|X, the Sorts of Q|]:]
    by A1,ZFMISC_1:87;
    dom the Sorts of Q = the carrier of J by PARTFUN1:def 2;
    then
A7: A in Union the Sorts of Q by A1,CARD_5:2;
    then [A,[x,t]] in [:Union the Sorts of Q, Union [|X, the Sorts of Q|]:]
    by A5,ZFMISC_1:87;
    then [A,[x,t]] in dom the subst-op of Q by A7,FUNCT_2:def 1;
    then (the subst-op of Q).[A,[x,t]] in
    (the subst-op of Q).:[:(the Sorts of Q).j, Union [|X, the Sorts of Q|]:]
    c= (the Sorts of Q).j by Def10,A6,FUNCT_1:def 6;
    hence thesis;
  end;
end;

registration
  let J be non empty non void ManySortedSign;
  let X be ManySortedSet of the carrier of J;
  cluster non-empty for SubstMSAlgebra over J,X;
  existence
  proof
    set Q = the non-empty MSAlgebra over J;
    set s = the sort-preserving Function of
    [:Union the Sorts of Q, Union [|X, the Sorts of Q|] :],
    Union the Sorts of Q;
    take K = SubstMSAlgebra(#the Sorts of Q, the Charact of Q, s#);
    thus the Sorts of K is non-empty;
  end;
end;

definition
  let J be non empty non void Signature;
  let X be non empty-yielding ManySortedSet of the carrier of J;
  let Q be non-empty SubstMSAlgebra over J,X;
  let o be OperSymbol of J;
  let p be Element of Args(o,Q);
  let x be Element of Union X;
  let y be Element of Union the Sorts of Q;
  func p/(x,y) -> Element of Args(o,Q) means: Def14:
  for i being Nat st i in dom the_arity_of o
  ex j being SortSymbol of J st j = (the_arity_of o).i &
  ex A being Element of Q,j st A = p.i & it.i = A/(x,y);
  existence
  proof
    deffunc F(object) =
    In(p.$1, (the Sorts of Q).((the_arity_of o)/.$1))/(x,y);
    consider q being Function such that
A1: dom q = dom the_arity_of o &
    for x st x in dom the_arity_of o holds q.x = F(x) from FUNCT_1:sch 3;
    dom q = Seg len the_arity_of o by A1,FINSEQ_1:def 3;
    then reconsider q as FinSequence by FINSEQ_1:def 2;
A2: len q = len the_arity_of o by A1,FINSEQ_3:29;
    now let k be Nat; assume
A3:   k in dom q;
      q.k = F(k) by A1,A3;
      hence q.k in (the Sorts of Q).((the_arity_of o)/.k);
    end;
    then reconsider q as Element of Args(o,Q) by A2,MSAFREE2:5;
    take q;
    let i be Nat; assume
A4: i in dom the_arity_of o;
    take j = (the_arity_of o)/.i;
    thus
    j = (the_arity_of o).i by A4,PARTFUN1:def 6;
    take A = In(p.i, (the Sorts of Q).j);
    thus A = p.i by A4,MSUALG_6:2,SUBSET_1:def 8;
    thus q.i = A/(x,y) by A4,A1;
  end;
  uniqueness
  proof
    let q1,q2 be Element of Args(o,Q) such that
A5: for i being Nat st i in dom the_arity_of o
    ex j being SortSymbol of J st j = (the_arity_of o).i &
    ex A being Element of Q,j st A = p.i & q1.i = A/(x,y) and
A6: for i being Nat st i in dom the_arity_of o
    ex j being SortSymbol of J st j = (the_arity_of o).i &
    ex A being Element of Q,j st A = p.i & q2.i = A/(x,y);
A7: dom q1 = dom the_arity_of o & dom q2 = dom the_arity_of o by MSUALG_6:2;
    hence dom q1 = dom q2;
    let z be object; assume
A8: z in dom q1; then reconsider i = z as Nat;
    consider j1 being SortSymbol of J such that
A9: j1 = (the_arity_of o).i &
    ex A being Element of Q,j1 st A = p.i & q1.i = A/(x,y) by A5,A7,A8;
    consider j2 being SortSymbol of J such that
A10: j2 = (the_arity_of o).i &
    ex A being Element of Q,j2 st A = p.i & q2.i = A/(x,y) by A6,A7,A8;
    thus q1.z = q2.z by A9,A10;
  end;
end;

definition
  let I be non empty set;
  let X be non-empty ManySortedSet of I;
  let S be non-empty ManySortedSubset of X;
  let x be Element of I;
  let z be Element of S.x;
  func @z -> Element of X.x equals z;
  coherence
  proof
    S c= X by PBOOLE:def 18; then
    z in S.x & S.x c= X.x & S.x is non empty;
    hence thesis;
  end;
end;

definition
  let J be non empty non void Signature;
  let X be non empty-yielding ManySortedSet of the carrier of J;
  let Q be non-empty SubstMSAlgebra over J,X;
  attr Q is subst-correct means
  for x being Element of Union X
  for a being SortSymbol of J st x in X.a holds
  (for j being SortSymbol of J for A being Element of Q,j holds A/(x,x) = A) &
  for y being Element of Union the Sorts of Q st y in (the Sorts of Q).a
  for o being OperSymbol of J
  for p being Element of Args(o,Q)
  for A being Element of Q, the_result_sort_of o
  st A = Den(o,Q).p holds
  not (ex S being QCLangSignature over Union X st J = S &
  ex z being (Element of Union X), q being Element of {1,2} st
  o = (the quantifiers of S).(q,z))
  implies A/(x,y) = Den(o,Q).(p/(x,y));
  attr Q is subst-correct2 means
  for j being SortSymbol of J for q being Element of Q,j,
  t being Element of Q,j for x being Element of Union X st t = x in X.j
  holds t/(x,q) = q;
end;

theorem Th14:
  for J being non empty non void Signature
  for X being non empty-yielding ManySortedSet of the carrier of J
  for Q being SubstMSAlgebra over J,X
  st X is ManySortedSubset of the Sorts of Q
  for a being SortSymbol of J st (the Sorts of Q).a <> {}
  for A being Element of Q,a
  for x,y being Element of Union X
  for t being Element of Union the Sorts of Q st y = t
  for j being SortSymbol of J st x in X.j & y in X.j
  holds A/(x,y) = A/(x,t)
  proof
    let J be non empty non void Signature;
    let X be non empty-yielding ManySortedSet of the carrier of J;
    let Q be SubstMSAlgebra over J,X;
    assume A1: X is ManySortedSubset of the Sorts of Q;
    let a be SortSymbol of J;
    assume A2: (the Sorts of Q).a <> {};
    let A be Element of Q,a;
    let x,y be Element of Union X;
    let t be Element of Union the Sorts of Q;
    assume A3: y = t;
    let j be SortSymbol of J;
    assume A4: x in X.j;
    assume A5: y in X.j;
A6: X.j is Subset of (the Sorts of Q).j by A1,Th13;
    thus A/(x,y) = (the subst-op of Q).[A,[x,y]] by A1,A2,A4,A5,Def12
    .= A/(x,t) by A6,A5,A3,A4,A2,Def13;
  end;

registration
  let J be non void Signature;
  cluster J-extension -> non void non empty for Signature;
  coherence
  proof
    let S be Signature;
    assume J is Subsignature of S;
    then the carrier of J c= the carrier of S &
    the carrier' of J c= the carrier' of S by INSTALG1:10;
    hence the carrier' of S is non empty &
    the carrier of S is non empty;
  end;
end;

registration
  let J be Signature;
  cluster J-extension for non empty non void Signature;
  existence
  proof
    set n = the non empty natural number;
    set X = the non empty set;
    set S = the J-extension n PC-correct QC-correct n AL-correct
    non void non empty strict AlgLangSignature over X;
    take S; thus thesis;
  end;
  let X be non empty set;
  cluster J-extension for non empty non void QCLangSignature over X;
  existence
  proof
    set n = the non empty natural number;
    set S = the J-extension n PC-correct QC-correct n AL-correct
    non void non empty strict AlgLangSignature over X;
    take S; thus thesis;
  end;
  let n be non empty natural number;
  cluster J-extension for non empty non void n PC-correct QC-correct
  QCLangSignature over X;
  existence
  proof
    set S = the J-extension n PC-correct QC-correct n AL-correct
    non void non empty strict AlgLangSignature over X;
    take S; thus thesis;
  end;
end;

definition
  let J be Signature;
  let X be non empty set;
  let n be non empty Nat;
  let S be J-extension n PC-correct feasible AlgLangSignature over X;
  attr S is essential means: Def16:
  (the connectives of S).:(n+9 \ n) misses the carrier' of J &
  rng the quantifiers of S misses the carrier' of J &
  {the formula-sort of S, the program-sort of S} misses the carrier of J;
end;

registration
  let n be non empty natural number;
  let X be non empty set;
  let J be Signature;
  cluster essential for J-extension n PC-correct QC-correct n AL-correct
  non void non empty strict AlgLangSignature over X;
  existence
  proof
    set w = sup the carrier' of J;
    deffunc c(ConnectivesSignature) = the connectives of $1;
    defpred P[Nat,ConnectivesSignature] means c($2).(n+$1) = w+^$1;
    consider S being strict non void non empty AlgLangSignature over X such
    that
A1: S is n PC-correct QC-correct n AL-correct J-extension and
A2: (for i st i = 0 or ... or i = 8 holds
    (the connectives of S).(n+i) = (sup the carrier' of J)+^i) and
::     (the connectives of S).(n+0) = (sup the carrier' of J)+^0 & ... &
::     (the connectives of S).(n+8) = (sup the carrier' of J)+^8 and
:: daje blad 1217
A3: (for x being Element of X holds
    (the quantifiers of S).(1,x) = [the carrier' of J,1,x] &
    (the quantifiers of S).(2,x) = [the carrier' of J,2,x]) &
    the formula-sort of S = sup the carrier of J &
    the program-sort of S = (sup the carrier of J)+^1 and
    the carrier of S = (the carrier of J) \/
    {the formula-sort of S, the program-sort of S} &
    for w being Ordinal st w = sup the carrier' of J holds
    the carrier' of S = (the carrier' of J) \/
    {w+^0,w+^1,w+^2,w+^3,w+^4,w+^5,w+^6,w+^7,w+^8}\/
    [:{the carrier' of J},{1,2},X:] by Th11;
    reconsider S as J-extension n PC-correct QC-correct n AL-correct
    non void non empty strict AlgLangSignature over X by A1;
    take S;
    set c = the connectives of S;
    thus (the connectives of S).:(n+9 \ n) misses the carrier' of J
    proof assume (the connectives of S).:(n+9 \ n) meets the carrier' of J;
      then consider x such that
A4:   x in c.:(n+9 \ n) & x in the carrier' of J
      by XBOOLE_0:3;
      consider k being object such that
A5:   k in dom c & k in n+9 \ n & x = c.k by A4,FUNCT_1:def 6;
      reconsider k as Nat by A5;
      set k1 = k-'n;
A6:   k in Segm (n+9) & k nin n by A5,XBOOLE_0:def 5;
      then Segm n c= Segm k by ORDINAL1:16;
      then n <= k < n+8+1 by A6,NAT_1:44;
      then n <= k <= n+8 by NAT_1:13;
      then
A7:   n+0 <= n+k1 <= n+8 & k = n+k1 by XREAL_1:235;
      then 0 <= k1 <= 8 by XREAL_1:6;
      then 0 = k1 or ... or 8 = k1;
      then c.k = w+^k1 by A2,A7;
      then w+^k1 in w = w+^0 by A4,A5,ORDINAL2:19,27;
      hence thesis by ORDINAL3:22;
    end;
    thus rng the quantifiers of S misses the carrier' of J
    proof assume
      rng the quantifiers of S meets the carrier' of J;
      then consider x such that
A8:   x in rng the quantifiers of S & x in the carrier' of J by XBOOLE_0:3;
      consider y such that
A9:   y in dom the quantifiers of S & x = (the quantifiers of S).y
      by A8,FUNCT_1:def 3;
      dom the quantifiers of S = [:the quant-sort of S, X:] by FUNCT_2:def 1
      .= [:{1,2},X:] by Def5;
      then consider i,z being object such that
A10:   i in {1,2} & z in X & y = [i,z] by A9,ZFMISC_1:def 2;
      i = 1 or i = 2 by A10,TARSKI:def 2;
      then x = (the quantifiers of S).(i,z) = [the carrier' of J,i,z]
      by A9,A10,A3;
      then the carrier' of J in {the carrier' of J} in {{the carrier' of J,i},
      {the carrier' of J}} in {[the carrier' of J,i]}
      in (the quantifiers of S).(i,z) = x in the carrier' of J
      by A8,TARSKI:def 1,def 2;
      hence thesis by XREGULAR:9;
    end;
    assume
    {the formula-sort of S, the program-sort of S} meets the carrier of J;
    then consider x such that
A11: x in {the formula-sort of S, the program-sort of S} &
     x in the carrier of J by XBOOLE_0:3;
    x = the formula-sort of S or x = the program-sort of S by A11,TARSKI:def 2;
    then sup the carrier of J in sup the carrier of J or
    (sup the carrier of J)+^1 in sup the carrier of J by A3,A11,ORDINAL2:19;
    then (sup the carrier of J)+^1 in (sup the carrier of J)+^0 by ORDINAL2:27;
    hence thesis by ORDINAL3:22;
  end;
end;

registration
  let J be non empty Signature;
  let S be J-extension non empty Signature;
  let X be non empty-yielding ManySortedSet of the carrier of J;
  cluster X-tolerating for non empty-yielding
  ManySortedSet of the carrier of S;
  existence
  proof
    set Y = X extended_by ({}, the carrier of S);
    consider x such that
A1: x in the carrier of J & X.x is non empty by PBOOLE:def 12;
    Y is non empty-yielding
    proof
      take x;
      J is Subsignature of S by Def2;
      then
A2:   the carrier of J c= the carrier of S by INSTALG1:10;
      hence x in the carrier of S by A1;
      x in dom X by A1,PARTFUN1:def 2;
      then x in dom (X|the carrier of S) by A2,RELAT_1:57;
      then Y.x = (X|the carrier of S).x by FUNCT_4:13
      .= X.x by A1,A2,FUNCT_1:49;
      hence Y.x is non empty by A1;
    end;
    hence thesis;
  end;
end;

definition
  let J be non empty Signature;
  let S be non empty Signature;
  let T be MSAlgebra over J;
  let Q be MSAlgebra over S;
  attr Q is T-extension means: Def17:
  Q|J = the MSAlgebra of T;
end;

theorem Th15:
  for J being non empty non void Signature
  for S being J-extension Signature
  for T being MSAlgebra over J
  for Q1,Q2 being MSAlgebra over S
  st the MSAlgebra of Q1 = the MSAlgebra of Q2
  holds Q1 is T-extension implies Q2 is T-extension
  proof
    let J be non empty non void Signature;
    let S be J-extension Signature;
A1: J is Subsignature of S by Def2;
    let T be MSAlgebra over J;
    let Q1,Q2 be MSAlgebra over S; assume
A2: the MSAlgebra of Q1 = the MSAlgebra of Q2;
    assume
A3: Q1|J = the MSAlgebra of T;
    Q1|J = Q1|(J, id the carrier of J, id the carrier' of J) &
    Q2|J = Q2|(J, id the carrier of J, id the carrier' of J)
    by INSTALG1:def 4;
    hence Q2|J = the MSAlgebra of T by A3,A1,A2,INSTALG1:def 2,21;
  end;

theorem Th16:
  for J being non empty non void Signature
  for S being J-extension Signature
  for T being MSAlgebra over J
  for Q being MSAlgebra over S st Q is T-extension
  for x st x in the carrier of J holds (the Sorts of T).x = (the Sorts of Q).x
  proof
    let J be non empty non void Signature;
    let S be J-extension Signature;
    J is Subsignature of S by Def2;
    then
A1: id the carrier of J, id the carrier' of J form_morphism_between J,S
    by INSTALG1:def 2;
    let T be MSAlgebra over J;
    let Q be MSAlgebra over S; assume
A2: Q|J = the MSAlgebra of T;
    Q|J = Q|(J, id the carrier of J, id the carrier' of J)
    by INSTALG1:def 4;
    then
A3: the Sorts of T = (the Sorts of Q)*(id the carrier of J) &
    dom id the carrier of J = the carrier of J by A1,A2,INSTALG1:def 3;
    let x; assume
A4: x in the carrier of J;
    hence (the Sorts of T).x = (the Sorts of Q).((id the carrier of J).x)
    by A3,FUNCT_1:13
    .= (the Sorts of Q).x by A4,FUNCT_1:17;
  end;

theorem Th17:
  for J being non empty non void Signature
  for S being J-extension Signature
  for T being MSAlgebra over J
  for I being set st I c= (the carrier of S)\the carrier of J
  for X being ManySortedSet of I
  ex Q being MSAlgebra over S st Q is T-extension & (the Sorts of Q)|I = X
  proof
    let J be non empty non void Signature;
    let S be J-extension Signature;
    let T be MSAlgebra over J;
    let I be set; assume
A1: I c= (the carrier of S)\the carrier of J;
    let X be ManySortedSet of I;
    set U = (the ManySortedSet of the carrier of S)+*(the Sorts of T)+*X;
A2: J is Subsignature of S by Def2;
    dom U = dom ((the ManySortedSet of the carrier of S)+*(the Sorts of T))\/
    dom X by FUNCT_4:def 1
    .= dom (the ManySortedSet of the carrier of S) \/ dom (the Sorts of T) \/
    dom X by FUNCT_4:def 1
    .= dom (the ManySortedSet of the carrier of S) \/ dom (the Sorts of T) \/ I
    by PARTFUN1:def 2
    .= dom (the ManySortedSet of the carrier of S) \/ (the carrier of J) \/ I
    by PARTFUN1:def 2
    .= (the carrier of S)\/(the carrier of J)\/I by PARTFUN1:def 2
    .= (the carrier of S) \/ I by A2,INSTALG1:10,XBOOLE_1:12
    .= the carrier of S by A1,XBOOLE_1:1,XBOOLE_1:12;
    then reconsider U as ManySortedSet of the carrier of S
    by RELAT_1:def 18,PARTFUN1:def 2;
    set C = (the ManySortedFunction of U#*the Arity of S,
    U*the ResultSort of S)+*the Charact of T;
    dom C = (dom the ManySortedFunction of U#*the Arity of S,
    U*the ResultSort of S)\/ dom the Charact of T by FUNCT_4:def 1
    .= (the carrier' of S) \/ dom the Charact of T by PARTFUN1:def 2
    .= (the carrier' of S) \/ the carrier' of J by PARTFUN1:def 2
    .= the carrier' of S by A2,INSTALG1:10,XBOOLE_1:12;
    then reconsider C as ManySortedSet of the carrier' of S
    by RELAT_1:def 18,PARTFUN1:def 2;
A3: dom X = I misses the carrier of J by A1,XBOOLE_1:63,79,PARTFUN1:def 2;
    C is ManySortedFunction of U#*the Arity of S, U*the ResultSort of S
    proof
      let o be object; assume
A4:   o in the carrier' of S;
      then reconsider w = o as OperSymbol of S;
      per cases;
      suppose
A5:     o in the carrier' of J;
        then reconsider u = o as OperSymbol of J;
        o in dom the Charact of T by A5,PARTFUN1:def 2;
        then
A6:     C.o = (the Charact of T).o by FUNCT_4:13;
        the Arity of J = (the Arity of S)|the carrier' of J &
        the ResultSort of J = (the ResultSort of S)|the carrier' of J
        by A2,INSTALG1:12;
        then
A7:     (the Arity of J).o = (the Arity of S).o &
        (the ResultSort of J).o = (the ResultSort of S).o by A5,FUNCT_1:49;
A8:    (the Sorts of T)#.the_arity_of u
        = product ((the Sorts of T)*the_arity_of u) &
        U#.the_arity_of w = product (U*the_arity_of w) by FINSEQ_2:def 5;
A9:    dom the Sorts of T = the carrier of J &
        rng the_arity_of u c= the carrier of J
        by PARTFUN1:def 2;
        U*the_arity_of w
        = ((the ManySortedSet of the carrier of S)+*(the Sorts of T))*
        the_arity_of w by A3,A7,A9,XBOOLE_1:63,FUNCT_7:11
        .= (the Sorts of T)*the_arity_of u by A9,A7,AOFA_I00:3;
        then
A10:    (the Sorts of T)#.the_arity_of u = U#.the_arity_of w by A8;
A11:    rng the ResultSort of S c= the carrier of S &
        rng the ResultSort of J c= the carrier of J &
        the carrier of J = dom the Sorts of T
        by PARTFUN1:def 2;
        rng the ResultSort of J misses dom X by A3,XBOOLE_1:63;
        then
A12:    U*the ResultSort of J = ((the ManySortedSet of the carrier of S)+*
        (the Sorts of T))*the ResultSort of J by FUNCT_7:11
        .= (the Sorts of T)*the ResultSort of J by A11,AOFA_I00:3;
        ((the Sorts of T)#*the Arity of J).o
        = (the Sorts of T)#.the_arity_of u &
        (U#*the Arity of S).o = U#.the_arity_of w &
        ((the Sorts of T)*the ResultSort of S).o
        = (the Sorts of T).((the ResultSort of S).o) &
        ((the Sorts of T)*the ResultSort of J).o
        = (the Sorts of T).((the ResultSort of J).o) &
        (U*the ResultSort of S).o = U.((the ResultSort of S).o) &
        (U*the ResultSort of J).o = U.((the ResultSort of J).o)
        by A4,A5,FUNCT_2:15;
        hence thesis by A6,A7,A10,A12;
      end;
      suppose o nin the carrier' of J;
        then o nin dom the Charact of T;
        then C.o = (the ManySortedFunction of U#*the Arity of S,
        U*the ResultSort of S).o by FUNCT_4:11;
        hence thesis;
      end;
    end;
    then reconsider C as ManySortedFunction of
    U#*the Arity of S, U*the ResultSort of S;
    take Q = MSAlgebra(#U,C#);
    thus Q is T-extension
    proof
A13:  Q|J = Q|(J, id the carrier of J, id the carrier' of J) by INSTALG1:def 4;
      id the carrier of J, id the carrier' of J form_morphism_between J,S
      by A2,INSTALG1:def 2;
      then the Sorts of (Q|J) = (the Sorts of Q)*id the carrier of J &
      the Charact of (Q|J) = (the Charact of Q)*id the carrier' of J
      by A13,INSTALG1:def 3;
      then
A14:   the Sorts of (Q|J) = (the Sorts of Q)|the carrier of J &
      the Charact of (Q|J) = (the Charact of Q)|the carrier' of J
      by RELAT_1:65;
A15:   dom the Sorts of T = the carrier of J &
      dom the Charact of T = the carrier' of J by PARTFUN1:def 2;
      the Sorts of (Q|J) = ((the ManySortedSet of the carrier of S)+*
      (the Sorts of T))|the carrier of J by A3,A14,FUNCT_4:72
      .= the Sorts of T by A15;
      hence Q|J = the MSAlgebra of T by A14,A15;
    end;
    dom X = I by PARTFUN1:def 2;
    hence (the Sorts of Q)|I = X;
  end;

theorem Th18:
  for J being non empty non void Signature
  for S being J-extension Signature
  for T being non-empty MSAlgebra over J
  for I being set st I c= (the carrier of S)\the carrier of J
  for X being non-empty ManySortedSet of I
  ex Q being non-empty MSAlgebra over S st
  Q is T-extension & (the Sorts of Q)|I = X
  proof
    let J be non empty non void Signature;
    let S be J-extension Signature;
    let T be non-empty MSAlgebra over J;
    set K = (the carrier of S)\the carrier of J;
    let I be set; assume
A1: I c= K;
    let X be non-empty ManySortedSet of I;
    set Y = (the non-empty ManySortedSet of K)+*X;
    dom Y = (dom the non-empty ManySortedSet of K)\/dom X by FUNCT_4:def 1
    .= K \/ dom X by PARTFUN1:def 2 .= K \/ I by PARTFUN1:def 2
    .= K by A1,XBOOLE_1:12;
    then reconsider Y as non-empty ManySortedSet of K
    by RELAT_1:def 18,PARTFUN1:def 2;
    consider Q being MSAlgebra over S such that
A2: Q is T-extension & (the Sorts of Q)|K = Y by Th17;
    now
      let x be object; assume
      x in the carrier of S;
      then per cases by XBOOLE_0:def 5;
      suppose
A3:     x in the carrier of J;
        then (the Sorts of Q).x = (the Sorts of T).x by A2,Th16;
        hence (the Sorts of Q).x is non empty by A3;
      end;
      suppose
A4:     x in K;
        then (the Sorts of Q).x = Y.x by A2,FUNCT_1:49;
        hence (the Sorts of Q).x is non empty by A4;
      end;
    end;
    then the Sorts of Q is non-empty;
    then reconsider Q as non-empty MSAlgebra over S by MSUALG_1:def 3;
    take Q; thus Q is T-extension by A2;
A5: dom X = I by PARTFUN1:def 2;
    thus (the Sorts of Q)|I = (the Sorts of Q)|K|I by A1,RELAT_1:74
    .= X by A2,A5;
  end;

registration
  let J be non empty non void Signature;
  let S be J-extension Signature;
  let T be MSAlgebra over J;
  cluster T-extension for MSAlgebra over S;
  existence
  proof
    set Z = the ManySortedSet of {};
    {} c= (the carrier of S)\the carrier of J;
    then consider Q being MSAlgebra over S such that
A1: Q is T-extension & (the Sorts of Q)|{} = Z by Th17;
    take Q; thus thesis by A1;
  end;
end;

registration
  let J be non empty non void Signature;
  let S be J-extension Signature;
  let T be non-empty MSAlgebra over J;
  cluster T-extension for non-empty MSAlgebra over S;
  existence
  proof
    set I = (the carrier of S)\the carrier of J;
    set Z = the non-empty ManySortedSet of I;
    consider Q being MSAlgebra over S such that
A1: Q is T-extension & (the Sorts of Q)|I = Z by Th17;
    now
      let s be object; assume
      s in the carrier of S;
      then per cases by XBOOLE_0:def 5;
      suppose
A2:     s in the carrier of J;
        then (the Sorts of Q).s = (the Sorts of T).s by A1,Th16;
        hence (the Sorts of Q).s is non empty by A2;
      end;
      suppose
A3:     s in I;
        then (the Sorts of Q).s = Z.s by A1,FUNCT_1:49;
        hence (the Sorts of Q).s is non empty by A3;
      end;
    end;
    then the Sorts of Q is non-empty;
    then reconsider Q as non-empty MSAlgebra over S by MSUALG_1:def 3;
    take Q; thus thesis by A1;
  end;
end;

theorem Th19:
  for I being set, a being object holds pr1(I,{a}) is one-to-one
  proof
    let I be set;
    let a be object;
    set f = pr1(I,{a});
    let x,y be object;
    assume
A1: x in dom f & y in dom f;
    then consider i1,a1 being object such that
A2: i1 in I & a1 in {a} & x = [i1,a1] by ZFMISC_1:def 2;
    consider i2,a2 being object such that
A3: i2 in I & a2 in {a} & y = [i2,a2] by A1,ZFMISC_1:def 2;
    assume f.x = f.y;
    then f.(i1,a1) = f.(i2,a2) by A2,A3;
    then
A4: i1 = f.(i2,a2) = i2 by A2,A3,FUNCT_3:def 4;
    a1 = a = a2 by A2,A3,TARSKI:def 1;
    hence x = y by A2,A3,A4;
  end;

theorem Th20:
  for S1,S2,E1,E2 being Signature
  st the ManySortedSign of S1 = the ManySortedSign of S2 &
  the ManySortedSign of E1 = the ManySortedSign of E2 &
  E1 is Extension of S1
  holds E2 is Extension of S2
  proof
    let S1,S2,E1,E2 be Signature;
    assume A1: the ManySortedSign of S1 = the ManySortedSign of S2;
    assume A2: the ManySortedSign of E1 = the ManySortedSign of E2;
    set f = id the carrier of S1, g = id the carrier' of S1;
    assume
A3: dom f = the carrier of S1 & dom g = the carrier' of S1 &
    rng f c= the carrier of E1 & rng g c= the carrier' of E1 &
    f*the ResultSort of S1 = (the ResultSort of E1)*g &
    for o being set, p being Function
    st o in the carrier' of S1 & p = (the Arity of S1).o
    holds f*p = (the Arity of E1).(g.o);
    thus dom id the carrier of S2 = the carrier of S2;
    thus thesis by A1,A2,A3;
  end;

registration
  let I be set;
  let a be object;
  cluster pr1(I,{a}) -> one-to-one;
  coherence by Th19;
end;

definition
  let a,b,c be non empty set;
  let g be Function of a,b;
  let f be Function of b,c;
  redefine func f*g -> Function of a,c;
  coherence
  proof
    dom(f*g) = a & rng(f*g) c= c by FUNCT_2:def 1;
    hence thesis;
  end;
end;

theorem Lem6:
  for f being one-to-one Function st X misses Y
  holds f.:X misses f.:Y
  proof
    let f be one-to-one Function;
    assume Z2: X misses Y;
    assume f.:X meets f.:Y;
    then consider x such that
A1: x in f.:X & x in f.:Y by XBOOLE_0:3;
    consider y such that
A2: y in dom f & y in X & x = f.y by A1,FUNCT_1:def 6;
    consider z being object such that
A3: z in dom f & z in Y & x = f.z by A1,FUNCT_1:def 6;
    y <> z by Z2,A2,A3,XBOOLE_0:3;
    hence contradiction by A3,A2,FUNCT_1:def 4;
  end;

theorem Th21:
  for n being non empty natural number, X being set
  for J being non empty Signature
  ex Q being non empty non void n PC-correct QC-correct
  QCLangSignature over X st
  the carrier of Q misses the carrier of J &
  the carrier' of Q misses the carrier' of J
  proof
    let n be non empty natural number, X be set;
    let J be non empty Signature;
    set Q = the non empty non void n PC-correct QC-correct
    QCLangSignature over X;
    reconsider A = [:the carrier of Q, {the carrier of J}:] as non empty set;
    reconsider B = [:the carrier' of Q, {the carrier' of J}:] as non empty set;
    reconsider f = pr1(the carrier of Q, {the carrier of J}) as
    Function of A, the carrier of Q;
    reconsider g = pr1(the carrier' of Q, {the carrier' of J}) as
    Function of B, the carrier' of Q;
    f is one-to-one & rng f = the carrier of Q by FUNCT_3:44;
    then reconsider f1 = f" as Function of the carrier of Q, A by FUNCT_2:25;
A1: g is one-to-one & rng g = the carrier' of Q by FUNCT_3:44;
    then reconsider g1 = g" as Function of the carrier' of Q, B by FUNCT_2:25;
    deffunc F(object) = f1*In($1,(the carrier of Q)*);
    consider ff being Function such that
A2: dom ff = (the carrier of Q)* &
    for p being object st p in (the carrier of Q)* holds ff.p = F(p)
    from FUNCT_1:sch 3;
    rng ff c= A*
    proof
      let a be object; assume a in rng ff;
      then consider b being object such that
A3:   b in dom ff & a = ff.b by FUNCT_1:def 3;
A4:   a = F(b) by A2,A3;
      F(b) is FinSequence & rng F(b) c= A;
      then F(b) is FinSequence of A by FINSEQ_1:def 4;
      hence thesis by A4,FINSEQ_1:def 11;
    end;
    then reconsider ff as Function of (the carrier of Q)*,A* by A2,FUNCT_2:2;
    reconsider Ar = (ff*(the Arity of Q))*g as Function of B,A*;
    reconsider re = f1*(the ResultSort of Q)*g as Function of B,A;
A5: the formula-sort of Q in the carrier of Q = dom f1 by FUNCT_2:def 1;
    then reconsider fs = (f1.the formula-sort of Q) as (Element of A)
    by FUNCT_1:102;
    rng(g1*the connectives of Q) c= B;
    then reconsider co = (g1*the connectives of Q) as (FinSequence of B)
    by FINSEQ_1:def 4;
    reconsider qu = (g1*the quantifiers of Q) as Function of
    [:the quant-sort of Q, X:], B;
    set QQ = QCLangSignature(#
    A qua non empty set, B qua non empty set, Ar, re, fs, co,
    (the quant-sort of Q) qua set, qu#);
A6: QQ is n PC-correct
    proof
      rng the connectives of Q c= the carrier' of Q = dom g1
      by FUNCT_2:def 1;
      then
A7:   dom the connectives of QQ = dom the connectives of Q
      = Seg len the connectives of Q by RELAT_1:27,FINSEQ_1:def 3;
      then len the connectives of QQ = len the connectives of Q
      by FINSEQ_1:def 3;
      hence len the connectives of QQ >= n+5 by Def4;
      (the connectives of QQ)|{n,n+1,n+2,n+3,n+4,n+5} =
      g1*((the connectives of Q)|{n,n+1,n+2,n+3,n+4,n+5}) &
      g1 is one-to-one & (the connectives of Q)|{n,n+1,n+2,n+3,n+4,n+5}
      is one-to-one by Def4,RELAT_1:83;
      hence (the connectives of QQ)|{n,n+1,n+2,n+3,n+4,n+5} is one-to-one;
      0 < n <= n+5 <= len the connectives of Q by Def4,NAT_1:12;
      then 0+1 <= n <= len the connectives of Q by NAT_1:13,XXREAL_0:2;
      then
A8:   g1.((the connectives of Q).n) = (the connectives of QQ).n in B = dom g &
      (the connectives of Q).n in the carrier' of Q
      by A7,FUNCT_1:13,102,FUNCT_2:def 1,FINSEQ_3:25;
      1 <= n+4+1 = n+5 <= len the connectives of Q by Def4,NAT_1:12;
      then
A9:   g1.((the connectives of Q).(n+5)) = (the connectives of QQ).(n+5) in B
      = dom g & (the connectives of Q).(n+5) in the carrier' of Q
      by A7,FUNCT_1:13,102,FUNCT_2:def 1,FINSEQ_3:25;
A10:  <*the formula-sort of Q*> in (the carrier of Q)* by FINSEQ_1:def 11;
A11:  <*>the carrier of Q in (the carrier of Q)* by FINSEQ_1:def 11;
A12:  (the connectives of Q).n is_of_type
      <*the formula-sort of Q*>, the formula-sort of Q by Def4;
A13:  (the connectives of Q).(n+5) is_of_type
      {}, the formula-sort of Q by Def4;
      thus (the Arity of QQ).((the connectives of QQ).n)
      = (ff*(the Arity of Q)).(g.((the connectives of QQ).n))
      by A8,FUNCT_1:13
      .= ff.((the Arity of Q).(g.((the connectives of QQ).n)))
      by A8,FUNCT_1:102,FUNCT_2:15
      .= ff.<*the formula-sort of Q*> by A12,A1,A8,FUNCT_1:35
      .= f1*In(<*the formula-sort of Q*>,(the carrier of Q)*) by A2,A10
      .= f1*<*the formula-sort of Q*> by A10,SUBSET_1:def 8
      .= <*the formula-sort of QQ*> by A5,FINSEQ_2:34;
      thus (the ResultSort of QQ).((the connectives of QQ).n)
      = (f1*(the ResultSort of Q)).(g.((the connectives of QQ).n))
      by A8,FUNCT_1:13
      .= f1.((the ResultSort of Q).(g.((the connectives of QQ).n)))
      by A8,FUNCT_1:102,FUNCT_2:15
      .= the formula-sort of QQ by A12,A1,A8,FUNCT_1:35;
      thus (the Arity of QQ).((the connectives of QQ).(n+5))
      = (ff*(the Arity of Q)).(g.((the connectives of QQ).(n+5)))
      by A9,FUNCT_1:13
      .= ff.((the Arity of Q).(g.((the connectives of QQ).(n+5))))
      by A9,FUNCT_1:102,FUNCT_2:15
      .= ff.{} by A13,A1,A9,FUNCT_1:35
      .= f1*In({},(the carrier of Q)*) by A2,A11
      .= f1*{} by A11,SUBSET_1:def 8
      .= {};
      thus (the ResultSort of QQ).((the connectives of QQ).(n+5))
      = (f1*(the ResultSort of Q)).(g.((the connectives of QQ).(n+5)))
      by A9,FUNCT_1:13
      .= f1.((the ResultSort of Q).(g.((the connectives of QQ).(n+5))))
      by A9,FUNCT_1:102,FUNCT_2:15
      .= the formula-sort of QQ by A13,A1,A9,FUNCT_1:35;
      ((the connectives of Q).(n+1) is_of_type
      <*the formula-sort of Q, the formula-sort of Q*>,
      the formula-sort of Q
      & ... &
      (the connectives of Q).(n+4) is_of_type
      <*the formula-sort of Q, the formula-sort of Q*>,
      the formula-sort of Q) by Def4;
      then
A14:  ((the Arity of Q).((the connectives of Q).(n+1)) =
      <*the formula-sort of Q, the formula-sort of Q*> &
      (the ResultSort of Q).((the connectives of Q).(n+1)) =
      the formula-sort of Q)
      & ... &
      ((the Arity of Q).((the connectives of Q).(n+4)) =
      <*the formula-sort of Q, the formula-sort of Q*> &
      (the ResultSort of Q).((the connectives of Q).(n+4)) =
      the formula-sort of Q) by AOFA_A00:def 9;
      let i; assume
A15:  1 <= i <= 4;
      then i <= n+i <= n+4 <= n+4+1 = n+5 <= len the connectives of Q
      by Def4,XREAL_1:6,NAT_1:12;
      then 1 <= n+i <= n+5 <= len the connectives of Q by A15,XXREAL_0:2;
      then 1 <= n+i <= len the connectives of Q by XXREAL_0:2;
      then
A16:  g1.((the connectives of Q).(n+i)) = (the connectives of QQ).(n+i) in B
      = dom g & (the connectives of Q).(n+i) in the carrier' of Q
      by A7,FUNCT_1:13,102,FUNCT_2:def 1,FINSEQ_3:25;
A17:   <*the formula-sort of Q,the formula-sort of Q*> in (the carrier of Q)*
      by FINSEQ_1:def 11;
      thus (the Arity of QQ).((the connectives of QQ).(n+i))
      = (ff*(the Arity of Q)).(g.((the connectives of QQ).(n+i)))
      by A16,FUNCT_1:13
      .= ff.((the Arity of Q).(g.((the connectives of QQ).(n+i))))
      by A16,FUNCT_1:102,FUNCT_2:15
      .= ff.((the Arity of Q).((the connectives of Q).(n+i)))
      by A1,A16,FUNCT_1:35
      .= ff.<*the formula-sort of Q,the formula-sort of Q*> by A15,A14
      .= f1*In(<*the formula-sort of Q,the formula-sort of Q*>,
      (the carrier of Q)*) by A2,A17
      .= f1*<*the formula-sort of Q,the formula-sort of Q*>
      by A17,SUBSET_1:def 8
      .= <*the formula-sort of QQ, the formula-sort of QQ*> by FINSEQ_2:36;
      thus (the ResultSort of QQ).((the connectives of QQ).(n+i))
      = (f1*(the ResultSort of Q)).(g.((the connectives of QQ).(n+i)))
      by A16,FUNCT_1:13
      .= f1.((the ResultSort of Q).(g.((the connectives of QQ).(n+i))))
      by A16,FUNCT_1:102,FUNCT_2:15
      .= f1.((the ResultSort of Q).((the connectives of Q).(n+i)))
      by A1,A16,FUNCT_1:35
      .= the formula-sort of QQ by A15,A14;
    end;
    QQ is QC-correct
    proof
      thus the quant-sort of QQ = {1,2} by Def5;
      the quantifiers of Q is one-to-one by Def5;
      hence the quantifiers of QQ is one-to-one;
      rng co = g1.:rng the connectives of Q & dom g1 = the carrier' of Q &
      rng qu = g1.:rng the quantifiers of Q &
      rng the quantifiers of Q misses rng the connectives of Q
      by Def5,RELSET_2:52,FUNCT_2:def 1;
      hence rng the quantifiers of QQ misses rng the connectives of QQ by Lem6;
      let q,x be object; assume
A18:  q in the quant-sort of QQ & x in X;
      then [q,x] in [:the quant-sort of QQ, X:] by ZFMISC_1:87;
      then
A19:  (the quantifiers of Q).(q,x) in the carrier' of Q = dom g1 &
      (the quantifiers of QQ).(q,x) in B = dom g by FUNCT_2:def 1,5;
A20:  <*the formula-sort of Q*> in (the carrier of Q)* by FINSEQ_1:def 11;
A21:  (the quantifiers of Q).(q,x) is_of_type <*the formula-sort of Q*>,
      the formula-sort of Q by A18,Def5;
      thus (the Arity of QQ).((the quantifiers of QQ).(q,x))
      = (ff*(the Arity of Q)).(g.((the quantifiers of QQ).(q,x)))
      by A19,FUNCT_1:13
      .= ff.((the Arity of Q).(g.((the quantifiers of QQ).(q,x))))
      by A19,FUNCT_1:102,FUNCT_2:15
      .= ff.((the Arity of Q).(g.(g1.((the quantifiers of Q).[q,x]))))
      by A18,ZFMISC_1:87,FUNCT_2:15
      .= ff.<*the formula-sort of Q*> by A21,A1,A19,FUNCT_1:35
      .= f1*In(<*the formula-sort of Q*>,
      (the carrier of Q)*) by A2,A20
      .= f1*<*the formula-sort of Q*>
      by A20,SUBSET_1:def 8
      .= <*the formula-sort of QQ*> by FINSEQ_2:35;
      thus (the ResultSort of QQ).((the quantifiers of QQ).(q,x))
      = (f1*(the ResultSort of Q)).(g.((the quantifiers of QQ).(q,x)))
      by A19,FUNCT_1:13
      .= f1.((the ResultSort of Q).(g.((the quantifiers of QQ).(q,x))))
      by A19,FUNCT_1:102,FUNCT_2:15
      .= f1.((the ResultSort of Q).(g.(g1.((the quantifiers of Q).[q,x]))))
      by A18,ZFMISC_1:87,FUNCT_2:15
      .= the formula-sort of QQ by A21,A1,A19,FUNCT_1:35;
    end;
    then reconsider QQ as non empty non void n PC-correct QC-correct
    QCLangSignature over X by A6;
    take QQ;
    thus the carrier of QQ misses the carrier of J
    proof
      assume the carrier of QQ meets the carrier of J;
      then consider a being object such that
A22:   a in the carrier of QQ & a in the carrier of J by XBOOLE_0:3;
      consider b,c being object such that
A23:   b in the carrier of Q & c in {the carrier of J} & a = [b,c]
      by A22,ZFMISC_1:def 2;
      reconsider c as set by TARSKI:1;
      c in {b,c} in {{b,c},{b}} in c by A22,A23,TARSKI:def 1,def 2;
      hence contradiction by XREGULAR:7;
    end;
    thus the carrier' of QQ misses the carrier' of J
    proof
      assume the carrier' of QQ meets the carrier' of J;
      then consider a being object such that
A24:   a in the carrier' of QQ & a in the carrier' of J by XBOOLE_0:3;
      consider b,c being object such that
A25:   b in the carrier' of Q & c in {the carrier' of J} & a = [b,c]
      by A24,ZFMISC_1:def 2;
      reconsider c as set by TARSKI:1;
      c in {b,c} in {{b,c},{b}} in c by A24,A25,TARSKI:def 1,def 2;
      hence contradiction by XREGULAR:7;
    end;
  end;

registration
  let J be non empty Signature;
  cluster J-extension for non empty non void Signature;
  existence
  proof
    reconsider E = (the non empty non void Signature)+*J as
    non empty non void Signature;
    take E;
    E is Extension of J by ALGSPEC1:48;
    hence J is Subsignature of E by ALGSPEC1:def 5;
  end;
  let X be set;
  cluster J-extension for non empty non void QCLangSignature over X;
  existence
  proof set Q = the non empty non void QCLangSignature over X;
    set C = (the carrier of Q)\/the carrier of J;
    set C9 = (the carrier' of Q)\/the carrier' of J;
A1: the carrier' of Q c= C9 & the carrier' of J c= C9 by XBOOLE_1:7;
    (the carrier of Q)* c= C* & (the carrier of J)* c= C*
    by XBOOLE_1:7,FINSEQ_1:62;
    then
A2: (the carrier of Q)*\/(the carrier of J)* c= C*\/C* = C* by XBOOLE_1:13;
    set A = (the Arity of Q)+*the Arity of J;
    (rng the Arity of Q)\/rng the Arity of J
    c= (the carrier of Q)*\/(the carrier of J)* by XBOOLE_1:13;
    then rng A c= (rng the Arity of Q)\/rng the Arity of J c= C* &
    dom the Arity of Q = the carrier' of Q &
    dom the Arity of J = the carrier' of J
    by A2,FUNCT_4:17,FUNCT_2:def 1;
    then dom A = C9 & rng A c= C* by FUNCT_4:def 1;
    then reconsider A as Function of C9,C* by FUNCT_2:2;
    set R = (the ResultSort of Q)+*the ResultSort of J;
    rng R c= (rng the ResultSort of Q)\/rng the ResultSort of J c= C &
    dom the ResultSort of Q = the carrier' of Q &
    dom the ResultSort of J = the carrier' of J
    by XBOOLE_1:13,FUNCT_4:17,FUNCT_2:def 1;
    then dom R = C9 & rng R c= C by FUNCT_4:def 1;
    then reconsider R as Function of C9,C by FUNCT_2:2;
    reconsider f = the formula-sort of Q as Element of C by XBOOLE_0:def 3;
    rng the connectives of Q c= C9 by A1;
    then reconsider c = the connectives of Q as FinSequence of C9
    by FINSEQ_1:def 4;
    rng the quantifiers of Q c= C9 by A1;
    then reconsider q = the quantifiers of Q as
    Function of [:the quant-sort of Q, X:], C9 by FUNCT_2:6;
    reconsider E = QCLangSignature(#
    C, C9, A, R, f, c, the quant-sort of Q, q
    #)
    as non empty non void QCLangSignature over X;
    take E;
A3: Q+*J is Extension of J by ALGSPEC1:48;
    set sE = the ManySortedSign of E;
    sE is non empty &
    the carrier of sE = (the carrier of Q) \/ (the carrier of J) &
    the carrier' of sE = (the carrier' of Q) \/ (the carrier' of J) &
    the Arity of sE = (the Arity of Q) +* (the Arity of J) &
    the ResultSort of sE = (the ResultSort of Q) +* (the ResultSort of J);
    then the ManySortedSign of E = Q+*J &
    the ManySortedSign of J = the ManySortedSign of J by CIRCCOMB:def 2;
    then E is Extension of J by A3,Th20;
    hence J is Subsignature of E by ALGSPEC1:def 5;
  end;
  let n be non empty natural number;
  cluster J-extension for non empty non void n PC-correct QC-correct
  QCLangSignature over X;
  existence
  proof
    consider Q being non empty non void n PC-correct QC-correct
    QCLangSignature over X such that
A4: the carrier of Q misses the carrier of J &
    the carrier' of Q misses the carrier' of J by Th21;
    set C = (the carrier of Q)\/the carrier of J;
    set C9 = (the carrier' of Q)\/the carrier' of J;
A5: the carrier' of Q c= C9 & the carrier' of J c= C9 by XBOOLE_1:7;
    (the carrier of Q)* c= C* & (the carrier of J)* c= C*
    by XBOOLE_1:7,FINSEQ_1:62;
    then
A6: (the carrier of Q)*\/(the carrier of J)* c= C*\/C* = C* by XBOOLE_1:13;
    set A = (the Arity of Q)+*the Arity of J;
    (rng the Arity of Q)\/rng the Arity of J
    c= (the carrier of Q)*\/(the carrier of J)* by XBOOLE_1:13;
    then rng A c= (rng the Arity of Q)\/rng the Arity of J c= C* &
    dom the Arity of Q = the carrier' of Q &
    dom the Arity of J = the carrier' of J
    by A6,FUNCT_4:17,FUNCT_2:def 1;
    then dom A = C9 & rng A c= C* by FUNCT_4:def 1;
    then reconsider A as Function of C9,C* by FUNCT_2:2;
    set R = (the ResultSort of Q)+*the ResultSort of J;
    rng R c= (rng the ResultSort of Q)\/rng the ResultSort of J c= C &
    dom the ResultSort of Q = the carrier' of Q &
    dom the ResultSort of J = the carrier' of J
    by XBOOLE_1:13,FUNCT_4:17,FUNCT_2:def 1;
    then dom R = C9 & rng R c= C by FUNCT_4:def 1;
    then reconsider R as Function of C9,C by FUNCT_2:2;
    reconsider f = the formula-sort of Q as Element of C by XBOOLE_0:def 3;
    rng the connectives of Q c= C9 by A5;
    then reconsider c = the connectives of Q as FinSequence of C9
    by FINSEQ_1:def 4;
    rng the quantifiers of Q c= C9 by A5;
    then reconsider q = the quantifiers of Q as
    Function of [:the quant-sort of Q, X:], C9 by FUNCT_2:6;
    reconsider E = QCLangSignature(#C, C9, A, R, f, c, the quant-sort of Q, q#)
    as non empty non void QCLangSignature over X;
A7: Q+*J is Extension of J & J+*Q is Extension of Q by ALGSPEC1:48;
    set sE = the ManySortedSign of E;
    dom the Arity of J = the carrier' of J &
    dom the Arity of Q = the carrier' of Q &
    dom the ResultSort of J = the carrier' of J &
    dom the ResultSort of Q = the carrier' of Q by FUNCT_2:def 1;
    then sE is non empty &
    the carrier of sE = (the carrier of Q) \/ (the carrier of J) &
    the carrier' of sE = (the carrier' of Q) \/ (the carrier' of J) &
    the Arity of sE = (the Arity of Q) +* (the Arity of J)
    = (the Arity of J) +* the Arity of Q &
    the ResultSort of sE = (the ResultSort of Q) +* (the ResultSort of J)
    = (the ResultSort of J)+*the ResultSort of Q by A4,FUNCT_4:35;
    then the ManySortedSign of E = Q+*J & sE = J+*Q &
    the ManySortedSign of Q = the ManySortedSign of Q &
    the ManySortedSign of J = the ManySortedSign of J by CIRCCOMB:def 2;
    then
A8: E is Extension of J & E is Extension of Q by A7,Th20;
A9: E is n PC-correct
    proof
A10:   len the connectives of Q >= n+5 &
      (the connectives of Q)|{n,n+1,n+2,n+3,n+4,n+5} is one-to-one &
      (the connectives of Q).n is_of_type
      <*the formula-sort of Q*>, the formula-sort of Q &
      (the connectives of Q).(n+5) is_of_type {}, the formula-sort of Q &
      ((the connectives of Q).(n+1) is_of_type
      <*the formula-sort of Q, the formula-sort of Q*>, the formula-sort of Q
      & ... &
      (the connectives of Q).(n+4) is_of_type
      <*the formula-sort of Q, the formula-sort of Q*>, the formula-sort of Q)
      by Def4;
      thus len the connectives of E >= n+5 by Def4;
      thus (the connectives of E)|{n,n+1,n+2,n+3,n+4,n+5} is one-to-one
      by Def4;
      0 < n <= n+5 by NAT_1:12;
      then 0+1 <= n <= len the connectives of Q by A10,XXREAL_0:2,NAT_1:13;
      then n in dom the connectives of Q by FINSEQ_3:25;
      then (the connectives of E).n is OperSymbol of Q by FUNCT_1:102;
      hence (the connectives of E).n is_of_type
      <*the formula-sort of E*>, the formula-sort of E by A10,A8,Th9;
      1 <= n+4+1 = n+5 <= len the connectives of Q by Def4,NAT_1:12;
      then n+5 in dom the connectives of Q by FINSEQ_3:25;
      then (the connectives of E).(n+5) is OperSymbol of Q by FUNCT_1:102;
      hence (the connectives of E).(n+5) is_of_type {}, the formula-sort of E
      by A10,A8,Th9;
      n+1 <= n+1+4 = n+5 & n+1+1 = n+2 <= n+2+3 = n+5 &
      n+2+1 = n+3 <= n+3+2 = n+5 & n+3+1 = n+4 <= n+4+1 = n+5 by NAT_1:12;
      then 1 <= n+1 <= len the connectives of Q & ... &
      1 <= n+4 <= len the connectives of Q by A10,XXREAL_0:2,NAT_1:12;
      then n+1 in dom the connectives of Q & ... &
      n+4 in dom the connectives of Q by FINSEQ_3:25;
      then (the connectives of E).(n+1) is OperSymbol of Q & ... &
      (the connectives of E).(n+4) is OperSymbol of Q by FUNCT_1:102;
      hence ((the connectives of E).(n+1) is_of_type
      <*the formula-sort of E, the formula-sort of E*>, the formula-sort of E
      & ... &
      (the connectives of E).(n+4) is_of_type
      <*the formula-sort of E, the formula-sort of E*>, the formula-sort of E)
      by A10,A8,Th9;
    end;
    E is QC-correct
    proof
      thus the quant-sort of E = {1,2} &  :: { \for, \ex }
      the quantifiers of E is one-to-one by Def5;
      thus rng the quantifiers of E misses rng the connectives of E by Def5;
      let q,x be object such that
A11:   q in the quant-sort of E & x in X;
      [q,x] in [:the quant-sort of Q,X:] by A11,ZFMISC_1:87;
      then (the quantifiers of E).(q,x) is OperSymbol of Q &
      (the quantifiers of Q).(q,x) is_of_type
      <*the formula-sort of Q*>, the formula-sort of Q by Def5,A11,FUNCT_2:5;
      hence (the quantifiers of E).(q,x) is_of_type
      <*the formula-sort of E*>, the formula-sort of E by A8,Th9;
    end;
    then reconsider E as non empty non void n PC-correct QC-correct
    QCLangSignature over X by A9;
    take E;
    thus J is Subsignature of E by A8,ALGSPEC1:def 5;
  end;
end;

definition
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void QCLangSignature over Union X;
  let Y be X-tolerating ManySortedSet of the carrier of S;
  struct (VarMSAlgebra over S,SubstMSAlgebra over S,Y) LanguageStr over T,Y,S
  (#
    Sorts -> ManySortedSet of the carrier of S,
    Charact -> (ManySortedFunction of (the Sorts)# * the Arity of S,
      the Sorts * the ResultSort of S),
    free-vars -> ManySortedMSSet of the Sorts, the Sorts,
:: Function of (the Sorts).the formula-sort of S, Bool X,
    subst-op -> sort-preserving Function of
      [:Union the Sorts, Union [|Y, the Sorts|]:], Union the Sorts,
    equality -> Function of Union [|the Sorts of T, the Sorts of T|],
      (the Sorts).the formula-sort of S
  #);
end;

definition
  let S be non empty PCLangSignature;
  let L be MSAlgebra over S;
  attr L is language means:
Def18:
  (the Sorts of L).the formula-sort of S is not empty;
end;

registration
  let S be non empty PCLangSignature;
  cluster non-empty -> language for MSAlgebra over S;
  coherence;
  cluster language for MSAlgebra over S;
  existence
  proof
    set A = the non-empty MSAlgebra over S;
    take A;
    thus (the Sorts of A).the formula-sort of S is not empty;
  end;
end;

theorem Th22:
  for J being non void Signature
  for S being J-extension non void Signature
  for A1,A2 being MSAlgebra over S st the MSAlgebra of A1 = the MSAlgebra of A2
  holds A1|J = A2|J
  proof
    let J be non void Signature;
    let S be J-extension non void Signature;
    let A1,A2 be MSAlgebra over S such that
A1: the MSAlgebra of A1 = the MSAlgebra of A2;
A2: A1|J = A1|(J, id the carrier of J, id the carrier' of J) &
    A2|J = A2|(J, id the carrier of J, id the carrier' of J) by INSTALG1:def 4;
    J is Subsignature of S by Def2;
    then
    id the carrier of J, id the carrier' of J form_morphism_between J, S
    by INSTALG1:def 2;
    then the Sorts of A1|J = (the Sorts of A1)*id the carrier of J &
    the Sorts of A2|J = (the Sorts of A2)*id the carrier of J &
    the Charact of A1|J = (the Charact of A1)*id the carrier' of J &
    the Charact of A2|J = (the Charact of A2)*id the carrier' of J
    by A2,INSTALG1:def 3;
    hence A1|J = A2|J by A1;
  end;

registration
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void QCLangSignature over Union X;
  cluster X-tolerating for
  non empty-yielding ManySortedSet of the carrier of S;
  existence
  proof
    set Y = the non empty-yielding ManySortedSet of the carrier of S;
A1: J is Subsignature of S by Def2;
    then
A2: the carrier of J c= the carrier of S by INSTALG1:10;
A3: dom X = the carrier of J & dom Y = the carrier of S by PARTFUN1:def 2;
    then
A4: dom Y \/ dom X = the carrier of S by A1,XBOOLE_1:12,INSTALG1:10;
    then dom (Y+*X) = the carrier of S by FUNCT_4:def 1;
    then
    reconsider YX = Y+*X as ManySortedSet of the carrier of S
    by RELAT_1:def 18,PARTFUN1:def 2;
    consider a being object such that
A5: a in the carrier of J & X.a is non empty by PBOOLE:def 12;
    YX is non empty-yielding
    proof take a;
      thus a in the carrier of S by A2,A5;
      thus YX.a is non empty by A2,A3,A5,A4,FUNCT_4:def 1;
    end;
    hence thesis;
  end;
end;

registration
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  cluster non-empty language T-extension
  for LanguageStr over T,Y,S;
  existence
  proof
    set A = the T-extension non-empty MSAlgebra over S;
    set f = the ManySortedMSSet of the Sorts of A, the Sorts of A;
    set g = the sort-preserving Function of [:Union the Sorts of A,
    Union [|Y,the Sorts of A|]:], Union the Sorts of A;
    set eq = the Function of Union [|the Sorts of T, the Sorts of T|],
      (the Sorts of A).the formula-sort of S;
    take L = LanguageStr(#the Sorts of A, the Charact of A, f, g, eq#);
    thus the Sorts of L is non-empty;
    thus (the Sorts of L).the formula-sort of S is not empty;
    the MSAlgebra of L = the MSAlgebra of A;
    hence L|J = A|J by Th22 .= the MSAlgebra of T by Def17;
  end;
end;

definition
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  let L be non-empty LanguageStr over T,Y,S;
  attr L is subst-correct3 means
  for s,s1 being SortSymbol of S
  for t being Element of L,s
  for t1 being Element of L,s1
  for y being Element of Union Y st y in Y.s holds y nin (vf t1).s &
  (y nin (vf t1).s implies t1/(y,t) = t1) &
  (t1 = y in Y.s1 implies t1/(y,t) = t) &
  for x being Element of Union Y st x in Y.s holds t1/(x,y)/(y,x) = t1;
end;

registration
  let J be non empty Signature;
  let S be J-extension non empty Signature;
  let X be non empty-yielding ManySortedSet of the carrier of J;
  let Y be set;
  cluster X extended_by(Y,the carrier of S) -> non empty-yielding;
  coherence
  proof
    consider x such that
A1: x in the carrier of J & X.x is non empty by PBOOLE:def 12;
    take x;
    J is Subsignature of S by Def2;
    then
A2: the carrier of J c= the carrier of S by INSTALG1:10;
    hence x in the carrier of S by A1;
    dom X = the carrier of J by PARTFUN1:def 2;
    then x in dom(X|the carrier of S) by A1,A2,RELAT_1:57;
    then (X extended_by (Y,the carrier of S)).x = (X|the carrier of S).x
    by FUNCT_4:13 .= X.x by A1,A2,FUNCT_1:49;
    hence thesis by A1;
  end;
end;

registration
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void QCLangSignature over Union X;
  cluster X extended_by({},the carrier of S)-vf-yielding non-empty language
  T-extension for LanguageStr over T,X extended_by({},the carrier of S),S;
  existence
  proof
    set A = the T-extension non-empty MSAlgebra over S;
    set f = the ManySortedMSSet of the Sorts of A,
    X extended_by({},the carrier of S);
    f is ManySortedMSSet of the Sorts of A, the Sorts of A
    proof
      let i,a be set; assume i in the carrier of S & a in (the Sorts of A).i;
      then reconsider fia = f.i.a as ManySortedSubset of X extended_by({},
      the carrier of S) by AOFA_A00:def 8;
      fia c= the Sorts of A
      proof
        let y be object; assume
        y in the carrier of S;
        then
A1:     fia.y c= (X extended_by({},the carrier of S)).y by PBOOLE:def 2,def 18;
A2:     J is Subsignature of S by Def2;
        then
A3:     dom X = the carrier of J c= the carrier of S
        by PARTFUN1:def 2,INSTALG1:10;
        then
A4:     X extended_by({},the carrier of S) = ((the carrier of S)-->{})
        +*(X|the carrier of S) = ((the carrier of S)-->{})+*X by RELAT_1:68;
        A|(J, id the carrier of J, id the carrier' of J) = A|J
        = the MSAlgebra of T & id the carrier of J, id the carrier' of J
        form_morphism_between J,S by A2,Def17,INSTALG1:def 2,def 4;
        then
A5:     (the Sorts of A)*id the carrier of J = the Sorts of T
        by INSTALG1:def 3;
        per cases;
        suppose A6: y in the carrier of J;
          (X extended_by({},the carrier of S)).y = X.y
          c= (the Sorts of T).y
          = (the Sorts of A).((id the carrier of J).y) = (the Sorts of A).y
          by A6,A3,A4,A5,FUNCT_4:13,PBOOLE:def 2,def 18,FUNCT_1:17,FUNCT_2:15;
          hence fia.y c= (the Sorts of A).y by A1;
        end;
        suppose y nin the carrier of J;
          then (X extended_by({},the carrier of S)).y
          = ((the carrier of S)-->{}).y by A3,A4,FUNCT_4:11
          .= {};
          hence fia.y c= (the Sorts of A).y by A1;
        end;
      end;
      hence f.i.a is ManySortedSubset of the Sorts of A by PBOOLE:def 18;
    end;
    then reconsider f as ManySortedMSSet of the Sorts of A, the Sorts of A;
    set Y = X extended_by({},the carrier of S);
    set g = the sort-preserving Function of [:Union the Sorts of A,
    Union [|Y,the Sorts of A|]:], Union the Sorts of A;
    set eq = the Function of Union [|the Sorts of T, the Sorts of T|],
      (the Sorts of A).the formula-sort of S;
    take L = LanguageStr(#the Sorts of A, the Charact of A, f, g, eq#);
    thus the free-vars of L is ManySortedMSSet of the Sorts of L,
    X extended_by({},the carrier of S);
    thus the Sorts of L is non-empty;
    thus (the Sorts of L).the formula-sort of S is not empty;
    the MSAlgebra of L = the MSAlgebra of A;
    hence L|J = A|J by Th22 .= the MSAlgebra of T by Def17;
  end;
end;

registration
  let X be set;
  let S be non empty QCLangSignature over X;
  let L be language MSAlgebra over S;
  cluster (the Sorts of L).the formula-sort of S -> non empty;
  coherence by Def18;
end;

definition
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  mode Language of Y,S is language T-extension LanguageStr over T,Y,S;
end;

definition
  let S be non empty PCLangSignature;
  let L be language MSAlgebra over S;
  mode Formula of L is Element of (the Sorts of L).the formula-sort of S;
end;

definition
  let n be non empty natural number;
  let S be non void non empty n PC-correct PCLangSignature;
  let L be language MSAlgebra over S;
  set f = the formula-sort of S;
A1: (the Sorts of L).f <> {} by Def18;
A2: (the connectives of S).n is_of_type <*f*>, f by Def4;
A3: (the connectives of S).(n+5) is_of_type {}, f by Def4;
A4:len the connectives of S >= n+5 by Def4;
  n+1 <= n+5 & ... & n+5 <= n+5 by XREAL_1:6;
  then 1 <= n+1 <= len the connectives of S & ... &
  1 <= n+5 <= len the connectives of S
  by A4,NAT_1:12,XXREAL_0:2; then
A5:n+1 in dom the connectives of S & ... & n+5 in dom the connectives of S
  by FINSEQ_3:25;
A6: (the connectives of S).(n+1) is_of_type <*f,f*>, f & ... &
   (the connectives of S).(n+4) is_of_type <*f,f*>, f by Def4;
A7: (the connectives of S).(n+5) in rng the connectives of S &
   rng the connectives of S c= the carrier' of S
   by A5,FUNCT_1:def 3;
  func \true_L -> Formula of L equals
  Den(In((the connectives of S).(n+5), the carrier' of S), L).{};
  coherence by A1,A3,A7,AOFA_A00:31;
  let A be Formula of L;
  func \notA -> Formula of L equals
  Den(In((the connectives of S).n, the carrier' of S), L).<*A*>;
  coherence by A1,A2,AOFA_A00:32;
  let B be Formula of L;
  func A\andB -> Formula of L equals
  Den(In((the connectives of S).(n+1), the carrier' of S), L).<*A,B*>;
  coherence by A1,A6,AOFA_A00:33;
  func A\orB -> Formula of L equals
  Den(In((the connectives of S).(n+2), the carrier' of S), L).<*A,B*>;
  coherence by A1,A6,AOFA_A00:33;
  func A\impB -> Formula of L equals
  Den(In((the connectives of S).(n+3), the carrier' of S), L).<*A,B*>;
  coherence by A1,A6,AOFA_A00:33;
  func A\iffB -> Formula of L equals
  Den(In((the connectives of S).(n+4), the carrier' of S), L).<*A,B*>;
  coherence by A1,A6,AOFA_A00:33;
end;

registration
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  cluster non empty for VariableSet of T;
  existence
  proof
    set G = the non-empty GeneratorSet of T;
    reconsider X = Union G as VariableSet of T;
    take X; thus thesis;
  end;
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty n PC-correct QC-correct
  QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  let L be Language of Y,S;
  let A be Formula of L;
  let x be Element of Union X;
  set f = the formula-sort of S;
A1: the quant-sort of S = {1,2} by Def5;
   reconsider j = 1 as Element of the quant-sort of S by A1,TARSKI:def 2;
   [j,x] in [:the quant-sort of S,Union X:] by A1,ZFMISC_1:87;
   then
A2: (the quantifiers of S).(1,x) =
   In((the quantifiers of S).(1,x), the carrier' of S) &
   (the quantifiers of S).(1,x) is_of_type <*f*>, f
   by A1,Def5,SUBSET_1:def 8,FUNCT_2:5;
  func \for(x,A) -> Formula of L equals
  Den(In((the quantifiers of S).(1,x), the carrier' of S), L).<*A*>;
  coherence by A2,AOFA_A00:32;
A3: the quant-sort of S = {1,2} by Def5;
   reconsider j = 2 as Element of the quant-sort of S by A3,TARSKI:def 2;
   [j,x] in [:the quant-sort of S,Union X:]
   by A3,ZFMISC_1:87; then
A4: (the quantifiers of S).(2,x) =
   In((the quantifiers of S).(2,x), the carrier' of S) &
   (the quantifiers of S).(2,x) is_of_type <*f*>, f
   by A3,Def5,SUBSET_1:def 8,FUNCT_2:5;
  func \ex(x,A) -> Formula of L equals
  Den(In((the quantifiers of S).(2,x), the carrier' of S), L).<*A*>;
  coherence by A4,AOFA_A00:32;
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty n PC-correct QC-correct
  QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  let L be Language of Y,S;
  let A be Formula of L;
  let x,y be Element of Union X;
  func \for(x,y,A) -> Formula of L equals \for(x,\for(y,A));
  coherence;
  func \ex(x,y,A) -> Formula of L equals \ex(x,\ex(y,A));
  coherence;
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty n PC-correct QC-correct
  QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  let L be Language of Y,S;
  let A be Formula of L;
  let x,y,z be Element of Union X;
  func \for(x,y,z,A) -> Formula of L equals \for(x,y,\for(z,A));
  coherence;
  func \ex(x,y,z,A) -> Formula of L equals \ex(x,y,\ex(z,A));
  coherence;
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty n PC-correct QC-correct
  QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  let L be Language of Y,S;
  let t1,t2 be object;
  given a being SortSymbol of J such that
A1: t1 in (the Sorts of T).a & t2 in (the Sorts of T).a;
  func t1 '=' (t2,L) -> Formula of L equals (the equality of L).(t1,t2);
  coherence
  proof
A2: [t1,t2] in [:(the Sorts of T).a,(the Sorts of T).a:]
    = [|the Sorts of T, the Sorts of T|].a by A1,ZFMISC_1:87,PBOOLE:def 16;
    dom [|the Sorts of T,the Sorts of T|] = the carrier of J by PARTFUN1:def 2;
    then [t1,t2] in Union [|the Sorts of T,the Sorts of T|] by A2,CARD_5:2;
    hence thesis by FUNCT_2:5;
  end;
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty n PC-correct QC-correct
  QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  let L be non-empty Language of Y,S;
  attr L is vf-qc-correct means
  for A,B being Formula of L holds
  vf \notA = vf A & vf(A\andB) = (vf A) (\/) (vf B) &
  vf(A\orB) = (vf A) (\/) (vf B) &
  vf(A\impB) = (vf A) (\/) (vf B) & vf(A\iffB) = (vf A) (\/) (vf B) &
  vf \true_L = EmptyMS the carrier of S &
  for x being Element of Union X
  for a being SortSymbol of S st x in X.a holds
  vf \for(x,A) = (vf A) (\) a-singleton(x) &
  vf \ex(x,A) = (vf A) (\) a-singleton(x);
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty n PC-correct QC-correct
  QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  let L be non-empty T-extension Language of Y,S;
  attr L is vf-finite means
  for s being SortSymbol of S, t being Element of L,s
  holds vf t is finite-yielding;
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty n PC-correct QC-correct
  QCLangSignature over Union X;
  let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
  let L be non-empty T-extension Language of Y,S;
  attr L is subst-forex means
  for A being  Formula of L
  for x being Element of Union X
  for s,s1 being SortSymbol of S
  for t being Element of L,s st x in X.s1
  for y being Element of Union Y st y in Y.s holds
  (x = y implies \for(x,A)/(y,t) = \for(x,A) & \ex(x,A)/(y,t) = \ex(x,A)) &
  (x <> y & x in (vf t).s1 implies
  ex z being (Element of Union X), x0,z0 being Element of Union Y
  st x = x0 & z0 = z = the Element of X.s1\(vf t).s1\(vf A).s1 &
  \for(x,A)/(y,t) = \for(z,A/(x0,z0)/(y,t)) &
  \ex(x,A)/(y,t) = \ex(z,A/(x0,z0)/(y,t))) &
  (x <> y & x nin (vf t).s implies \for(x,A)/(y,t) = \for(x,A/(y,t)) &
  \ex(x,A)/(y,t) = \ex(x,A/(y,t)));
end;

theorem Th23:
  for J being non void Signature
  for T being MSAlgebra over J
  for X being ManySortedSubset of the Sorts of T
  for S being J-extension non void Signature
  for Q being T-extension MSAlgebra over S holds
  X extended_by ({}, the carrier of S) is ManySortedSubset of the Sorts of Q
  proof
    let J be non void Signature;
    let T be MSAlgebra over J;
    let X be ManySortedSubset of the Sorts of T;
    let S be J-extension non void Signature;
    let Q be T-extension MSAlgebra over S;
    let x;
    assume
A1: x in the carrier of S;
    then reconsider s = x as SortSymbol of S;
    per cases;
    suppose
A2:   s in the carrier of J;
      then s in dom X by PARTFUN1:def 2;
      then s in dom(X|the carrier of S) by RELAT_1:57;
      then
A3:   (X extended_by ({}, the carrier of S)).x = (X|the carrier of S).x
      by FUNCT_4:13 .= X.x by A1,FUNCT_1:49;
      X.x c= (the Sorts of T).x by A2,PBOOLE:def 18,def 2;
      hence (X extended_by ({}, the carrier of S)).x c= (the Sorts of Q).x
      by A2,A3,Th16;
    end;
    suppose
A4:   s nin the carrier of J;
A5:   J is Subsignature of S by Def2;
      dom (X|the carrier of S) = (dom X)/\the carrier of S by RELAT_1:61
      .= (the carrier of J) /\ the carrier of S by PARTFUN1:def 2
      .= the carrier of J by A5,XBOOLE_1:28,INSTALG1:10;
      then (X extended_by ({}, the carrier of S)).x
      = ((the carrier of S)-->{}).x by A4,FUNCT_4:11
      .= {};
      hence (X extended_by ({}, the carrier of S)).x c= (the Sorts of Q).x;
    end;
  end;

theorem Th24:
  for J being non void Signature
  for T being MSAlgebra over J
  for X being ManySortedSubset of the Sorts of T
  for S being J-extension non void Signature holds
  Union (X extended_by ({},the carrier of S)) = Union X
  proof
    let J be non void Signature;
    let T be MSAlgebra over J;
    let X be ManySortedSubset of the Sorts of T;
    let S be J-extension non void Signature;
    set Y = X extended_by ({},the carrier of S);
A1: J is Subsignature of S by Def2;
    dom X = the carrier of J by PARTFUN1:def 2;
    then
A2: X|the carrier of S = X by A1,RELAT_1:68,INSTALG1:10;
    then rng Y c= rng ((the carrier of S)-->{}) \/ rng X by FUNCT_4:17;
    then Union Y c= union({{}} \/ rng X) = union{{}} \/ Union X = {} \/ Union X
    by ZFMISC_1:77,78;
    hence Union Y c= Union X;
    X c= Y by A2,FUNCT_4:25;
    hence Union X c= Union Y by RELAT_1:11,ZFMISC_1:77;
  end;

theorem Th25:
  for n being non empty natural number
  for X being non empty set
  for S being non empty non void n PC-correct QC-correct
  QCLangSignature over X
  for Q being language MSAlgebra over S holds
  {} in Args(In((the connectives of S).(n+5), the carrier' of S),Q) &
  for A being Formula of Q holds
  <*A*> in Args(In((the connectives of S).n, the carrier' of S),Q) &
  for B being Formula of Q holds
  (<*A,B*> in Args(In((the connectives of S).(n+1), the carrier' of S),Q)
  & ... &
  <*A,B*> in Args(In((the connectives of S).(n+4), the carrier' of S),Q)) &
  for x being Element of X holds
  <*A*> in Args(In((the quantifiers of S).(1,x), the carrier' of S),Q) &
  <*A*> in Args(In((the quantifiers of S).(2,x), the carrier' of S),Q)
  proof
    let n be non empty natural number;
    let X be non empty set;
    let S be non empty non void n PC-correct QC-correct
    QCLangSignature over X;
    let Q be language MSAlgebra over S;
    set f = the formula-sort of S;
A1: len the connectives of S >= n+5 by Def4;
    n > 0;
    then
A2: n >= 0+1 by NAT_1:13;
    n+0 <= n+5 & ... & n+4 <= n+5 by XREAL_1:6;
    then (1 <= n+0 & ... & 1 <= n+5) &
    (n+0 <= len the connectives of S & ... &
    n+5 <= len the connectives of S)
    by A1,A2,NAT_1:12,XXREAL_0:2; then
A3: n+0 in dom the connectives of S & ... & n+5 in dom the connectives of S
    by FINSEQ_3:25;
A4: (the connectives of S).(n+0) is_of_type <*f*>, f &
    ((the connectives of S).(n+1) is_of_type <*f,f*>, f & ... &
    (the connectives of S).(n+4) is_of_type <*f,f*>, f) &
    (the connectives of S).(n+5) is_of_type {}, f by Def4;
    In((the connectives of S).(n+5), the carrier' of S) is_of_type {},f
    by A4,A3,FUNCT_1:102,SUBSET_1:def 8;
    hence {} in Args(In((the connectives of S).(n+5), the carrier' of S),Q)
    by Th4;
    let A be Formula of Q;
    In((the connectives of S).(n+0), the carrier' of S) is_of_type <*f*>,f
    by A4,A3,FUNCT_1:102,SUBSET_1:def 8;
    hence <*A*> in Args(In((the connectives of S).n, the carrier' of S),Q)
    by Th5;
    let B be Formula of Q;
    In((the connectives of S).(n+1), the carrier' of S)
    = (the connectives of S).(n+1) & ... &
    In((the connectives of S).(n+4), the carrier' of S)
    = (the connectives of S).(n+4) by A3,FUNCT_1:102,SUBSET_1:def 8;
    then
    In((the connectives of S).(n+1), the carrier' of S) is_of_type <*f,f*>, f
    & ... &
    In((the connectives of S).(n+4), the carrier' of S) is_of_type <*f,f*>, f
    by Def4;
    hence <*A,B*> in Args(In((the connectives of S).(n+1),
    the carrier' of S),Q) & ... &
    <*A,B*> in Args(In((the connectives of S).(n+4), the carrier' of S),Q)
    by Th6;
    let x be Element of X;
    the quant-sort of S = {1,2} by Def5;
    then
A5: 1 in the quant-sort of S & 2 in the quant-sort of S by TARSKI:def 2;
    then [1,x] in [:the quant-sort of S,X:] &
    dom the quantifiers of S = [:the quant-sort of S, X:] &
    [2,x] in [:the quant-sort of S,X:] by FUNCT_2:def 1,ZFMISC_1:def 2;
    then In((the quantifiers of S).(1,x), the carrier' of S)
    = (the quantifiers of S).(1,x) &
    In((the quantifiers of S).(2,x), the carrier' of S)
    = (the quantifiers of S).(2,x) by SUBSET_1:def 8,FUNCT_1:102;
    then In((the quantifiers of S).(1,x), the carrier' of S) is_of_type <*f*>,f
    & In((the quantifiers of S).(2,x), the carrier' of S) is_of_type <*f*>,f
    by A5,Def5;
    hence <*A*> in Args(In((the quantifiers of S).(1,x), the carrier' of S),Q)
    & <*A*> in Args(In((the quantifiers of S).(2,x), the carrier' of S),Q)
    by Th5;
  end;

theorem Th26:
  for n being non empty natural number
  for J being non empty non void Signature
  for T being non-empty MSAlgebra over J
  for X being non empty-yielding GeneratorSet of T
  for S being J-extension non void non empty n PC-correct QC-correct
  QCLangSignature over Union X
  for Y being X-tolerating non empty-yielding ManySortedSet of the carrier of S
  for L being non-empty Language of Y,S
  for x being Element of Union Y
  for t being Element of Union the Sorts of L
  for s being SortSymbol of S
  st x in Y.s & t in (the Sorts of L).s
  holds
  (for a being Element of
  Args(In((the connectives of S).(n+5), the carrier' of S),L) st a = {}
  holds a/(x,t) = {}) &
  for A being Formula of L holds
  (for a being Element of Args(In((the connectives of S).n,
  the carrier' of S),L) st <*A*> = a holds a/(x,t) = <*A/(x,t)*>) &
  for B being Formula of L holds
  ((for a being Element of Args(In((the connectives of S).(n+1),
  the carrier' of S),L) st <*A,B*> = a holds a/(x,t) = <*A/(x,t),B/(x,t)*>)
  & ... &
  (for a being Element of Args(In((the connectives of S).(n+4),
  the carrier' of S),L) st <*A,B*> = a holds a/(x,t) = <*A/(x,t),B/(x,t)*>)) &
  for z being Element of Union X holds
  (for a being Element of Args(In((the quantifiers of S).(1,z),
  the carrier' of S),L) st <*A*> = a holds a/(x,t) = <*A/(x,t)*>) &
  (for a being Element of Args(In((the quantifiers of S).(2,z),
  the carrier' of S),L) st <*A*> = a holds a/(x,t) = <*A/(x,t)*>)
  proof
    let n be non empty natural number;
    let J be non empty non void Signature;
    let T be non-empty MSAlgebra over J;
    let X be non empty-yielding GeneratorSet of T;
    let S be J-extension non void non empty n PC-correct QC-correct
    QCLangSignature over Union X;
    let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
    let L be non-empty Language of Y,S;
    let x be Element of Union Y;
    let t be Element of Union the Sorts of L;
    let s be SortSymbol of S;
    set f = the formula-sort of S;
    assume x in Y.s & t in (the Sorts of L).s;
A1:len the connectives of S >= n+5 by Def4;
    n > 0;
    then
A2: n >= 0+1 by NAT_1:13;
    n+0 <= n+5 & ... & n+4 <= n+5 by XREAL_1:6;
    then (1 <= n+0 & ... & 1 <= n+5) &
    (n+0 <= len the connectives of S & ... &
    n+5 <= len the connectives of S)
    by A1,A2,NAT_1:12,XXREAL_0:2; then
A3: n+0 in dom the connectives of S & ... & n+5 in dom the connectives of S
    by FINSEQ_3:25;
A4: (the connectives of S).(n+0) is_of_type <*f*>, f &
    ((the connectives of S).(n+1) is_of_type <*f,f*>, f & ... &
    (the connectives of S).(n+4) is_of_type <*f,f*>, f) &
    (the connectives of S).(n+5) is_of_type {}, f by Def4;
A5: In((the connectives of S).n, the carrier' of S) is_of_type <*f*>,f &
    (In((the connectives of S).(n+1), the carrier' of S) is_of_type <*f,f*>,f
    & ... &
    In((the connectives of S).(n+4), the carrier' of S) is_of_type <*f,f*>,f) &
    In((the connectives of S).(n+5), the carrier' of S) is_of_type {},f
    by A4,A3,FUNCT_1:102,SUBSET_1:def 8;
    hereby let a be Element of
      Args(In((the connectives of S).(n+5), the carrier' of S),L);
      assume a = {}; then
      dom {}
      = dom the_arity_of In((the connectives of S).(n+5), the carrier' of S)
      = dom (a/(x,t)) by MSUALG_6:2;
      hence a/(x,t) = {};
    end;
    let A be Formula of L;
    hereby set o = In((the connectives of S).n, the carrier' of S);
      let a be Element of Args(o,L);
      assume a = <*A*>; then
A6:   dom a = Seg 1 & a.1 = A & len a = 1 &
      dom a = dom the_arity_of o = dom (a/(x,t))
      by MSUALG_6:2,FINSEQ_1:40,89;
      consider j being SortSymbol of S such that
A7:   j = (the_arity_of o).1 &
      ex A being Element of L,j st A = a.1 & (a/(x,t)).1 = A/(x,t)
      by A6,Def14,FINSEQ_1:1;
      j = f & len (a/(x,t)) = 1 by A5,A6,A7,FINSEQ_1:40,FINSEQ_3:29;
      hence a/(x,t) = <*A/(x,t)*> by A7,A6,FINSEQ_1:40;
    end;
    let B be Formula of L;
    thus
    (for a being Element of Args(In((the connectives of S).(n+1),
    the carrier' of S),L) st <*A,B*> = a holds a/(x,t) = <*A/(x,t),B/(x,t)*>)
    & ... &
    (for a being Element of Args(In((the connectives of S).(n+4),
    the carrier' of S),L) st <*A,B*> = a holds a/(x,t) = <*A/(x,t),B/(x,t)*>)
    proof
      let i; assume
A8:  1 <= i <= 4;
      set o = In((the connectives of S).(n+i), the carrier' of S);
      let a be Element of Args(o,L);
      assume a = <*A,B*>;
      then
A9:  dom a = Seg 2 & a.1 = A & a.2 = B & len a = 2 &
      dom a = dom the_arity_of o = dom (a/(x,t))
      by MSUALG_6:2,FINSEQ_1:44,89;
      consider j1 being SortSymbol of S such that
A10:  j1 = (the_arity_of o).1 &
      ex A being Element of L,j1 st A = a.1 & (a/(x,t)).1 = A/(x,t)
      by A9,Def14,FINSEQ_1:1;
      consider j2 being SortSymbol of S such that
A11:  j2 = (the_arity_of o).2 &
      ex A being Element of L,j2 st A = a.2 & (a/(x,t)).2 = A/(x,t)
      by A9,Def14,FINSEQ_1:1;
      o is_of_type <*f,f*>,f by A8,A5;
      then j1 = f & j2 = f by A10,A11,FINSEQ_1:44;
      hence a/(x,t) = <*A/(x,t),B/(x,t)*>
      by A9,A10,A11,FINSEQ_3:29,FINSEQ_1:44;
    end;
    let z be Element of Union X;
    hereby set o = In((the quantifiers of S).(1,z), the carrier' of S);
      let a be Element of Args(o,L);
      assume a = <*A*>; then
A12:  dom a = Seg 1 & a.1 = A & len a = 1 &
      dom a = dom the_arity_of o = dom (a/(x,t))
      by MSUALG_6:2,FINSEQ_1:40,89;
      consider j being SortSymbol of S such that
A13:  j = (the_arity_of o).1 &
      ex A being Element of L,j st A = a.1 & (a/(x,t)).1 = A/(x,t)
      by A12,Def14,FINSEQ_1:1;
A14:  1 in {1,2} & the quant-sort of S = {1,2} & z in Union X
      by Def5,TARSKI:def 2;
      then [1,z] in [:the quant-sort of S,Union X:] by ZFMISC_1:87;
      then o = (the quantifiers of S).(1,z) by SUBSET_1:def 8,FUNCT_2:5;
      then o is_of_type <*f*>,f by A14,Def5;
      then j = f & len (a/(x,t)) = 1
      by A12,A13,FINSEQ_1:40,FINSEQ_3:29;
      hence a/(x,t) = <*A/(x,t)*> by A13,A12,FINSEQ_1:40;
    end;
    set o = In((the quantifiers of S).(2,z), the carrier' of S);
    let a be Element of Args(o,L);
    assume a = <*A*>; then
A15: Seg 1 = dom a & a.1 = A & len a = 1 &
    dom a = dom the_arity_of o = dom (a/(x,t)) by MSUALG_6:2,FINSEQ_1:40,89;
    consider j being SortSymbol of S such that
A16: j = (the_arity_of o).1 &
    ex A being Element of L,j st A = a.1 & (a/(x,t)).1 = A/(x,t)
    by A15,Def14,FINSEQ_1:1;
A17: 2 in {1,2} & the quant-sort of S = {1,2} & z in Union X
    by Def5,TARSKI:def 2;
    then [2,z] in [:the quant-sort of S,Union X:] by ZFMISC_1:87;
    then o = (the quantifiers of S).(2,z) by SUBSET_1:def 8,FUNCT_2:5;
    then o is_of_type <*f*>,f by A17,Def5;
    then j = f & len (a/(x,t)) = 1 by A15,A16,FINSEQ_1:40,FINSEQ_3:29;
    hence a/(x,t) = <*A/(x,t)*> by A16,A15,FINSEQ_1:40;
  end;

theorem Th27:
  for n being non empty natural number
  for J being non empty non void Signature
  for T being non-empty MSAlgebra over J
  for X being non empty-yielding GeneratorSet of T
  for S being J-extension non empty non void n PC-correct QC-correct
  QCLangSignature over Union X
  for Y being X-tolerating non empty-yielding ManySortedSet of the carrier of S
  for L being non-empty Language of Y,S st L is subst-correct &
  Y is ManySortedSubset of the Sorts of L
  for x,y being Element of Union Y
  for a being SortSymbol of S st x in Y.a & y in Y.a
  for A being Formula of L
  holds (\notA)/(x,y) = \not(A/(x,y)) &
  for B being Formula of L
  holds (A\andB)/(x,y) = (A/(x,y))\and(B/(x,y)) &
  (A\orB)/(x,y) = (A/(x,y))\or(B/(x,y)) &
  (A\impB)/(x,y) = (A/(x,y))\imp(B/(x,y)) &
  (A\iffB)/(x,y) = (A/(x,y))\iff(B/(x,y)) & \true_L/(x,y) = \true_L
  proof
    let n be non empty natural number;
    let J be non empty non void Signature;
    let T be non-empty MSAlgebra over J;
    let X be non empty-yielding GeneratorSet of T;
    let S be J-extension non empty non void n PC-correct QC-correct
    QCLangSignature over Union X;
    let Y be X-tolerating non empty-yielding ManySortedSet of the carrier of S;
    let L be non-empty Language of Y,S such that
A1: L is subst-correct and
A2: Y is ManySortedSubset of the Sorts of L;
    let x,y be Element of Union Y;
    let a be SortSymbol of S such that
A3: x in Y.a & y in Y.a;
    Y c= the Sorts of L by A2,PBOOLE:def 18;
    then Y.a c= (the Sorts of L).a;
    then reconsider t = y as Element of (the Sorts of L).a by A3;
    let A be Formula of L;
    reconsider aa = <*A*> as Element of Args(In((the connectives of S).n,
    the carrier' of S),L) by Th25;
    set f = the formula-sort of S;
B1: now
      let i; assume i in dom the connectives of S;
      then (the connectives of S).i in rng the connectives of S c=
      the carrier' of S by FUNCT_1:def 3;
      then
B7:   In((the connectives of S).i,the carrier' of S)in rng the connectives of S
      by SUBSET_1:def 8;
      let S1 be QCLangSignature over Union Y;
      assume
B5:   S = S1;
      let z be (Element of Union Y), q be Element of {1,2};
      [q,z] in [:{1,2},Union Y:] & the quant-sort of S = {1,2}
      by Def5,ZFMISC_1:87;
      then (the quantifiers of S1).[q,z] in rng the quantifiers of S &
      rng the quantifiers of S misses rng the connectives of S
      by B5,Def5,FUNCT_2:4;
      hence In((the connectives of S).i, the carrier' of S) <>
      (the quantifiers of S1).(q,z) by B7,XBOOLE_0:3;
    end;
A4: len the connectives of S >= n+5 by Def4;
    0 < n <= n+5 by NAT_1:11;
    then 0+1 <= n <= len the connectives of S by A4,NAT_1:13,XXREAL_0:2;
    then
B2: n in dom the connectives of S by FINSEQ_3:25;
    then (the connectives of S).n = In((the connectives of S).n,
    the carrier' of S) &
    (the connectives of S).n is_of_type <*f*>, f
    by SUBSET_1:def 8,Def4,FUNCT_1:102;
    then
A5: aa/(x,t) = <*A/(x,t)*> & the_result_sort_of In((the connectives of S).n,
    the carrier' of S) = the formula-sort of S by A3,Th26;
B3: not (ex S1 being QCLangSignature over Union Y st S = S1 &
    ex z being (Element of Union Y), q being Element of {1,2} st
    In((the connectives of S).n, the carrier' of S) =
    (the quantifiers of S1).(q,z)) by B1,B2;
    thus (\notA)/(x,y) = (\notA)/(x,t) by A3,A2,Th14
    .= \not(A/(x,t)) by A5,A1,A3,B3
    .= \not(A/(x,y)) by A3,A2,Th14;
    let B be Formula of L;
A6: <*A,B*> in Args(In((the connectives of S).(n+1), the carrier' of S),L)
    & ... &
    <*A,B*> in Args(In((the connectives of S).(n+4), the carrier' of S),L)
    by Th25;
A7: (for a being Element of Args(In((the connectives of S).(n+1),
    the carrier' of S),L) st <*A,B*> = a holds a/(x,t) = <*A/(x,t),B/(x,t)*>)
    & ... &
    (for a being Element of Args(In((the connectives of S).(n+4),
    the carrier' of S),L) st <*A,B*> = a holds a/(x,t) = <*A/(x,t),B/(x,t)*>)
    by A3,Th26;
    reconsider a1 = <*A,B*> as Element of Args(In((the connectives of S).(n+1),
    the carrier' of S),L) by A6;
    reconsider a2 = <*A,B*> as Element of Args(In((the connectives of S).(n+2),
    the carrier' of S),L) by A6;
    reconsider a3 = <*A,B*> as Element of Args(In((the connectives of S).(n+3),
    the carrier' of S),L) by A6;
    reconsider a4 = <*A,B*> as Element of Args(In((the connectives of S).(n+4),
    the carrier' of S),L) by A6;
    1 <= n+1 <= n+1+4 by NAT_1:11;
    then 1 <= n+1 <= len the connectives of S by A4,XXREAL_0:2;
    then
B4: n+1 in dom the connectives of S by FINSEQ_3:25;
    then
A8: (the connectives of S).(n+1) = In((the connectives of S).(n+1),
    the carrier' of S) & ((the connectives of S).(n+1) is_of_type <*f,f*>, f
    & ... & (the connectives of S).(n+4) is_of_type <*f,f*>, f)
    by Def4,SUBSET_1:def 8,FUNCT_1:102;
    then In((the connectives of S).(n+1), the carrier' of S)
    is_of_type <*f,f*>, f;
    then
A9: a1/(x,t) = <*A/(x,t),B/(x,t)*> &
    the_result_sort_of In((the connectives of S).(n+1),
    the carrier' of S) = the formula-sort of S by A7;
B3: not (ex S1 being QCLangSignature over Union Y st S = S1 &
    ex z being (Element of Union Y), q being Element of {1,2} st
    In((the connectives of S).(n+1), the carrier' of S) =
    (the quantifiers of S1).(q,z)) by B1,B4;
    thus (A\andB)/(x,y) = (A\andB)/(x,t) by A3,A2,Th14
    .= (A/(x,t))\and(B/(x,t)) by A1,A3,A9,B3
    .= (A/(x,y))\and(B/(x,t)) by A3,A2,Th14
    .= (A/(x,y))\and(B/(x,y)) by A3,A2,Th14;
    1+1 <= n+2 <= n+2+3 by NAT_1:11;
    then 1 <= n+2 <= len the connectives of S by A4,XXREAL_0:2;
    then
B4: n+2 in dom the connectives of S by FINSEQ_3:25;
    then (the connectives of S).(n+2) = In((the connectives of S).(n+2),
    the carrier' of S) & (the connectives of S).(n+2) is_of_type <*f,f*>, f
    by A8,SUBSET_1:def 8,FUNCT_1:102;
    then
A10: a2/(x,t) = <*A/(x,t),B/(x,t)*> &
    the_result_sort_of In((the connectives of S).(n+2),
    the carrier' of S) = the formula-sort of S by A7;
B3: not (ex S1 being QCLangSignature over Union Y st S = S1 &
    ex z being (Element of Union Y), q being Element of {1,2} st
    In((the connectives of S).(n+2), the carrier' of S) =
    (the quantifiers of S1).(q,z)) by B1,B4;
    thus (A\orB)/(x,y) = (A\orB)/(x,t) by A3,A2,Th14
    .= (A/(x,t))\or(B/(x,t)) by A1,A3,A10,B3
    .= (A/(x,y))\or(B/(x,t)) by A3,A2,Th14
    .= (A/(x,y))\or(B/(x,y)) by A3,A2,Th14;
    1 <= n+2+1 <= n+3+2 by NAT_1:11;
    then 1 <= n+3 <= len the connectives of S by A4,XXREAL_0:2;
    then
B4: n+3 in dom the connectives of S by FINSEQ_3:25;
    then (the connectives of S).(n+3) = In((the connectives of S).(n+3),
    the carrier' of S) & (the connectives of S).(n+3) is_of_type <*f,f*>, f
    by A8,SUBSET_1:def 8,FUNCT_1:102;
    then
A11: a3/(x,t) = <*A/(x,t),B/(x,t)*> &
    the_result_sort_of In((the connectives of S).(n+3),
    the carrier' of S) = the formula-sort of S by A7;
B3: not (ex S1 being QCLangSignature over Union Y st S = S1 &
    ex z being (Element of Union Y), q being Element of {1,2} st
    In((the connectives of S).(n+3), the carrier' of S) =
    (the quantifiers of S1).(q,z)) by B1,B4;
    thus (A\impB)/(x,y) = (A\impB)/(x,t) by A3,A2,Th14
    .= (A/(x,t))\imp(B/(x,t)) by A1,A3,A11,B3
    .= (A/(x,y))\imp(B/(x,t)) by A3,A2,Th14
    .= (A/(x,y))\imp(B/(x,y)) by A3,A2,Th14;
    1 <= n+3+1 <= n+4+1 by NAT_1:11;
    then 1 <= n+4 <= len the connectives of S by A4,XXREAL_0:2;
    then
B4: n+4 in dom the connectives of S by FINSEQ_3:25;
    then (the connectives of S).(n+4) = In((the connectives of S).(n+4),
    the carrier' of S) & (the connectives of S).(n+4) is_of_type <*f,f*>, f
    by A8,SUBSET_1:def 8,FUNCT_1:102;
    then
A12: a4/(x,t) = <*A/(x,t),B/(x,t)*> &
    the_result_sort_of In((the connectives of S).(n+4),
    the carrier' of S) = the formula-sort of S by A7;
B3: not (ex S1 being QCLangSignature over Union Y st S = S1 &
    ex z being (Element of Union Y), q being Element of {1,2} st
    In((the connectives of S).(n+4), the carrier' of S) =
    (the quantifiers of S1).(q,z)) by B1,B4;
    thus (A\iffB)/(x,y) = (A\iffB)/(x,t) by A3,A2,Th14
    .= (A/(x,t))\iff(B/(x,t)) by A1,A3,A12,B3
    .= (A/(x,y))\iff(B/(x,t)) by A3,A2,Th14
    .= (A/(x,y))\iff(B/(x,y)) by A3,A2,Th14;
    reconsider ab = {} as Element of Args(In((the connectives of S).(n+5),
    the carrier' of S),L) by Th25;
    1 <= n+4+1 <= n+5 by NAT_1:11;
    then
B4: n+5 in dom the connectives of S by A4,FINSEQ_3:25;
    then (the connectives of S).(n+5) = In((the connectives of S).(n+5),
    the carrier' of S) & (the connectives of S).(n+5) is_of_type {}, f
    by Def4,SUBSET_1:def 8,FUNCT_1:102;
    then
A13: ab/(x,t) = ab & the_result_sort_of In((the connectives of S).(n+5),
    the carrier' of S) = the formula-sort of S by A3,Th26;
B3: not (ex S1 being QCLangSignature over Union Y st S = S1 &
    ex z being (Element of Union Y), q being Element of {1,2} st
    In((the connectives of S).(n+5), the carrier' of S) =
    (the quantifiers of S1).(q,z)) by B1,B4;
    thus \true_L/(x,y) = \true_L/(x,t) by A3,A2,Th14 .= \true_L
    by A1,A3,A13,B3;
  end;

begin :: Algorithmic Theory

definition
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty QCLangSignature over Union X;
  let Y be X-tolerating ManySortedSet of the carrier of S;
  struct (LanguageStr over T,Y,S,ProgramAlgStr over J,T,X)
  BialgebraStr over S,Y (#
    Sorts -> ManySortedSet of the carrier of S,
    Charact -> (ManySortedFunction of (the Sorts)# * the Arity of S,
      the Sorts * the ResultSort of S),
    free-vars -> ManySortedMSSet of the Sorts, the Sorts,
    subst-op -> sort-preserving Function of [:Union the Sorts,
      Union [|Y, the Sorts|]:], Union the Sorts,
    equality -> Function of Union [|the Sorts of T, the Sorts of T|],
      (the Sorts).the formula-sort of S,
    carrier -> set,
    charact -> PFuncFinSequence of the carrier,
    assignments -> (Function of Union [|X, the Sorts of T|], the carrier)
  #);
end;

registration
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  cluster J-extension for non void non empty AlgLangSignature over Union X;
  existence
  proof
    set fs = the Element of the carrier of J;
    set ps = the Element of the carrier of J;
    set co = the FinSequence of the carrier' of J;
    set qs = {1,2};
    set qq = the Function of [:qs, Union X:], the carrier' of J;
    reconsider Q = AlgLangSignature(#the carrier of J, the carrier' of J,
    the Arity of J, the ResultSort of J, fs, ps, co, qs, qq#)
    as non void non empty AlgLangSignature over Union X;
    take Q;
    thus J is Subsignature of Q by INSTALG1:13;
  end;
end;

definition
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty AlgLangSignature over Union X;
  let Y be X-tolerating ManySortedSet of the carrier of S;
  let L be BialgebraStr over S,Y;
  attr L is AL-correct means :Def34:
  the carrier of L = (the Sorts of L).the program-sort of S;
end;

notation
  let S be 1-sorted;
  synonym S is 1s-empty for S is empty;
end;

notation
  let S be UAStr;
  synonym S is ua-non-empty for S is non-empty;
end;

registration
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non void non empty AlgLangSignature over Union X;
  let Y be X-tolerating ManySortedSet of the carrier of S;
  cluster non 1s-empty for strict BialgebraStr over S,Y;
  existence
  proof
    set U = the non empty UAStr;
    set A = the MSAlgebra over S;
    set f = the ManySortedMSSet of the Sorts of A, the Sorts of A;
    set g = the sort-preserving Function of [:Union the Sorts of A,
    Union [|Y, the Sorts of A|]:], Union the Sorts of A;
    set a = the Function of Union [|X, the Sorts of T|], the carrier of U;
    set eq = the Function of Union [|the Sorts of T, the Sorts of T|],
      (the Sorts of A).the formula-sort of S;
    take X = BialgebraStr(#the Sorts of A,the Charact of A, f, g, eq,
    the carrier of U, the charact of U, a#);
    thus the carrier of X is non empty;
  end;
end;

registration
  let n be non empty Nat;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be essential J-extension n PC-correct non void non empty feasible
  AlgLangSignature over Union X;
  let Y be X-tolerating ManySortedSet of the carrier of S;
  cluster non-empty language AL-correct quasi_total partial ua-non-empty
  with_empty-instruction with_catenation with_if-instruction
  with_while-instruction T-extension
  for non 1s-empty strict BialgebraStr over S,Y;
  existence
  proof
    set W = the IfWhileAlgebra;
    set I = {the program-sort of S};
    set p = the program-sort of S;
    set f = the formula-sort of S;
    p in {f,p} & {f,p} misses the carrier of J by Def16,TARSKI:def 2;
    then
    p nin the carrier of J by XBOOLE_0:3;
    then p in (the carrier of S)\the carrier of J by XBOOLE_0:def 5;
    then
    consider Q being non-empty MSAlgebra over S such that
A1: Q is T-extension & (the Sorts of Q)|I = I-->the carrier of W
    by Th18,ZFMISC_1:31;
    set U2 = (the Sorts of Q) qua non-empty ManySortedSet of the carrier of S;
    set C = (the Charact of Q) qua ManySortedFunction of U2#*the Arity of S,
    U2*the ResultSort of S;
    deffunc Z(object,object,object) = {};
    deffunc G(object) = $1`1;
    consider g being Function such that
A2: dom g = [:Union U2,Union [|Y,U2|]:] and
A3: for x st x in [:Union U2,Union [|Y,U2|]:]
    holds g.x = G(x) from FUNCT_1:sch 3;
    rng g c= Union U2
    proof let x; assume x in rng g; then
      consider y such that
A4:   y in dom g & x = g.y by FUNCT_1:def 3;
      consider y1,y2 being object such that
A5:   y1 in Union U2 & y2 in Union [|Y, U2|] &
      y = [y1,y2] by A2,A4,ZFMISC_1:def 2;
      x = [y1,y2]`1 by A5,A2,A3,A4
      .= y1;
      hence thesis by A5;
    end; then
    reconsider g as Function of [:Union U2, Union [|Y, U2|]:], Union U2
    by A2,FUNCT_2:2;
    g is sort-preserving
    proof
      let j be SortSymbol of S;
      let x; assume x in g.:[:U2.j, Union [|Y,U2|]:];
      then consider y such that
A6:   y in dom g & y in [:U2.j, Union [|Y,U2|]:] & x = g.y by FUNCT_1:def 6;
      consider a,b being object such that
A7:   a in U2.j & b in Union [|Y,U2|] & y = [a,b] by A6,ZFMISC_1:def 2;
      x = [a,b]`1 by A3,A6,A7 .= a;
      hence x in U2.j by A7;
    end;
    then reconsider g as sort-preserving Function of
    [:Union U2, Union [|Y, U2|]:], Union U2;
    set a = the Function of Union [|X, the Sorts of T|], the carrier of W;
    set f = the ManySortedMSSet of U2,U2;
    set eq = the Function of Union [|the Sorts of T, the Sorts of T|],
      (U2).the formula-sort of S;
    set A = BialgebraStr(#U2,C,f,g,eq,the carrier of W, the charact of W, a#);
    reconsider A as non 1s-empty strict BialgebraStr over S,Y;
    take A;
    thus the Sorts of A is non-empty;
    thus (the Sorts of A).the formula-sort of S is non empty;
A8: p in I by TARSKI:def 1;
    hence the carrier of A = (I-->the carrier of W).p by FUNCOP_1:7
    .= (the Sorts of A).the program-sort of S by A1,A8,FUNCT_1:49;
    thus the charact of A is quasi_total;
    thus the charact of A is homogeneous;
    thus the charact of A <> {} & the charact of A is non-empty;
    thus 1 in dom the charact of A &
    (the charact of A).1 is 0-ary non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A
    by AOFA_000:def 10;
    thus 2 in dom the charact of A &
    (the charact of A).2 is 2-ary non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A
    by AOFA_000:def 11;
    thus 3 in dom the charact of A &
    (the charact of A).3 is 3-ary non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A
    by AOFA_000:def 12;
    thus 4 in dom the charact of A &
    (the charact of A).4 is 2-ary non empty homogeneous
    quasi_total PartFunc of (the carrier of A)*, the carrier of A
    by AOFA_000:def 13;
    the MSAlgebra of A = the MSAlgebra of Q;
    hence A is T-extension by A1,Th15;
  end;
end;

theorem
  for U1,U2 be preIfWhileAlgebra st the UAStr of U1 = the UAStr of U2
  holds EmptyIns U1 = EmptyIns U2 &
  for I1,J1 being Element of U1
  for I2,J2 being Element of U2 st I1 = I2 & J1 = J2
  holds I1\;J1 = I2\;J2 & while(I1,J1) = while(I2,J2) &
  for C1 being Element of U1
  for C2 being Element of U2 st C1 = C2
  holds if-then-else(C1,I1,J1) = if-then-else(C2,I2,J2);

theorem Th29:
  for U1,U2 be preIfWhileAlgebra st the UAStr of U1 = the UAStr of U2
  holds ElementaryInstructions U1 = ElementaryInstructions U2
  proof
    let U1,U2 be preIfWhileAlgebra;
    assume A1: the UAStr of U1 = the UAStr of U2;
    set Y1 = {I1 \; I2 where I1,I2 is Algorithm of U1: I1 <> I1\;I2 &
    I2 <> I1\;I2};
    set Y2 = {I1 \; I2 where I1,I2 is Algorithm of U2: I1 <> I1\;I2 &
    I2 <> I1\;I2};
A2: Y1 = Y2
    proof
      thus Y1 c= Y2
      proof
        let x; assume x in Y1; then
        consider I1,I2 being Algorithm of U1 such that
A3:     x = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2;
        reconsider I1,I2 as Algorithm of U2 by A1;
        x = I1\;I2 by A1,A3;
        hence thesis by A3;
      end;
      let x; assume x in Y2; then
      consider I1,I2 being Algorithm of U2 such that
A4:   x = I1\;I2 & I1 <> I1\;I2 & I2 <> I1\;I2;
      reconsider I1,I2 as Algorithm of U1 by A1;
      x = I1\;I2 by A1,A4;
      hence thesis by A4;
    end;
    thus ElementaryInstructions U1
    = ElementaryInstructions U2 by A2,A1;
  end;

theorem
  for U1,U2 being Universal_Algebra st the UAStr of U1 = the UAStr of U2
  for S1 being Subset of U1, S2 being Subset of U2 st S1 = S2
  for o1 being operation of U1, o2 being operation of U2 st o1 = o2
  holds S1 is_closed_on o1 implies S2 is_closed_on o2;

theorem Th31:
  for U1,U2 being Universal_Algebra st the UAStr of U1 = the UAStr of U2
  for S1 being Subset of U1, S2 being Subset of U2 st S1 = S2
  holds S1 is opers_closed implies S2 is opers_closed
  proof
    let U1,U2 be Universal_Algebra;
    assume A1: the UAStr of U1 = the UAStr of U2;
    let S1 be Subset of U1;
    let S2 be Subset of U2;
    assume A2: S1 = S2;
    assume
A3: for o be operation of U1 holds S1 is_closed_on o;
    let o be operation of U2;
    reconsider o1 = o as operation of U1 by A1;
    S1 is_closed_on o1 by A3;
    hence thesis by A2;
  end;

theorem Th32:
  for U1,U2 being Universal_Algebra st the UAStr of U1 = the UAStr of U2
  for G being GeneratorSet of U1 holds G is GeneratorSet of U2
  proof
    let U1,U2 be Universal_Algebra;
    assume A1: the UAStr of U1 = the UAStr of U2;
    let G be GeneratorSet of U1;
    reconsider G2 = G as Subset of U2 by A1;
    G2 is GeneratorSet of U2
    proof
      let A be Subset of U2;
      reconsider B = A as Subset of U1 by A1;
      assume A is opers_closed;
      hence thesis by A1,Th31,FREEALG:def 4;
    end;
    hence G is GeneratorSet of U2;
  end;

theorem Th33:
  for U1,U2 be Universal_Algebra st the UAStr of U1 = the UAStr of U2
  holds signature U1 = signature U2
  proof
    let U1,U2 be Universal_Algebra;
    assume A1: the UAStr of U1 = the UAStr of U2;
A2: len signature U2 = len the charact of U1 by A1,UNIALG_1:def 4;
    for i st i in dom signature U2
    for h be homogeneous non empty PartFunc of (the carrier of U1)*,
      the carrier of U1 st h = (the charact of U1).i
      holds (signature U2).i = arity h by A1,UNIALG_1:def 4;
    hence signature U1 = signature U2 by A2,UNIALG_1:def 4;
  end;

registration
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be essential J-extension non void non empty n PC-correct QC-correct
  AlgLangSignature over Union X;
  cluster AL-correct vf-qc-correct vf-correct vf-finite subst-correct
  subst-forex non degenerated well_founded ECIW-strict
  for non-empty quasi_total partial ua-non-empty
  with_empty-instruction with_catenation with_if-instruction
  with_while-instruction language non 1s-empty T-extension BialgebraStr over
  S, X extended_by ({}, the carrier of S);
  existence
  proof
    set Y = X extended_by ({}, the carrier of S);
    set W = the IfWhileAlgebra;
    set I = {the program-sort of S};
    set p = the program-sort of S;
    set f = the formula-sort of S;
    p in {f,p} & {f,p} misses the carrier of J by Def16,TARSKI:def 2;
    then
    p nin the carrier of J by XBOOLE_0:3;
    then p in (the carrier of S)\the carrier of J by XBOOLE_0:def 5;
    then
    consider Q being non-empty MSAlgebra over S such that
A1: Q is T-extension & (the Sorts of Q)|I = I-->the carrier of W
    by Th18,ZFMISC_1:31;
    set U2 = (the Sorts of Q) qua non-empty ManySortedSet of the carrier of S;
    set C = (the Charact of Q) qua ManySortedFunction of U2#*the Arity of S,
    U2*the ResultSort of S;
    deffunc Z(object,object,object) = {};
A2: for s,r being Element of the carrier of S
    for t being Element of U2.s holds
    Z(s,r,t) is Subset of U2.r by XBOOLE_1:2;
    consider f being ManySortedMSSet of U2,U2 such that
A3: for s,r being Element of the carrier of S for t being Element of U2.s
    holds f.s.t.r = Z(s,r,t) from AOFA_A00:sch 1(A2);
    deffunc G(object) = $1`1;
    consider g being Function such that
A4: dom g = [:Union U2,Union [|Y,U2|]:] and
A5: for x st x in [:Union U2,Union [|Y,U2|]:]
    holds g.x = G(x) from FUNCT_1:sch 3;
    rng g c= Union U2
    proof let x; assume x in rng g; then
      consider y such that
A6:   y in dom g & x = g.y by FUNCT_1:def 3;
      consider y1,y2 being object such that
A7:   y1 in Union U2 & y2 in Union [|Y, U2|] &
      y = [y1,y2] by A4,A6,ZFMISC_1:def 2;
      x = [y1,y2]`1 by A7,A4,A5,A6
      .= y1;
      hence thesis by A7;
    end; then
    reconsider g as Function of [:Union U2, Union [|Y, U2|]:], Union U2
    by A4,FUNCT_2:2;
    g is sort-preserving
    proof
      let j be SortSymbol of S;
      let x; assume x in g.:[:U2.j, Union [|Y,U2|]:];
      then consider y such that
A8:   y in dom g & y in [:U2.j, Union [|Y,U2|]:] & x = g.y by FUNCT_1:def 6;
      consider a,b being object such that
A9:   a in U2.j & b in Union [|Y,U2|] & y = [a,b] by A8,ZFMISC_1:def 2;
      x = [a,b]`1 by A5,A8,A9 .= a;
      hence x in U2.j by A9;
    end;
    then reconsider g as sort-preserving Function of
    [:Union U2, Union [|Y, U2|]:], Union U2;
    set a = the Function of Union [|X, the Sorts of T|], the carrier of W;
    set eq = the Function of Union [|the Sorts of T, the Sorts of T|],
      (U2).the formula-sort of S;
    set A = BialgebraStr(#U2,C,f,g,eq, the carrier of W, the charact of W, a#);
    reconsider A as non 1s-empty BialgebraStr over S,Y;
    A is language;
    then reconsider A as language non 1s-empty BialgebraStr over S,Y;
A10: now
      let s be SortSymbol of S;
      let B be Element of (the Sorts of A).s;
      let x,y be Element of Union Y;
      let a be SortSymbol of S; assume
A11:  x in Y.a & y in Y.a;
A12:  Y is ManySortedSubset of the Sorts of Q by A1,Th23;
      then Y.a is Subset of (the Sorts of A).a by Th13; then
A13:  [x,y] in [:Y.a, (the Sorts of A).a:] by A11,ZFMISC_1:87;
A14:  [|Y, the Sorts of A|].a = [:Y.a, (the Sorts of A).a:] by PBOOLE:def 16;
      dom U2 = the carrier of S &
      dom [|Y, the Sorts of A|] = the carrier of S by PARTFUN1:def 2; then
A15:  B in Union U2 & [x,y] in Union [|Y, the Sorts of A|]
      by A13,A14,CARD_5:2;
      thus B/(x,y) = g.[B,[x,y]] by A12,A11,Def12
      .= [B,[x,y]]`1 by A5,A15,ZFMISC_1:87
      .= B;
    end;
A16: now
      let s be SortSymbol of S;
      let B be Element of (the Sorts of A).s;
      let x be Element of Union Y;
      let y be Element of Union the Sorts of A;
      let a be SortSymbol of S; assume
A17:  x in Y.a & y in (the Sorts of A).a; then
A18:  [x,y] in [:Y.a, (the Sorts of A).a:] by ZFMISC_1:87;
A19:  [|Y, the Sorts of A|].a = [:Y.a, (the Sorts of A).a:] by PBOOLE:def 16;
      dom U2 = the carrier of S &
      dom [|Y, the Sorts of A|] = the carrier of S by PARTFUN1:def 2; then
A20:  B in Union U2 & [x,y] in Union [|Y, the Sorts of A|]
      by A18,A19,CARD_5:2;
      thus B/(x,y) = g.[B,[x,y]] by A17,Def13
      .= [B,[x,y]]`1 by A5,A20,ZFMISC_1:87
      .= B;
    end;
A21: the MSAlgebra of A = the MSAlgebra of Q;
    A is non-empty quasi_total partial ua-non-empty
    with_empty-instruction with_catenation with_if-instruction
    with_while-instruction by AOFA_000:def 10,def 11,def 12,def 13;
    then reconsider A as non-empty quasi_total partial ua-non-empty
    with_empty-instruction with_catenation with_if-instruction
    with_while-instruction language non 1s-empty T-extension
    BialgebraStr over S,Y by A21,A1,Th15;
    take A;
A22: p in I by TARSKI:def 1;
    hence the carrier of A = (I-->the carrier of W).p by FUNCOP_1:7
    .= (the Sorts of A).the program-sort of S by A1,A22,FUNCT_1:49;
    thus A is vf-qc-correct
    proof
      let C,B be Formula of A;
A23:  vf C = EmptyMS the carrier of S & vf B = EmptyMS the carrier of S &
      vf \notC = EmptyMS the carrier of S &
      vf(C\andB) = EmptyMS the carrier of S &
      vf(C\orB) = EmptyMS the carrier of S &
      vf(C\impB) = EmptyMS the carrier of S &
      vf(C\iffB) = EmptyMS the carrier of S
      by A3;
      thus vf \notC = vf C & vf(C\andB) = vf C (\/) vf B by A23;
      thus vf(C\orB) = vf C (\/) vf B &
      vf(C\impB) = vf C (\/) vf B & vf(C\iffB) = vf C (\/) vf B by A23;
      thus vf \true_A = EmptyMS the carrier of S
      by A3;
      let x be Element of Union X;
      let a be SortSymbol of S; assume
      x in X.a;
      vf \for(x,C) = EmptyMS the carrier of S &
      vf \ex(x,C) = EmptyMS the carrier of S by A3;
      hence vf \for(x,C) = vf C (\) a-singleton x &
      vf \ex(x,C) = vf C (\) a-singleton x by A23,PBOOLE:60;
    end;
    thus A is vf-correct
    proof
      let o be OperSymbol of S;
      let p be FinSequence; assume p in Args(o,A);
      let b be Element of A, the_result_sort_of o; assume b = Den(o,A).p;
      let s be SortSymbol of S;
      (vf b).s = {} by A3;
      hence thesis;
    end;
    thus A is vf-finite
    proof
      let s be SortSymbol of S, t be Element of A,s;
      let a be object;
      assume a in the carrier of S;
      hence (vf t).a is finite by A3;
    end;
    thus A is subst-correct
    proof
      let x be Element of Union Y;
      let a be SortSymbol of S such that
A24:  x in Y.a;
      thus for j be SortSymbol of S, C be Element of A,j
        holds C/(x,x) = C by A24,A10;
      let y be Element of Union the Sorts of A such that
A25:  y in (the Sorts of A).a;
      let o be OperSymbol of S;
      let p be Element of Args(o,A);
      now let i be Nat; assume
A26:    i in dom the_arity_of o;
        take j = (the_arity_of o)/.i;
        thus j = (the_arity_of o).i by A26,PARTFUN1:def 6;
        take B = In(p.i,(the Sorts of A).j);
        thus B = p.i by A26,MSUALG_6:2,SUBSET_1:def 8;
        hence p.i = B/(x,y) by A24,A25,A16;
      end;
      then
A27:  p/(x,y) = p by Def14;
      let C be Element of A, the_result_sort_of o;
      assume
A28:  C = Den(o,A).p;
      assume not (ex S1 being QCLangSignature over Union Y st S = S1 &
      ex z being (Element of Union Y), q being Element of {1,2} st
      o = (the quantifiers of S1).(q,z));
      thus C/(x,y) = Den(o,A).(p/(x,y)) by A27,A28,A24,A25,A16;
    end;
    thus A is subst-forex
    proof
      let B be Formula of A;
      let x be Element of Union X;
      let s,s1 be SortSymbol of S;
      let t be Element of A,s; assume x in X.s1;
      let y be Element of Union Y; assume
C2:   y in Y.s;
      thus x = y implies \for(x,B)/(y,t) = \for(x,B) &
      \ex(x,B)/(y,t) = \ex(x,B) by C2,A16;
      thus (x <> y & x in (vf t).s1 implies
      ex z being (Element of Union X), x0,z0 being Element of Union Y
      st x = x0 & z0 = z = the Element of X.s1\(vf t).s1\(vf B).s1 &
      \for(x,B)/(y,t) = \for(z,B/(x0,z0)/(y,t)) &
      \ex(x,B)/(y,t) = \ex(z,B/(x0,z0)/(y,t))) by A3;
      assume x <> y & x nin (vf t).s;
      thus \for(x,B)/(y,t) = \for(x,B) by C2,A16 .= \for(x,B/(y,t)) by C2,A16;
      thus \ex(x,B)/(y,t) = \ex(x,B) by C2,A16 .= \ex(x,B/(y,t)) by C2,A16;
    end;
    hereby let I1,I2 be Element of the carrier of A;
      reconsider J1 = I1, J2 = I2 as Element of W;
      EmptyIns A = EmptyIns W & I1\;I2 = J1\;J2;
      hence (I1 <> EmptyIns A implies I1\;I2 <> I2) &
      (I2 <> EmptyIns A implies I1\;I2 <> I1) &
      (I1 <> EmptyIns A or I2 <> EmptyIns A implies I1\;I2 <> EmptyIns A)
      by AOFA_000:def 24;
    end;
    hereby let C,I1,I2 be Element of the carrier of A;
      reconsider C1 = C, J1 = I1, J2 = I2 as Element of W;
      if-then-else(C,I1,I2) = if-then-else(C1,J1,J2) & EmptyIns W = EmptyIns A;
      hence if-then-else(C,I1,I2) <> EmptyIns A by AOFA_000:def 24;
    end;
    hereby let C,I be Element of the carrier of A;
      reconsider C1 = C, J = I as Element of W;
      EmptyIns A = EmptyIns W & while(C,I) = while(C1,J);
      hence while(C,I) <> EmptyIns A by AOFA_000:def 24;
    end;
    hereby let I1,I2,C,J1,J2 be Element of the carrier of A;
      reconsider C1 = C, K1 = I1, K2 = I2, L1 = J1, L2 = J2 as Element of W;
      if-then-else(C,J1,J2) = if-then-else(C1,L1,L2) & I1\;I2 = K1\;K2 &
      EmptyIns W = EmptyIns A;
      hence I1 = EmptyIns A or I2 = EmptyIns A or
      I1\;I2 <> if-then-else(C,J1,J2) by AOFA_000:def 24;
    end;
    hereby let I1,I2,C,J be Element of the carrier of A;
      reconsider C1 = C, K1 = I1, K2 = I2, L = J as Element of W;
      EmptyIns W = EmptyIns A & I1\;I2 = K1\;K2 & while(C,J) = while(C1,L);
      hence I1 <> EmptyIns A & I2 <> EmptyIns A implies I1\;I2 <> while(C,J)
      by AOFA_000:def 24;
    end;
    hereby let C1,I1,I2,C2,J be Element of the carrier of A;
      reconsider C3 = C1, K1 = I1, K2 = I2, C4 = C2, L = J as Element of W;
      while(C2,J) = while(C4,L) &
      if-then-else(C1,I1,I2) = if-then-else(C3,K1,K2);
      hence if-then-else(C1,I1,I2) <> while(C2,J) by AOFA_000:def 24;
    end;
    thus A is well_founded
    proof
A29:   the UAStr of W = the UAStr of A; then
      ElementaryInstructions W = ElementaryInstructions A &
      ElementaryInstructions W is GeneratorSet of W by Th29,AOFA_000:def 25;
      hence ElementaryInstructions A is GeneratorSet of A by A29,Th32;
    end;
    the UAStr of A = the UAStr of W; then
    signature A = signature W by Th33;
    hence signature A = ECIW-signature by AOFA_000:def 27;
  end;
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be essential J-extension non empty non void n PC-correct QC-correct
  n AL-correct AlgLangSignature over Union X;
  mode IfWhileAlgebra of X,S is AL-correct vf-qc-correct vf-correct
  subst-correct subst-forex non degenerated well_founded ECIW-strict
  non-empty quasi_total partial ua-non-empty
  with_empty-instruction with_catenation with_if-instruction
  with_while-instruction language non 1s-empty T-extension BialgebraStr over
  S, X extended_by ({}, the carrier of S);
end;

definition
  let n be non empty Nat;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be essential J-extension non empty non void n PC-correct QC-correct
  n AL-correct AlgLangSignature over Union X;
  let L be IfWhileAlgebra of X,S;
  set f = the formula-sort of S;
  set p = the program-sort of S;
A1: (the connectives of S).(n+6) is_of_type <*p,f*>, f & ... &
  (the connectives of S).(n+8) is_of_type <*p,f*>, f by Def6;
A2: (the Sorts of L).p = the carrier of L by Def34;
  let K be Formula of L;
  let P be Algorithm of L;
  func P*K -> Formula of L equals
  Den(In((the connectives of S).(n+6), the carrier' of S), L).<*P,K*>;
  coherence by A1,A2,AOFA_A00:33;
  func \Cup(P,K) -> Formula of L equals
  Den(In((the connectives of S).(n+7), the carrier' of S), L).<*P,K*>;
  coherence by A1,A2,AOFA_A00:33;
  func \Cap(P,K) -> Formula of L equals
  Den(In((the connectives of S).(n+8), the carrier' of S), L).<*P,K*>;
  coherence by A1,A2,AOFA_A00:33;
end;

definition
  let n be non empty Nat;
  let S be non empty non void n PC-correct PCLangSignature;
  let L be language MSAlgebra over S;
  let F be Subset of (the Sorts of L).the formula-sort of S;
  attr F is PC-closed means :Def38:
  for A,B,C being Formula of L holds
  A\imp(B\impA) in F &
  (A\imp(B\impC))\imp((A\impB)\imp(A\impC)) in F &
  (\notA\imp\notB)\imp(B\impA) in F &
  A\imp(A\orB) in F & A\imp(B\orA) in F &
  (A\impC)\imp((B\impC)\imp((A\orB)\impC)) in F &
  A\andB\impA in F & A\andB\impB in F & A\imp(B\impA\andB) in F &
  A\and\notA\impB in F &
  (A\impB)\imp((A\imp\notB)\imp\notA) in F &
  A\or\notA in F &
  (A\iffB)\imp(A\impB) in F & (A\iffB)\imp(B\impA) in F &
  (A\impB)\and(B\impA)\imp(A\iffB) in F &
  \true_L in F & (\true_L)\andA\iffA in F & (\true_L)\orA\iff\true_L in F &
  (A in F & A\impB in F implies B in F);
end;

definition
  let n be non empty Nat;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void n PC-correct QC-correct
  QCLangSignature over Union X;
  let L be non-empty Language of X extended_by ({},the carrier of S), S;
  let F be Subset of (the Sorts of L).the formula-sort of S;
  attr F is QC-closed means: Def39:
  for A,B being Element of (the Sorts of L).the formula-sort of S
  for x being Element of Union X holds
  (for a being SortSymbol of J holds
  (for t being Element of Union the Sorts of L
  st x in (X extended_by ({}, the carrier of S)).a &
  t in (the Sorts of L).a holds
  for y being Element of Union (X extended_by ({}, the carrier of S)) st x = y
  holds
  \for(x,A)\imp(A/(y,t)) in F) &
  (x in X.a & x nin (vf A).a implies
  \for(x,A\impB)\imp(A\imp\for(x,B)) in F)) &
  \not\ex(x,A)\iff\for(x,\notA) in F &
  \ex(x,\notA)\iff\not\for(x,A) in F &
  (A in F implies \for(x,A) in F);
end;

definition
  let n be non empty Nat;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void n PC-correct QC-correct
  QCLangSignature over Union X;
  let L be non-empty T-extension Language of
  X extended_by ({},the carrier of S), S;
  attr L is subst-eq-correct means
  for x0 being Element of Union (X extended_by({},the carrier of S))
  for s,s1 being SortSymbol of S st x0 in X.s
  for t being Element of L,s, t1,t2 being Element of L,s1
  holds (t1 '=' (t2,L))/(x0,t) = (t1/(x0,t)) '=' (t2/(x0,t),L);
  attr L is vf-eq-correct means
  for s being SortSymbol of S holds
  (for t1,t2 being Element of L,s
  holds vf(t1 '=' (t2,L)) = (vf t1) (\/) (vf t2)) &
  for s being SortSymbol of S
  for t being Element of L,s st t in X.s
  holds vf t = s-singleton t;
  let F be Subset of (the Sorts of L).the formula-sort of S;
  attr F is with_equality means: Def42:
  (for t being Element of T holds t '=' (t,L) in F) &
  for b being SortSymbol of S
  for t1,t2 being Element of L,b
  for x being Element of Union (X extended_by ({},the carrier of S))
  st x in X.b
  holds (for c being SortSymbol of S st c in the carrier of J
  for t being Element of L,c holds
  (t1 '=' (t2,L))\imp(t/(x,t1) '=' (t/(x,t2),L)) in F) &
  for A being Formula of L holds
  (t1 '=' (t2,L))\imp(A/(x,t1)\imp(A/(x,t2))) in F;
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty VarMSAlgebra over J;
  let X be non-empty GeneratorSet of T;
  let S be essential J-extension non empty non void n PC-correct QC-correct
  n AL-correct AlgLangSignature over Union X;
  let L be non 1s-empty IfWhileAlgebra of X,S;
  let V be Formula of L; :: true state test
  let F be Subset of (the Sorts of L).the formula-sort of S;
  attr F is V AL-closed means: Def43:
  for A,B being Formula of L holds
  (for M being Algorithm of L holds
  (M*(A\andB)) \iff (M*A)\and(M*B) in F &
  (M*(A\orB)) \iff (M*A)\or(M*B) in F &
  \Cup(M,A) \iff A\or\Cup(M, M*A) in F &
  \Cap(M,A) \iff A\and\Cap(M, M*A) in F &
  (A\impB in F implies
  \Cup(M,A)\imp\Cup(M,B) in F & \Cap(M,A)\imp\Cap(M,B) in F)) &
  (for a being SortSymbol of J
  for x being Element of X.a
  for x0 being Element of Union (X extended_by ({},the carrier of S))
  st x = x0 holds
  for t being Element of (the Sorts of T).a
  for t1 being Element of Union the Sorts of L st t1 = t holds
  ((x:=(t,L))*A) \iff (A/(x0,t1)) in F &
  (for y being Element of X.a st y nin (vf t).a holds
  for y0 being Element of Union (X extended_by ({},the carrier of S)) st y = y0
  holds ((x:=(t,L))*\ex(x,A)) \iff
  \ex(y, (x:=(t,L))*((y:=(@x,L))*(A/(x0,y0)))) in F) &
  ((x:=(t,L))*A) \imp \ex(x,A) in F) &
  for M,M1,M2 being Algorithm of L holds
  ((M\;M1)*A) \iff (M*(M1*A)) in F &
  (if-then-else(M,M1,M2)*A) \iff
  ((M*V)\and(M*(M1*A)))\or((M*\notV)\and(M*(M2*A))) in F &
  (while(M,M1)*A) \iff
  ((M*\notV)\andA)\or((M*V)\and(M*(M1*(while(M,M1)*A)))) in F;
end;

registration
  let n be non empty Nat;
  let S be non empty non void n PC-correct PCLangSignature;
  let L be language MSAlgebra over S;
  cluster [#]((the Sorts of L).the formula-sort of S) -> PC-closed;
  coherence
  proof
    let A be Formula of L;
    [#]((the Sorts of L).the formula-sort of S) =
    (the Sorts of L).the formula-sort of S &
    (the Sorts of L).the formula-sort of S is non empty
    by Def18,SUBSET_1:def 3;
    hence thesis;
  end;
  cluster PC-closed -> non empty for
  Subset of (the Sorts of L).the formula-sort of S;
  coherence;
  cluster PC-closed for Subset of (the Sorts of L).the formula-sort of S;
  existence
  proof
    take [#]((the Sorts of L).the formula-sort of S); thus thesis;
  end;
end;

registration
  let n be non empty Nat;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void n PC-correct QC-correct
  QCLangSignature over Union X;
  let L be non-empty Language of X extended_by ({}, the carrier of S),S;
  cluster [#]((the Sorts of L).the formula-sort of S) -> QC-closed;
  coherence
  proof
    let A be Element of (the Sorts of L).the formula-sort of S;
    [#]((the Sorts of L).the formula-sort of S) =
    (the Sorts of L).the formula-sort of S by SUBSET_1:def 3;
    hence thesis;
  end;
  cluster QC-closed PC-closed for
  Subset of (the Sorts of L).the formula-sort of S;
  existence
  proof
    take [#]((the Sorts of L).the formula-sort of S); thus thesis;
  end;
end;

registration
  let n be non empty Nat;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S be J-extension non empty non void n PC-correct QC-correct
  QCLangSignature over Union X;
  let L be non-empty T-extension Language of
  X extended_by ({}, the carrier of S),S;
  cluster [#]((the Sorts of L).the formula-sort of S) -> with_equality;
  coherence
  proof
    [#]((the Sorts of L).the formula-sort of S) =
    (the Sorts of L).the formula-sort of S by SUBSET_1:def 3;
    hence thesis;
  end;
  cluster QC-closed PC-closed with_equality for
  Subset of (the Sorts of L).the formula-sort of S;
  existence
  proof
    take [#]((the Sorts of L).the formula-sort of S); thus thesis;
  end;
end;

definition
  let n be non empty Nat;
  let S being non empty non void n PC-correct PCLangSignature;
  let L be language MSAlgebra over S;
  mode PC-theory of L is
  PC-closed Subset of (the Sorts of L).the formula-sort of S;
end;

definition
  let n be non empty Nat;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S being J-extension non empty non void n PC-correct QC-correct
  QCLangSignature over Union X;
  let L be non-empty Language of X extended_by ({}, the carrier of S), S;
  mode QC-theory of L is
  QC-closed PC-closed Subset of (the Sorts of L).the formula-sort of S;
end;

definition
  let n be non empty Nat;
  let J be non empty non void Signature;
  let T be non-empty MSAlgebra over J;
  let X be non empty-yielding GeneratorSet of T;
  let S being J-extension non empty non void n PC-correct QC-correct
  QCLangSignature over Union X;
  let L be non-empty T-extension Language of
  X extended_by ({}, the carrier of S), S;
  mode QC-theory_with_equality of L is
  QC-closed PC-closed with_equality
  Subset of (the Sorts of L).the formula-sort of S;
end;

registration
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty VarMSAlgebra over J;
  let X be non-empty GeneratorSet of T;
  let S be essential J-extension non empty non void n PC-correct QC-correct
  n AL-correct AlgLangSignature over Union X;
  let L be non 1s-empty IfWhileAlgebra of X,S;
  let V be Formula of L;
  cluster V AL-closed for PC-closed QC-closed with_equality
  Subset of (the Sorts of L).the formula-sort of S;
  existence
  proof
    take F = [#]((the Sorts of L).the formula-sort of S);
    let A be Formula of L;
    F = (the Sorts of L).the formula-sort of S by SUBSET_1:def 3;
    hence thesis;
  end;
end;

definition
  let n be non empty natural number;
  let J be non empty non void Signature;
  let T be non-empty VarMSAlgebra over J;
  let X be non-empty GeneratorSet of T;
  let S be essential J-extension non empty non void n PC-correct QC-correct
  n AL-correct AlgLangSignature over Union X;
  let L be non empty IfWhileAlgebra of X,S;
  let V be Formula of L;
  mode AL-theory of V,L is PC-closed QC-closed with_equality V AL-closed
  Subset of (the Sorts of L).the formula-sort of S;
end;

begin :: Propositional Calculus

reserve
  n for non empty Nat,
  S for non empty non void n PC-correct PCLangSignature,
  L for language MSAlgebra over S,
  F for PC-theory of L,
  A,B,C,D for Formula of L;

theorem Th34:
  A\impA in F
  proof
A1: A\imp((A\impA)\impA)\imp(A\imp(A\impA)\imp(A\impA)) in F by Def38;
A2: A\imp((A\impA)\impA) in F by Def38;
A3: A\imp(A\impA)\imp(A\impA) in F by A1,A2,Def38;
A4: A\imp(A\impA) in F by Def38;
    thus thesis by A3,A4,Def38;
  end;

theorem Th35:
  A\andB in F iff A in F & B in F
  proof
    A\andB\impA in F & A\andB\impB in F by Def38;
    hence A\andB in F implies A in F & B in F by Def38;
    A\imp(B\impA\andB) in F by Def38; then
    A in F implies B\imp(A\andB) in F by Def38;
    hence thesis by Def38;
  end;

theorem Th36:
  A\orB\impB\orA in F
  proof
A1: (A\impB\orA)\imp((B\impB\orA)\imp(A\orB\impB\orA)) in F by Def38;
A2: (A\impB\orA) in F & B\impB\orA in F by Def38;
    (B\impB\orA)\imp(A\orB\impB\orA) in F by A1,A2,Def38;
    hence thesis by A2,Def38;
  end;

theorem Th37:
  (B\impC)\imp((A\impB)\imp(A\impC)) in F
proof
A1: ((A\imp(B\impC))\imp((A\impB)\imp(A\impC))) in F by Def38;
A2: ( (B\impC)\imp((A\imp(B\impC))\imp((A\impB)\imp(A\impC))))\imp(((B\impC)
    \imp(A\imp(B\impC)))\imp((B\impC)\imp((A\impB)\imp(A\impC)))) in F
    by Def38;
    ((A\imp(B\impC))\imp((A\impB)\imp(A\impC)))\imp( (B\impC)\imp((A\imp(B
    \impC))\imp((A\impB)\imp(A\impC)))) in F by Def38;
    then
    ( (B\impC)\imp((A\imp(B\impC))\imp((A\impB)\imp(A\impC)))) in F
    by A1,Def38;
    then
A3: ((B\impC)\imp(A\imp(B\impC)))\imp((B\impC)\imp((A\impB)\imp(A\impC))) in F
    by A2,Def38;
    (B\impC)\imp(A\imp(B\impC)) in F by Def38;
    hence thesis by A3,Def38;
  end;

theorem Th38:
  A\imp(B\impC) in F implies B\imp(A\impC) in F
  proof
    assume
A1: A\imp(B\impC) in F;
A2: ((A\impB)\imp(A\impC))\imp((B\imp(A\impB))\imp(B\imp(A\impC))) in F
    by Th37;
    (A\imp(B\impC))\imp((A\impB)\imp(A\impC)) in F by Def38;
    then ((A\impB)\imp(A\impC)) in F by A1,Def38;
    then
A3: ((B\imp(A\impB))\imp(B\imp(A\impC))) in F by A2,Def38;
    B\imp(A\impB) in F by Def38;
    hence thesis by A3,Def38;
  end;

theorem Th39: :: Hypothetical syllogism
  (A\impB)\imp((B\impC)\imp(A\impC)) in F
proof
  (B\impC)\imp((A\impB)\imp(A\impC)) in F by Th37;
  hence thesis by Th38;
end;

theorem
  A\imp(B\imp(A\impB)) in F
  proof
    (B\imp(A\impB))\imp(A\imp(B\imp(A\impB))) in F &
    (B\imp(A\impB)) in F by Def38;
    hence thesis by Def38;
  end;

theorem Th41: :: Contraposition
  (A\imp(B\impC))\imp(B\imp(A\impC)) in F
  proof
A1: B\imp(A\impB) in F by Def38;
    (A\imp(B\impC))\imp((A\impB)\imp(A\impC)) in F by Def38;
    then
A2: (A\impB)\imp((A\imp(B\impC))\imp(A\impC)) in F by Th38;
    ((A\impB)\imp((A\imp(B\impC))\imp(A\impC)))\imp((B\imp(A\impB))\imp(B\imp
    ((A\imp(B\impC))\imp(A\impC)))) in F by Th37;
    then
    (B\imp(A\impB))\imp(B\imp((A\imp(B\impC))\imp(A\impC))) in F by A2,Def38;
    then (B\imp((A\imp(B\impC))\imp(A\impC))) in F by A1,Def38;
    hence thesis by Th38;
  end;

theorem :: Modus ponendo ponens
  B\imp((B\impA)\impA) in F
  proof
A1: ((B\impA)\imp(B\impA))\imp(B\imp((B\impA)\impA)) in F by Th41;
    (B\impA)\imp(B\impA) in F by Th34;
    hence thesis by A1,Def38;
  end;

theorem Th43:
  A\iffB in F iff A\impB in F & B\impA in F
  proof
    (A\iffB)\imp(A\impB) in F & (A\iffB)\imp(B\impA) in F by Def38;
    hence A\iffB in F implies A\impB in F & B\impA in F by Def38;
    assume A\impB in F & B\impA in F;
    then (A\impB)\and(B\impA) in F & (A\impB)\and(B\impA)\imp(A\iffB) in F
    by Def38,Th35;
    hence thesis by Def38;
  end;

theorem Th44:
  B in F implies A\impB in F
proof
  B\imp(A\impB) in F by Def38;
  hence thesis by Def38;
end;

theorem Th45:
  A\impB in F & B\impC in F implies A\impC in F
  proof
    assume that
A1: A\impB in F and
A2: B\impC in F;
    (A\impB)\imp((B\impC)\imp(A\impC)) in F by Th39;
  then (B\impC)\imp(A\impC) in F by A1,Def38;
  hence thesis by A2,Def38;
end;

theorem Th46:
  C\imp(B\impA) in F & B in F implies C\impA in F
  proof
    assume that
A1: C\imp(B\impA) in F and
A2: B in F;
    (C\imp(B\impA))\imp(B\imp(C\impA)) in F by Th41;
    then B\imp(C\impA) in F by A1,Def38;
    hence thesis by A2,Def38;
  end;

theorem Th47:
  (( A\andB )\impC )\imp( A\imp( B\impC )) in F
proof
  set qp = ( B\imp( A\andB ));
  set pr = (( A\andB )\impC)\imp( B\impC );
A1: ( A\imp( qp\imppr ))\imp( ( A\impqp )\imp( A\imppr )) in F by Def38;
A2: A\imp( B\imp( A\andB )) in F by Def38;
  A\imp(( B\imp( A\andB ))\imp((( A\andB )\impC )\imp( B\impC ))) in
  F by Th44,Th39;
  then ( ( A\impqp )\imp( A\imppr )) in F by A1,Def38;
  then
A3: A\imp((( A\andB )\impC )\imp( B\impC )) in F by A2,Def38;
  (A\imp((( A\andB )\impC )\imp( B\impC )))\imp((( A\andB )\impC )\imp(
  A\imp( B\impC ))) in F by Th41;
  hence thesis by A3,Def38;
end;

theorem Th48:
  ( A\imp( B\impC ))\imp(( A\andB )\impC ) in F
proof
A1: (( A\andB )\impB)\imp(( B\impC )\imp(( A\andB )\impC )) in F by
Th39;
  ( A\andB )\impB in F by Def38;
  then ( B\impC )\imp(( A\andB )\impC ) in F by A1,Def38;
  then
A2: A\imp(( B\impC )\imp(( A\andB )\impC )) in F by Th44;
A3: ( A\imp(( A\andB )\impC ))\imp((A\andB )\imp( A\impC )) in F by
Th41;
  A\imp(( B\impC )\imp(( A\andB )\impC ))\imp((A\imp( B\impC ))\imp( A\imp
  (( A\andB )\impC ))) in F by Def38;
  then (A\imp( B\impC ))\imp( A\imp(( A\andB )\impC )) in F by A2,Def38;
  then
A4: (A\imp( B\impC ))\imp((A\andB )\imp( A\impC )) in F by A3,Th45;
A5: ( A\andB )\impA in F by Def38;
  ((A\andB )\imp( A\impC ))\imp((( A\andB )\impA )\imp(( A\andB )\impC
  )) in F by Def38;
  then ((A\andB )\imp( A\impC ))\imp(( A\andB )\impC ) in F by A5,Th46;
  hence thesis by A4,Th45;
end;

theorem Th49:
  ( C\impA )\imp(( C\impB )\imp( C\imp( A\andB ))) in F
  proof
A1: ( C\imp( B\imp( A\andB )))\imp(( C\impB )\imp( C\imp( A\andB ))) in F
    by Def38;
    A\imp( B\imp( A\andB )) in F by Def38;
    then
A2: C\imp( A\imp( B\imp( A\andB ))) in F by Th44;
    (C\imp( A\imp( B\imp( A\andB ))))\imp(( C\impA )\imp( C\imp( B\imp( A
    \andB )))) in F by Def38;
    then ( C\impA )\imp( C\imp( B\imp( A\andB ))) in F by A2,Def38;
    hence thesis by A1,Th45;
  end;

theorem Th50:
  A\andB\impB\andA in F
  proof
    set P = A\andB;
A1: P\impB in F by Def38;
A2: P\impA in F by Def38;
    ( P\impB )\imp(( P\impA )\imp( P\imp( B\andA ))) in F by Th49;
    then ( P\impA )\imp( P\imp( B\andA )) in F by A1,Def38;
    hence thesis by A2,Def38;
  end;

theorem
  (A\iffB)\imp(B\iffA) in F
  proof
A1: (B\impA)\and(A\impB)\imp(B\iffA) in F by Def38;
A2: (A\impB)\and(B\impA)\imp(B\impA)\and(A\impB) in F by Th50;
    (A\impB)\and(B\impA)\imp(B\impA)\and(A\impB)\imp
    (((B\impA)\and(A\impB)\imp(B\iffA))\imp
    ((A\impB)\and(B\impA)\imp(B\iffA))) in F by Th39; then
    (((B\impA)\and(A\impB)\imp(B\iffA))\imp
    ((A\impB)\and(B\impA)\imp(B\iffA))) in F by A2,Def38; then
A3: (A\impB)\and(B\impA)\imp(B\iffA) in F by A1,Def38;
A4: (A\iffB)\imp(A\impB)\imp(((A\iffB)\imp(B\impA))\imp
    ((A\iffB)\imp(A\impB)\and(B\impA))) in F by Th49;
A5: (A\iffB)\imp(A\impB) in F & ((A\iffB)\imp(B\impA)) in F by Def38; then
    (((A\iffB)\imp(B\impA))\imp((A\iffB)\imp(A\impB)\and(B\impA))) in F
    by A4,Def38; then
A6: (A\iffB)\imp(A\impB)\and(B\impA) in F by A5,Def38;
    (A\iffB)\imp(A\impB)\and(B\impA)\imp(((A\impB)\and(B\impA)\imp(B\iffA))\imp
    ((A\iffB)\imp(B\iffA))) in F by Th39; then
    ((A\impB)\and(B\impA)\imp(B\iffA))\imp((A\iffB)\imp(B\iffA)) in F
    by A6,Def38;
    hence thesis by A3,Def38;
  end;

theorem Th52:
  A\orA\impA in F
  proof
A1: A\impA\imp(A\impA\imp(A\orA\impA)) in F by Def38;
A2: A\impA in F by Th34;
    then A\impA\imp(A\orA\impA) in F by A1,Def38;
    hence thesis by A2,Def38;
  end;

theorem Th53:
  A\impA\andA in F
  proof
A1: A\impA\imp(A\impA\imp(A\impA\andA)) in F by Th49;
A2: A\impA in F by Th34;
    then A\impA\imp(A\impA\andA) in F by A1,Def38;
    hence thesis by A2,Def38;
  end;

theorem Th201:
  A\impB in F & A\impC in F implies A\imp(B\andC) in F
  proof
    assume Z0: A\impB in F & A\impC in F;
    (A\impB)\imp((A\impC)\imp(A\imp(B\andC))) in F by Th49;
    then (A\impC)\imp(A\imp(B\andC)) in F by Z0,Def38;
    hence A\impB\andC in F by Z0,Def38;
  end;

theorem Th54:
  (A\andB)\or(A\andC) \imp A\and(B\orC) in F
  proof
    A\andB\impB in F & B\impB\orC in F by Def38; then
A1: A\andB\impB\orC in F by Th45;
    A\andC\impC in F & C\impB\orC in F by Def38; then
A2: A\andC\impB\orC in F by Th45;
    set AB = A\andB, AC = A\andC;
A3: AB\impA\imp(AB\impB\orC\imp(AB\impA\and(B\orC))) in F by Th49;
    AB\impA in F by Def38; then
    AB\impB\orC\imp(AB\impA\and(B\orC)) in F by A3,Def38; then
A4: AB\impA\and(B\orC) in F by A1,Def38;
A5: AC\impA\imp(AC\impB\orC\imp(AC\impA\and(B\orC))) in F by Th49;
    AC\impA in F by Def38; then
    AC\impB\orC\imp(AC\impA\and(B\orC)) in F by A5,Def38; then
A6: AC\impA\and(B\orC) in F by A2,Def38;
    AB\impA\and(B\orC)\imp(AC\impA\and(B\orC)\imp(AB\orAC\impA\and(B\orC)))in F
    by Def38; then
    AC\impA\and(B\orC)\imp(AB\orAC\impA\and(B\orC)) in F by A4,Def38;
    hence thesis by A6,Def38;
  end;

theorem
  A\or(B\andC) \imp (A\orB)\and(A\orC) in F
  proof
    set AB =A\orB, AC = A\orC, BC = B\andC;
    set ABC = A\orBC;
A1: ABC\impAB\imp(ABC\impAC\imp(ABC\impAB\andAC)) in F by Th49;
A2: A\impAB\imp(BC\impAB\imp(ABC\impAB)) in F by Def38;
A3: A\impAC\imp(BC\impAC\imp(ABC\impAC)) in F by Def38;
A4: A\impAC in F & A\impAB in F by Def38;
    BC\impC in F & BC\impB in F & B\impAB in F & C\impAC in F by Def38; then
A5: BC\impAB in F & BC\impAC in F by Th45;
    BC\impAB\imp(ABC\impAB) in F & BC\impAC\imp(ABC\impAC) in F by A2,A3,A4,
Def38;
    then
A6: ABC\impAB in F & ABC\impAC in F by A5,Def38; then
    ABC\impAC\imp(ABC\impAB\andAC) in F by A1,Def38;
    hence thesis by A6,Def38;
  end;

theorem Th56:
  A\imp(\notA\impB) in F
  proof
    A\and\notA\impB\imp(A\imp(\notA\impB)) in F & A\and\notA\impB in F
    by Th47,Def38;
    hence thesis by Def38;
  end;

theorem Th57:
  A\impB\imp(\notB\imp\notA) in F
  proof
    A\impB\imp(A\imp\notB\imp\notA) in F by Def38; then
A1: A\imp\notB\imp(A\impB\imp\notA) in F by Th38;
    \notB\imp(A\imp\notB) in F by Def38; then
    \notB\imp(A\impB\imp\notA) in F by A1,Th45;
    hence thesis by Th38;
  end;

theorem Th58:
  A\impB in F iff \notB\imp\notA in F
  proof
    (\notB\imp\notA)\imp(A\impB) in F &
    A\impB\imp(\notB\imp\notA) in F by Def38,Th57;
    hence thesis by Def38;
  end;

theorem Th59:
  A\impB in F & C\impD in F implies A\orC\impB\orD in F
  proof
    assume A1: A\impB in F;
    assume A2: C\impD in F;
A3: A\impB\orD\imp(C\impB\orD\imp(A\orC\impB\orD)) in F by Def38;
    B\impB\orD in F & D\impB\orD in F by Def38; then
A4: A\impB\orD in F & C\impB\orD in F by A1,A2,Th45; then
    C\impB\orD\imp(A\orC\impB\orD) in F by A3,Def38;
    hence A\orC\impB\orD in F by A4,Def38;
  end;

theorem Th60:
  A\impB\imp(C\orA\impC\orB) in F
  proof
    C\impC\orB in F & C\impC\orB\imp(A\impC\orB\imp(C\orA\impC\orB)) in F
    by Def38; then
A1: A\impC\orB\imp(C\orA\impC\orB) in F by Def38;
    A\impB\imp(A\impB) in F & A\impB\imp(A\impB)\imp((A\impB)\andA\impB) in F
    by Th34,Th48; then
    ((A\impB)\andA\impB) in F & B\impC\orB in F by Def38; then
    ((A\impB)\andA\impC\orB) in F &
    ((A\impB)\andA\impC\orB)\imp(A\impB\imp(A\impC\orB)) in F by Th45,Th47;then
    A\impB\imp(A\impC\orB) in F by Def38;
    hence thesis by A1,Th45;
  end;

theorem
  A\impB in F & C\impD in F & \notB\or\notD in F implies \notA\or\notC in F
  proof
    assume A1: A\impB in F;
    assume A2: C\impD in F;
    assume A3: \notB\or\notD in F;
    A\impB\imp(\notB\imp\notA) in F & C\impD\imp(\notD\imp\notC) in F
    by Th57; then
    \notB\imp\notA in F & \notD\imp\notC in F by A1,A2,Def38; then
    \notB\or\notD\imp\notA\or\notC in F by Th59;
    hence \notA\or\notC in F by A3,Def38;
  end;

theorem Th62:
  A\orB\imp(\notA\impB) in F
  proof
A1: A\imp(\notA\impB) in F by Th56;
A2: B\imp(\notA\impB) in F by Def38;
    A\imp(\notA\impB)\imp((B\imp(\notA\impB))\imp(A\orB\imp(\notA\impB))) in F
    by Def38; then
    (B\imp(\notA\impB))\imp(A\orB\imp(\notA\impB)) in F by A1,Def38;
    hence thesis by A2,Def38;
  end;

theorem
  A\orB\imp(\notB\impA) in F
  proof
    A\orB\impB\orA in F & B\orA\imp(\notB\impA) in F by Th36,Th62;
    hence A\orB\imp(\notB\impA) in F by Th45;
  end;

theorem Th64:
  A\imp\not\notA in F
  proof
A1: A\imp((\notA\impA)\imp\not\notA)\imp((A\imp(\notA\impA))\imp
    (A\imp\not\notA)) in F by Def38;
A2: (\notA\impA)\imp((\notA\imp\notA)\imp\not\notA)\imp((\notA\impA)\imp
    (\notA\imp\notA)\imp(\notA\impA\imp\not\notA)) in F by Def38;
    (\notA\impA)\imp((\notA\imp\notA)\imp\not\notA) in F by Def38; then
A3: (\notA\impA)\imp(\notA\imp\notA)\imp(\notA\impA\imp\not\notA)in F
    by A2,Def38;
    (\notA\impA)\imp(\notA\imp\notA) in F by Th34,Th44; then
    \notA\impA\imp\not\notA in F by A3,Def38; then
    A\imp(\notA\impA\imp\not\notA) in F by Th44; then
A4: (A\imp(\notA\impA))\imp(A\imp\not\notA) in F by A1,Def38;
    A\imp(\notA\impA) in F by Def38;
    hence thesis by A4,Def38;
  end;

theorem Th65:
  \not\notA\impA in F
  proof
    \notA\imp\not\not\notA\imp(\not\notA\impA) in F &
    \notA\imp\not\not\notA in F by Def38,Th64;
    hence thesis by Def38;
  end;

theorem Th66:
  A\iff\not\notA in F
  proof
A1: (A\imp\not\notA)\and(\not\notA\impA)\imp(A\iff\not\notA) in F by Def38;
    A\imp\not\notA in F & \not\notA\impA in F by Th64,Th65;
    then (A\imp\not\notA)\and(\not\notA\impA) in F by Th35;
    hence thesis by A1,Def38;
  end;

theorem Th67:
  A\imp\notB in F iff B\imp\notA in F
  proof
A1: A\imp\notB in F iff \not\notB\imp\notA in F by Th58;
A2: B\imp\notA in F iff \not\notA\imp\notB in F by Th58;
    B\imp\not\notB in F & A\imp\not\notA in F by Th64;
    hence thesis by A1,A2,Th45;
  end;

theorem Th68:
  \notA\impB in F iff \notB\impA in F
  proof
A1: \notA\impB in F iff \notB\imp\not\notA in F by Th58;
A2: \notB\impA in F iff \notA\imp\not\notB in F by Th58;
    \not\notA\impA in F & \not\notB\impB in F by Th65;
    hence thesis by A1,A2,Th45;
  end;

theorem Th69:
  A\imp(B\impC) in F & C\impD in F implies A\imp(B\impD) in F
  proof assume
A1: A\imp(B\impC) in F & C\impD in F;
    A\imp(B\impC)\imp(A\andB\impC) in F by Th48;
    then A\andB\impC in F by A1,Def38;
    then A\andB\impD in F & A\andB\impD\imp(A\imp(B\impD)) in F
    by A1,Th45,Th47;
    hence thesis by Def38;
  end;

theorem Th70:
  \not(A\andB)\imp\notA\or\notB in F
  proof
    \notA\imp\notA\or\notB in F & \notB\imp\notA\or\notB in F by Def38; then
    \not(\notA\or\notB)\imp\not\notA in F & \not\notA\impA in F &
    \not(\notA\or\notB)\imp\not\notB in F & \not\notB\impB in F
    by Th58,Th65; then
A1: \not(\notA\or\notB)\impA in F & \not(\notA\or\notB)\impB in F by Th45;
    \not(\notA\or\notB)\impA\imp(\not(\notA\or\notB)\impB\imp
    (\not(\notA\or\notB)\impA\andB)) in F by Th49; then
    \not(\notA\or\notB)\impB\imp(\not(\notA\or\notB)\impA\andB) in F
    by A1,Def38; then
    \not(\notA\or\notB)\impA\andB in F by A1,Def38; then
    \not(A\andB)\imp\not\not(\notA\or\notB) in F &
    \not\not(\notA\or\notB)\imp(\notA\or\notB) in F by Th58,Th65;
    hence thesis by Th45;
  end;

theorem Th71:
  \not(A\orB)\imp\notA\and\notB in F
  proof
    A\impA\orB in F & B\impA\orB in F by Def38; then
A1: \not(A\orB)\imp\notA in F & \not(A\orB)\imp\notB in F by Th58;
    \not(A\orB)\imp\notA\imp(\not(A\orB)\imp\notB\imp(\not(A\orB)\imp\notA\and
    \notB)) in F by Th49; then
    \not(A\orB)\imp\notB\imp(\not(A\orB)\imp\notA\and\notB) in F by A1,Def38;
    hence thesis by A1,Def38;
  end;

theorem Th72:
  A\impB in F & C\impD in F implies A\andC\impB\andD in F
  proof
    assume A1: A\impB in F;
    assume A2: C\impD in F;
A3: A\andC\impB\imp(A\andC\impD\imp(A\andC\impB\andD)) in F by Th49;
    A\andC\impA in F & A\andC\impC in F by Def38; then
A4: A\andC\impB in F & A\andC\impD in F by A1,A2,Th45; then
    A\andC\impD\imp(A\andC\impB\andD) in F by A3,Def38;
    hence A\andC\impB\andD in F by A4,Def38;
  end;

theorem Th73:
  \notA\or\notB\imp\not(A\andB) in F
  proof
    A\andB\impA in F & A\andB\impB in F by Def38; then
A1: \notA\imp\not(A\andB) in F & \notB\imp\not(A\andB) in F by Th58;
    \notA\imp\not(A\andB)\imp(\notB\imp\not(A\andB)\imp
    (\notA\or\notB\imp\not(A\andB))) in F by Def38; then
    \notB\imp\not(A\andB)\imp(\notA\or\notB\imp\not(A\andB)) in F by A1,Def38;
    hence \notA\or\notB\imp\not(A\andB) in F by A1,Def38;
  end;

theorem Th74:
  \notA\and\notB\imp\not(A\orB) in F
  proof
A1: \not\notA\or\not\notB\imp\not(\notA\and\notB) in F by Th73;
    A\imp\not\notA in F & B\imp\not\notB in F by Th64; then
    A\orB\imp\not\notA\or\not\notB in F by Th59; then
    A\orB\imp\not(\notA\and\notB) in F by A1,Th45; then
    (\notA\and\notB)\imp\not\not(\notA\and\notB) in F &
    \not\not(\notA\and\notB)\imp\not(A\orB) in F by Th64,Th58;
    hence thesis by Th45;
  end;

theorem
  A\or(B\orC)\imp(A\orB)\orC in F
  proof
A1: A\imp(A\orB)\orC\imp(B\orC\imp(A\orB)\orC\imp(A\or(B\orC)\imp(A\orB)\orC))
    in F by Def38;
    A\impA\orB in F & A\orB\imp(A\orB)\orC in F by Def38; then
    A\imp(A\orB)\orC in F by Th45; then
A2: B\orC\imp(A\orB)\orC\imp(A\or(B\orC)\imp(A\orB)\orC) in F by A1,Def38;
    B\impA\orB in F & C\impC in F by Def38,Th34; then
    B\orC\imp(A\orB)\orC in F by Th59;
    hence thesis by A2,Def38;
  end;

theorem Th76:
  (A\orB)\orC\iffA\or(B\orC) in F
  proof
A1: A\orB\imp(A\or(B\orC))\imp(C\imp(A\or(B\orC))\imp((A\orB)\orC\imp
    (A\or(B\orC)))) in F by Def38;
    B\impB\orC in F & A\impA in F by Def38,Th34; then
    A\orB\imp(A\or(B\orC)) in F by Th59; then
A2: C\impA\or(B\orC)\imp(A\orB\orC\impA\or(B\orC)) in F by A1,Def38;
    C\impB\orC in F & B\orC\impA\or(B\orC) in F by Def38; then
    C\impA\or(B\orC) in F by Th45;
    then
A3: (A\orB)\orC\impA\or(B\orC) in F by A2,Def38;
A4: A\imp((A\orB)\orC)\imp(B\orC\imp(A\orB\orC)\imp(A\or(B\orC)\imp
    (A\orB\orC))) in F by Def38;
    B\impA\orB in F & C\impC in F by Def38,Th34; then
    B\orC\imp(A\orB\orC) in F by Th59; then
A5: A\impA\orB\orC\imp(A\or(B\orC)\impA\orB\orC) in F by A4,Th46;
    A\impA\orB in F & A\orB\impA\orB\orC in F by Def38; then
    A\impA\orB\orC in F by Th45;
    then
    A\or(B\orC)\impA\orB\orC in F by A5,Def38;
    hence thesis by A3,Th43;
  end;

theorem
  A\and(B\andC)\imp(A\andB)\andC in F
  proof
A1: A\and(B\andC)\imp(A\andB)\imp(A\and(B\andC)\impC\imp(A\and(B\andC)\imp
    (A\andB)\andC)) in F by Th49;
    A\impA in F & B\andC\impB in F by Def38,Th34; then
    A\and(B\andC)\imp(A\andB) in F by Th72; then
A2: A\and(B\andC)\impC\imp(A\and(B\andC)\imp(A\andB)\andC) in F by A1,Def38;
    A\and(B\andC)\impB\andC in F & B\andC\impC in F by Def38; then
    A\and(B\andC)\impC in F by Th45;
    hence thesis by A2,Def38;
  end;

theorem Th78:
  (A\andB)\andC\iffA\and(B\andC) in F
  proof
A1: A\andB\andC\impA\imp(A\andB\andC\impB\andC\imp((A\andB)\andC\imp
    (A\and(B\andC)))) in F by Th49;
    A\andB\impA in F & A\andB\andC\impA\andB in F by Def38; then
    A\andB\andC\impA in F by Th45; then
A2: A\andB\andC\impB\andC\imp(A\andB\andC\impA\and(B\andC)) in F by A1,Def38;
    A\andB\impB in F & C\impC in F by Def38,Th34; then
    A\andB\andC\impB\andC in F by Th72;
    then
A3: (A\andB)\andC\impA\and(B\andC) in F by A2,Def38;
A4: (A\and(B\andC))\impA\andB\imp((A\and(B\andC))\impC\imp(A\and(B\andC)\imp
    (A\andB\andC))) in F by Th49;
    B\andC\impB in F & A\impA in F by Def38,Th34; then
    A\and(B\andC)\imp(A\andB) in F by Th72; then
A5: (A\and(B\andC))\impC\imp(A\and(B\andC)\imp (A\andB\andC)) in F by A4,Def38;
    B\andC\impC in F & A\and(B\andC)\impB\andC in F by Def38; then
    A\and(B\andC)\impC in F by Th45;
    then
    (A\and(B\andC)\imp (A\andB\andC)) in F by A5,Def38;
    hence thesis by A3,Th43;
  end;

theorem Th79:
  C\or(A\impB)\imp(C\orA\impC\orB) in F
  proof
A1: C\imp(C\orA\impC\orB)\imp((A\impB\imp(C\orA\impC\orB))\imp
    (C\or(A\impB)\imp(C\orA\impC\orB))) in F by Def38;
    C\impC\orB in F by Def38; then
    C\orA\imp(C\impC\orB) in F &
    C\orA\imp(C\impC\orB)\imp(C\imp(C\orA\impC\orB)) in F by Th44,Th41; then
    C\imp(C\orA\impC\orB) in F by Def38; then
A2: (A\impB\imp(C\orA\impC\orB))\imp(C\or(A\impB)\imp(C\orA\impC\orB)) in F
    by A1,Def38;
    A\impB\imp(C\orA\impC\orB) in F by Th60;
    hence thesis by A2,Def38;
  end;

theorem Th80:
  (A\orB)\and(A\orC) \imp A\or(B\andC) in F
  proof
    B\imp(C\impB\andC) in F & A\impA in F by Def38,Th34; then
    A\orB\impA\or(C\impB\andC) in F &
    A\or(C\impB\andC)\imp(A\orC\impA\or(B\andC)) in F by Th59,Th79; then
A1: A\orB\imp(A\orC\impA\orB\andC) in F by Th45;
    A\orB\imp(A\orC\impA\orB\andC)\imp((A\orB)\and(A\orC)\impA\orB\andC) in F
    by Th48;
    hence thesis by A1,Def38;
  end;

theorem Th81:
  A\and(B\orC) \imp (A\andB)\or(A\andC) in F
  proof
    set AB =A\andB, AC = A\andC, BC = B\orC;
    set ABC = A\andBC;
A1: (\notA\or\notB)\and(\notA\or\notC) \imp \notA\or(\notB\and\notC) in F
    by Th80;
    \not(A\andB)\imp(\notA\or\notB) in F &
    \not(A\andC)\imp(\notA\or\notC) in F by Th70; then
A2: \not(A\andB)\and\not(A\andC)\imp(\notA\or\notB)\and(\notA\or\notC) in F
    by Th72;
    \not(A\andB\orA\andC)\imp\not(A\andB)\and\not(A\andC) in F by Th71; then
    \not(A\andB\orA\andC)\imp(\notA\or\notB)\and(\notA\or\notC) in F
    by A2,Th45; then
A3: \not(A\andB\orA\andC)\imp\notA\or(\notB\and\notC) in F by A1,Th45;
    \notA\imp\notA in F &
    \notB\and\notC\imp\not(B\orC) in F by Th34,Th74; then
    \notA\or(\notB\and\notC)\imp\notA\or\not(B\orC) in F &
    \notA\or\not(B\orC)\imp\not(A\and(B\orC)) in F
    by Th73,Th59; then
    \notA\or(\notB\and\notC)\imp\not(A\and(B\orC)) in F
    by Th45; then
    \not(A\andB\orA\andC)\imp\not(A\and(B\orC)) in F by A3,Th45;
    hence thesis by Th58;
  end;

theorem Th82:
  A\impB\imp\notA\orB in F
  proof
A1: A\impB\imp(A\impB) in F by Th34;
    A\impB\imp(A\impB)\imp((A\impB)\andA\impB) in F by Th48; then
    (A\impB)\andA\impB in F & \notA\imp\notA in F by A1,Def38,Th34; then
A2: \notA\or(A\impB)\andA\imp\notA\orB in F by Th59;
    (\notA\or(A\impB))\and(\notA\orA)\imp(\notA\or(A\impB)\andA) in F by Th80;
    then
A3: (\notA\or(A\impB))\and(\notA\orA)\imp\notA\orB in F by A2,Th45;
    (\notA\orA)\and(\notA\or(A\impB))\imp((\notA\or(A\impB))\and(\notA\orA))
    in F by Th50; then
A4: (\notA\orA)\and(\notA\or(A\impB))\imp\notA\orB in F by A3,Th45;
    ((\notA\orA)\and(\notA\or(A\impB))\imp\notA\orB)\imp
    ((\notA\orA)\imp((\notA\or(A\impB))\imp\notA\orB)) in F by Th47; then
A5: (\notA\orA)\imp((\notA\or(A\impB))\imp\notA\orB) in F by A4,Def38;
    A\or\notA in F & A\or\notA\imp\notA\orA in F by Def38,Th36; then
    \notA\orA in F by Def38; then
A6: (\notA\or(A\impB))\imp\notA\orB in F by A5,Def38;
    (A\impB)\imp(\notA\or(A\impB)) in F by Def38;
    hence thesis by A6,Th45;
  end;

theorem
  A\impB\imp\not(A\and\notB) in F
  proof
A1: A\impB\imp\notA\orB in F by Th82;
    \notA\imp\notA in F & B\imp\not\notB in F by Th64,Th34; then
    \notA\orB\imp\notA\or\not\notB in F by Th59; then
A2: A\impB\imp\notA\or\not\notB in F by A1,Th45;
    \notA\or\not\notB\imp\not(A\and\notB) in F by Th73;
    hence thesis by A2,Th45;
  end;

theorem Th84:
  B\or\notC\andC\impB in F
  proof
    (C\and\notC\impB) in F & \notC\andC\impC\and\notC in F by Th50,Def38; then
    \notC\andC\impB in F & B\impB in F by Th34,Th45; then
    B\or\notC\andC\impB\orB in F & B\orB\impB in F by Th59,Th52;
    hence B\or\notC\andC\impB in F by Th45;
  end;

theorem Th85:
  B\orC\and\notC\impB in F
  proof
    (C\and\notC\impB) in F & B\impB in F by Th34,Def38; then
    B\orC\and\notC\impB\orB in F & B\orB\impB in F by Th59,Th52;
    hence B\orC\and\notC\impB in F by Th45;
  end;

theorem Th86:
  A\iffB\impA\andB\or\notA\and\notB in F
  proof
A1: (A\iffB)\imp(A\impB) in F & (A\iffB)\imp(B\impA) in F by Def38;
    A\impB\imp\notA\orB in F & B\impA\imp\notB\orA in F by Th82; then
A2: (A\iffB)\imp\notA\orB in F & (A\iffB)\imp\notB\orA in F by A1,Th45;
    (A\iffB)\imp\notA\orB\imp((A\iffB)\imp\notB\orA\imp((A\iffB)\imp
    (\notA\orB)\and(\notB\orA))) in F by Th49; then
    (A\iffB)\imp\notB\orA\imp((A\iffB)\imp(\notA\orB)\and(\notB\orA)) in F
    by A2,Def38; then
A3: (A\iffB)\imp(\notA\orB)\and(\notB\orA) in F by A2,Def38;
A4: (\notA\orB)\and(\notB\orA) \imp (\notA\orB)\and\notB\or(\notA\orB)\andA
    in F by Th81;
    (\notA\orB)\and\notB \imp \notB\and(\notA\orB) in F &
    \notB\and(\notA\orB)\imp\notB\and\notA\or\notB\andB in F by Th50,Th81;then
    (\notA\orB)\and\notB \imp \notB\and\notA\or\notB\andB in F &
    \notB\and\notA\or\notB\andB\imp\notB\and\notA in F by Th45,Th84; then
A5: (\notA\orB)\and\notB \imp \notB\and\notA in F by Th45;
    (\notA\orB)\andA \imp A\and(\notA\orB) in F &
    A\and(\notA\orB)\impA\and\notA\orA\andB in F by Th50,Th81;then
    (\notA\orB)\andA \imp A\and\notA\orA\andB in F &
    A\and\notA\orA\andB \imp A\andB\orA\and\notA in F by Th36,Th45; then
    (\notA\orB)\andA \imp A\andB\orA\and\notA in F &
    A\andB\orA\and\notA\impA\andB in F by Th45,Th85; then
    (\notA\orB)\andA \imp A\andB in F by Th45; then
    (\notA\orB)\and\notB\or(\notA\orB)\andA \imp \notB\and\notA\orA\andB in F
    by A5,Th59; then
    (\notA\orB)\and(\notB\orA) \imp \notB\and\notA\orA\andB in F by A4,Th45;
    then
A6: (A\iffB)\imp\notB\and\notA\orA\andB in F by A3,Th45;
    \notB\and\notA\imp\notA\and\notB in F & A\andB\impA\andB in F by Th34,Th50;
    then
    \notB\and\notA\orA\andB \imp \notA\and\notB\orA\andB in F &
    \notA\and\notB\orA\andB \imp A\andB\or\notA\and\notB in F by Th36,Th59;then
    \notB\and\notA\orA\andB \imp A\andB\or\notA\and\notB in F by Th45;
    hence thesis by A6,Th45;
  end;

theorem
  A\iffB\imp(A\or\notB)\and(\notA\orB) in F
  proof
    \notA\and(A\or\notB) \imp (A\or\notB)\and\notA in F &
    B\and(A\or\notB) \imp (A\or\notB)\andB in F by Th50; then
    (A\or\notB)\and\notA\or(A\or\notB)\andB\imp(A\or\notB)\and(\notA\orB) in F&
    \notA\and(A\or\notB)\orB\and(A\or\notB) \imp
    (A\or\notB)\and\notA\or(A\or\notB)\andB in F by Th54,Th59; then
A1: \notA\and(A\or\notB)\orB\and(A\or\notB)\imp(A\or\notB)\and(\notA\orB) in F
    by Th45;
    (\notA\andA)\or(\notA\and\notB)\imp\notA\and(A\or\notB) in F &
    (B\andA)\or(B\and\notB)\impB\and(A\or\notB) in F &
    (\notA\and\notB)\imp(\notA\andA)\or(\notA\and\notB) in F &
    (B\andA)\imp(B\andA)\or(B\and\notB) in F by Def38,Th54; then
    (\notA\and\notB)\imp\notA\and(A\or\notB) in F &
    (B\andA)\impB\and(A\or\notB) in F by Th45; then
    (\notA\and\notB)\or(B\andA)\imp\notA\and(A\or\notB)\orB\and(A\or\notB) in F
    by Th59; then
A2: (\notA\and\notB)\or(B\andA)\imp(A\or\notB)\and(\notA\orB) in F by A1,Th45;
    A\andB\impB\andA in F & \notA\and\notB\imp\notA\and\notB in F
    by Th34,Th50; then
    (\notA\and\notB)\or(A\andB)\imp(\notA\and\notB)\or(B\andA) in F &
    (A\andB)\or(\notA\and\notB)\imp(\notA\and\notB)\or(A\andB) in F
    by Th36,Th59; then
    A\andB\or\notA\and\notB\imp(\notA\and\notB)\or(B\andA) in F by Th45; then
A3: A\andB\or\notA\and\notB\imp(A\or\notB)\and(\notA\orB) in F by A2,Th45;
    A\iffB\impA\andB\or\notA\and\notB in F by Th86;
    hence thesis by A3,Th45;
  end;

theorem
  \not(A\and\notA) in F
  proof
    \notA\imp\notA in F & A\imp\not\notA in F by Th34,Th64; then
    \notA\andA\imp\notA\and\not\notA in F &
    \notA\and\not\notA\imp\not(A\or\notA) in F by Th74,Th72; then
    \notA\andA\imp\not(A\or\notA) in F by Th45; then
    \not\not(A\or\notA)\imp\not(\notA\andA) in F &
    A\or\notA\imp\not\not(A\or\notA) in F by Th64,Th58; then
    (A\or\notA)\imp\not(\notA\andA) in F & A\or\notA in F by Th45,Def38; then
A1: \not(\notA\andA) in F by Def38;
    A\and\notA\imp\notA\andA in F by Th50; then
    \not(\notA\andA)\imp\not(A\and\notA) in F by Th58;
    hence thesis by Def38,A1;
  end;

theorem
  A\iffA in F
  proof
A1: (A\impA)\and(A\impA)\imp(A\iffA) in F by Def38;
    A\impA in F by Th34; then
    (A\impA)\and(A\impA) in F by Th35;
    hence thesis by A1,Def38;
  end;

theorem Th90:
  A\iffB in F implies B\iffA in F
  proof
    assume
A1: A\iffB in F;
    A\iffB\imp(A\impB) in F & A\iffB\imp(B\impA) in F by Def38; then
    A\impB in F & B\impA in F by A1,Def38; then
A2: (B\impA)\and(A\impB) in F by Th35;
    (B\impA)\and(A\impB)\imp(B\iffA) in F by Def38;
    hence thesis by A2,Def38;
  end;

theorem Th91:
  A\iffB in F & B\iffC in F implies A\iffC in F
  proof
    assume
A1: A\iffB in F & B\iffC in F;
    A\iffB\imp(A\impB) in F & A\iffB\imp(B\impA) in F &
    B\iffC\imp(B\impC) in F & B\iffC\imp(C\impB) in F by Def38; then
    A\impB in F & B\impA in F & C\impB in F & B\impC in F by A1,Def38; then
    A\impC in F & C\impA in F by Th45; then
A2: (A\impC)\and(C\impA) in F by Th35;
    (A\impC)\and(C\impA)\imp(A\iffC) in F by Def38;
    hence thesis by A2,Def38;
  end;

theorem Th92:
  A\iffB in F & B\impC in F implies A\impC in F
  proof
    assume
A1: A\iffB in F & B\impC in F;
    A\iffB\imp(A\impB) in F & A\iffB\imp(B\impA) in F &
    B\iffC\imp(B\impC) in F & B\iffC\imp(C\impB) in F by Def38; then
    A\impB in F by A1,Def38;
    hence thesis by A1,Th45;
  end;

theorem Th93:
  A\impB in F & B\iffC in F implies A\impC in F
  proof
    assume
A1: A\impB in F & B\iffC in F;
    A\iffB\imp(A\impB) in F & A\iffB\imp(B\impA) in F &
    B\iffC\imp(B\impC) in F & B\iffC\imp(C\impB) in F by Def38; then
    B\impC in F by A1,Def38;
    hence thesis by A1,Th45;
  end;

theorem Th94:
  A\iffB in F iff \notA\iff\notB in F
  proof
    hereby
      assume
A1:   A\iffB in F;
      A\iffB\imp(A\impB) in F & A\iffB\imp(B\impA) in F by Def38; then
      A\impB in F & B\impA in F & A\impB\imp(\notB\imp\notA) in F &
      B\impA\imp(\notA\imp\notB) in F by A1,Def38,Th57; then
      \notA\imp\notB in F & \notB\imp\notA in F by Def38; then
      (\notA\imp\notB)\and(\notB\imp\notA) in F &
      (\notA\imp\notB)\and(\notB\imp\notA)\imp(\notA\iff\notB) in F
      by Def38,Th35;
      hence \notA\iff\notB in F by Def38;
    end;
    assume
A2: \notA\iff\notB in F;
    \notA\iff\notB\imp(\notA\imp\notB) in F &
    \notA\iff\notB\imp(\notB\imp\notA) in F by Def38; then
    \notA\imp\notB in F & \notB\imp\notA in F & \notA\imp\notB\imp(B\impA) in F
    & \notB\imp\notA\imp(A\impB) in F by A2,Def38; then
    A\impB in F & B\impA in F by Def38; then
    (A\impB)\and(B\impA) in F & (A\impB)\and(B\impA)\imp(A\iffB) in F
    by Def38,Th35;
    hence A\iffB in F by Def38;
  end;

theorem Th95:
  A\iffB in F iff \not\notA\iffB in F
  proof
    \not\notA\impA in F & A\imp\not\notA in F by Th64,Th65; then
    (\not\notA\impA)\and(A\imp\not\notA) in F &
    (\not\notA\impA)\and(A\imp\not\notA)\imp(\not\notA\iffA) in F
    by Th35,Def38;
    then
A1: \not\notA\iffA in F by Def38; then
    A\iff\not\notA in F by Th90;
    hence thesis by A1,Th91;
end;

theorem Th96:
  A\imp(B\impC) in F & D\impB in F implies A\imp(D\impC) in F
  proof
    assume
A1: A\imp(B\impC) in F & D\impB in F;
    (A\imp(B\impC))\imp(B\imp(A\impC)) in F by Th41; then
    B\imp(A\impC) in F by A1,Def38; then
A2: D\imp(A\impC) in F by A1,Th45;
    (D\imp(A\impC))\imp(A\imp(D\impC)) in F by Th41;
    hence thesis by A2,Def38;
  end;

theorem Th97:
  A\iffB\andC in F & C\iffD in F implies A\iffB\andD in F
  proof
    assume A1: A\iffB\andC in F;
    then A2: B\andC\iffA in F by Th90;
    assume C\iffD in F;
    then C\impD in F & D\impC in F & B\impB in F by Th43,Th34;
    then B\andC\impB\andD in F & B\andD\impB\andC in F by Th72;
    then A\impB\andD in F & B\andD\impA in F by A1,A2,Th92,Th93;
    hence A\iffB\andD in F by Th43;
  end;

theorem Th98:
  A\iffB\andC in F & B\iffD in F implies A\iffD\andC in F
  proof
    assume A1: A\iffB\andC in F;
    then A2: B\andC\iffA in F by Th90;
    assume B\iffD in F;
    then B\impD in F & D\impB in F & C\impC in F by Th43,Th34;
    then B\andC\impD\andC in F & D\andC\impB\andC in F by Th72;
    then A\impD\andC in F & D\andC\impA in F by A1,A2,Th92,Th93;
    hence A\iffD\andC in F by Th43;
  end;

theorem Th99:
  A\iffB\orC in F & C\iffD in F implies A\iffB\orD in F
  proof
    assume A1: A\iffB\orC in F;
    then A2: B\orC\iffA in F by Th90;
    assume C\iffD in F;
    then C\impD in F & D\impC in F & B\impB in F by Th43,Th34;
    then B\orC\impB\orD in F & B\orD\impB\orC in F by Th59;
    then A\impB\orD in F & B\orD\impA in F by A1,A2,Th92,Th93;
    hence A\iffB\orD in F by Th43;
  end;

theorem Th100:
  A\iffB\orC in F & B\iffD in F implies A\iffD\orC in F
  proof
    assume A1: A\iffB\orC in F;
    then A2: B\orC\iffA in F by Th90;
    assume B\iffD in F;
    then B\impD in F & D\impB in F & C\impC in F by Th43,Th34;
    then B\orC\impD\orC in F & D\orC\impB\orC in F by Th59;
    then A\impD\orC in F & D\orC\impA in F by A1,A2,Th92,Th93;
    hence A\iffD\orC in F by Th43;
  end;

theorem Th101:
  A\impB in F implies B\impC\imp(A\impC) in F
  proof
    A\impB\imp(B\impC\imp(A\impC)) in F by Th39;
    hence thesis by Def38;
  end;

theorem Th102:
  A\impB in F implies C\impA\imp(C\impB) in F
  proof
    C\impA\imp(A\impB\imp(C\impB)) in F by Th39;
    then A\impB\imp(C\impA\imp(C\impB)) in F by Th38;
    hence thesis by Def38;
  end;

theorem Th103:
  A\impB in F & C\impD in F implies B\impC\imp(A\impD) in F
  proof assume
    A\impB in F & C\impD in F;
    then B\impC\imp(A\impC) in F & A\impC\imp(A\impD) in F by Th101,Th102;
    hence thesis by Th45;
  end;

begin :: Quantifier calculus

reserve
  J for non empty non void Signature,
  T for non-empty MSAlgebra over J,
  X for non empty-yielding GeneratorSet of T,
  S1 for J-extension non empty non void n PC-correct QC-correct
  QCLangSignature over Union X,
  L for non-empty Language of X extended_by ({},the carrier of S1), S1,
  G for QC-theory of L,
  A,B,C,D for Formula of L;
reserve x,y,z for Element of Union X;
reserve x0,y0,z0 for Element of Union (X extended_by ({},the carrier of S1));

theorem Th104:
  L is subst-correct implies \for(x,A)\impA in G
  proof set Y = X extended_by ({},the carrier of S1);
    assume
A1: L is subst-correct;
    consider a being object such that
A2: a in dom X & x in X.a by CARD_5:2;
    J is Subsignature of S1 by Def2;
    then
A3: the carrier of J c= the carrier of S1 & dom Y = the carrier of S1 &
    dom X = the carrier of J by PARTFUN1:def 2,INSTALG1:10;
    then reconsider a as SortSymbol of S1 by A2;
A4: x in Y.a by A2,A3,Th1;
    then reconsider x0 = x as Element of Union Y by A3,CARD_5:2;
    X c= the Sorts of T by PBOOLE:def 18;
    then X.a c= (the Sorts of T).a = (the Sorts of L).a
    by A2,Th16;
    then reconsider t = x as Element of (the Sorts of L).a by A2;
    Y is ManySortedSubset of the Sorts of L by Th23;
    then A/(x0,t) = A/(x0,x0) by A4,Th14 .= A by A4,A1;
    hence thesis by A2,A4,Def39;
  end;

theorem Th105:
  \ex(x,A)\iff\not\for(x,\notA) in G
  proof
    \not\ex(x,A)\iff\for(x,\notA) in G by Def39; then
    \not\not\ex(x,A)\iff\not\for(x,\notA) in G by Th94;
    hence \ex(x,A)\iff\not\for(x,\notA) in G by Th95;
  end;

theorem Th106:
  \for(x,A)\iff\not\ex(x,\notA) in G
  proof
    \ex(x,\notA)\iff\not\for(x,A) in G by Def39; then
    \not\for(x,A)\iff\ex(x,\notA) in G by Th90; then
    \not\not\for(x,A)\iff\not\ex(x,\notA) in G by Th94;
    hence \for(x,A)\iff\not\ex(x,\notA) in G by Th95;
  end;

theorem Th107:
       L is subst-correct implies
  \for(x,A\impB)\imp(\for(x,A)\impB) in G
  proof set Y = X extended_by ({},the carrier of S1);
    consider a being object such that
A1: a in dom X & x in X.a by CARD_5:2;
    J is Subsignature of S1 by Def2;
    then
A2: the carrier of J c= the carrier of S1 & dom Y = the carrier of S1 &
    dom X = the carrier of J by PARTFUN1:def 2,INSTALG1:10;
    reconsider a as SortSymbol of J by A1;
A3: x in Y.a by A1,A2,Th1;
A4: X.a is Subset of (the Sorts of T).a by Th13;
A5: Y is ManySortedSubset of the Sorts of L by Th23;
    then x in Union X = Union Y c= Union the Sorts of L
    by Th24,MSAFREE4:1,PBOOLE:def 18; then
    reconsider t = x as Element of Union the Sorts of L;
A6: (the Sorts of T).a = (the Sorts of L).a by Th16;
    reconsider x0 = x as Element of Union Y by Th24;
    assume L is subst-correct; then
    A/(x0,x0) = A & (A\impB)/(x0,x0) = A\impB by A1,A2,A3;
    then A/(x0,t) = A & (A\impB)/(x0,t) = A\impB
    by A5,A1,A2,A3,Th14;
    then \for(x,A\impB)\imp(A\impB) in G & \for(x,A)\impA in G
    by A6,A1,A4,A3,Def39;
    hence \for(x,A\impB)\imp(\for(x,A)\impB) in G by Th96;
  end;

theorem Th108:
  for a being SortSymbol of J
  st x in X.a & x nin (vf A).a & \for(x,A\impB) in G
  holds A\imp\for(x,B) in G
  proof let a be SortSymbol of J;
    assume
A1: x in X.a & x nin (vf A).a & \for(x,A\impB) in G; then
    \for(x,A\impB)\imp(A\imp\for(x,B)) in G by Def39;
    hence thesis by Def38,A1;
  end;

::  x nin (vf A).a implies \for(x,A\impB)\imp(A\imp\for(x,B)) in G by AX2;

theorem Th109:
       L is subst-correct vf-qc-correct implies
  \for(x,A\impB)\imp(\for(x,A)\imp\for(x,B)) in G
  proof set Y = X extended_by ({},the carrier of S1);
    consider a being object such that
A1: a in dom X & x in X.a by CARD_5:2;
    J is Subsignature of S1 by Def2;
    then dom X = the carrier of J c= the carrier of S1 = dom Y
    by INSTALG1:10,PARTFUN1:def 2;
    then reconsider a as SortSymbol of S1 by A1;
    assume
A2: L is subst-correct vf-qc-correct;
    then \for(x,A\impB)\imp(\for(x,A)\impB) in G by Th107;
    then
A3: \for(x,\for(x,A\impB)\imp(\for(x,A)\impB)) in G by Def39;
A4: vf \for(x,A\impB) = vf(A\impB) (\) a-singleton x & x in {x}
    by A1,A2,TARSKI:def 1;
    then (vf \for(x,A\impB)).a
    = (vf(A\impB)).a \ (a-singleton x).a by PBOOLE:def 6
    .= (vf(A\impB)).a \ {x} by AOFA_A00:6;
    then x nin (vf \for(x,A\impB)).a by A4,XBOOLE_0:def 5;
    then
A5: \for(x,A\impB)\imp\for(x,\for(x,A)\impB) in G by A1,A3,Th108;
A6: vf \for(x,A) = vf A (\) a-singleton x & x in {x}
    by A1,A2,TARSKI:def 1;
    then (vf \for(x,A)).a = (vf(A)).a \ (a-singleton x).a by PBOOLE:def 6
    .= (vf(A)).a \ {x} by AOFA_A00:6;
    then x nin (vf \for(x,A)).a by A6,XBOOLE_0:def 5;
    then \for(x,\for(x,A)\impB)\imp(\for(x,A)\imp\for(x,B)) in G by A1,Def39;
    hence thesis by A5,Th45;
  end;

theorem Th110:
       L is subst-correct implies
  for a being SortSymbol of J st x in X.a & y in X.a & x0 = x & y0 = y
  holds A/(x0,y0)\imp\ex(x,A) in G
  proof set Y = X extended_by ({},the carrier of S1);
    assume
A1: L is subst-correct;
    let a be SortSymbol of J such that
A2: x in X.a & y in X.a & x0 = x & y0 = y;
    J is Subsignature of S1 by Def2;
    then the carrier of J c= the carrier of S1 by INSTALG1:10;
    then
A3: a in the carrier of S1 & X c= the Sorts of T &
    dom the Sorts of L = the carrier of S1 by PARTFUN1:def 2,PBOOLE:def 18;
    then (the Sorts of L).a in rng the Sorts of L &
    (the Sorts of L).a = (the Sorts of T).a by Th16,FUNCT_1:def 3;
    then
A4: X.a c= (the Sorts of T).a = (the Sorts of L).a
    c= Union the Sorts of L by A3,ZFMISC_1:74;
    then reconsider t = y as Element of Union the Sorts of L by A2;
A5: a is SortSymbol of S1 by Th8; then
A6: x in Y.a & y in Y.a by A2,Th2;
A7: Y is ManySortedSubset of the Sorts of L by Th23;
    \for(x,\notA)\imp((\notA)/(x0,t)) in G by A2,A4,A6,Def39;
    then \for(x,\notA)\imp((\notA)/(x0,y0)) in G by A2,A6,A7,A5,Th14;
    then \not((\notA)/(x0,y0))\imp\not\for(x,\notA) in G by Th58;
    then \not\not(A/(x0,y0))\imp\not\for(x,\notA) in G &
    (A/(x0,y0))\imp\not\not(A/(x0,y0)) in G &
    \ex(x,A)\iff\not\for(x,\notA) in G &
    \ex(x,A)\iff\not\for(x,\notA)\imp(\not\for(x,\notA)\imp\ex(x,A)) in G
    by A1,A2,A6,A7,A5,Th27,Def38,Th64,Th105;
    then (A/(x0,y0))\imp\not\for(x,\notA) in G &
    \not\for(x,\notA)\imp\ex(x,A) in G by Th45,Def38;
    hence thesis by Th45;
  end;

theorem Th111:
       L is subst-correct vf-qc-correct implies
  \ex(x,y,A)\iff\not\for(x,y,\notA) in G
  proof
    assume
A1: L is subst-correct vf-qc-correct;
A2: \ex(x,y,A)\iff\not\for(x,\not\ex(y,A)) in G by Th105;
    \ex(y,A)\iff\not\for(y,\notA) in G &
    \for(y,\notA)\iff\not\not\for(y,\notA) in G by Th66,Th105;
    then \not\ex(y,A)\iff\not\not\for(y,\notA) in G &
    \not\not\for(y,\notA)\iff\for(y,\notA) in G by Th90,Th94;
    then \not\ex(y,A)\iff\for(y,\notA) in G by Th91;
    then \not\ex(y,A)\imp\for(y,\notA) in G &
    \for(y,\notA)\imp\not\ex(y,A) in G by Th43;
    then
A3: \for(x,\not\ex(y,A)\imp\for(y,\notA)) in G &
    \for(x,\for(y,\notA)\imp\not\ex(y,A)) in G by Def39;
    \for(x,\not\ex(y,A)\imp\for(y,\notA))\imp
    (\for(x,\not\ex(y,A))\imp\for(x,\for(y,\notA))) in G &
    \for(x,\for(y,\notA)\imp\not\ex(y,A))\imp
    (\for(x,\for(y,\notA))\imp\for(x,\not\ex(y,A))) in G by A1,Th109;
    then \for(x,\not\ex(y,A))\imp\for(x,\for(y,\notA)) in G &
    \for(x,\for(y,\notA))\imp\for(x,\not\ex(y,A)) in G by A3,Def38;
    then \for(x,\not\ex(y,A))\iff\for(x,y,\notA) in G by Th43;
    then \not\for(x,\not\ex(y,A))\iff\not\for(x,y,\notA) in G by Th94;
    hence thesis by A2,Th91;
  end;

theorem Th112:
  L is subst-correct implies A\imp\ex(x,A) in G
  proof set Y = X extended_by ({},the carrier of S1);
    assume
A1: L is subst-correct;
    consider a being object such that
A2: a in dom X & x in X.a by CARD_5:2;
    reconsider a as SortSymbol of J by A2;
A3: x in X.a & a is SortSymbol of S1 by A2,Th8; then
A4: x in Y.a & dom Y = the carrier of S1 by Th2,PARTFUN1:def 2;
    then reconsider x0 = x as Element of Union Y by A3,CARD_5:2;
    A/(x0,x0)\imp\ex(x,A) in G by A1,A2,Th110;
    hence thesis by A1,A3,A4;
  end;

theorem Th113:
  L is vf-qc-correct implies
  for a being SortSymbol of S1 st x in X.a
  holds x nin (vf \for(x,A)).a
  proof set Y = X extended_by ({},the carrier of S1);
    assume
A1: L is vf-qc-correct;
    let a be SortSymbol of S1; assume x in X.a;
    then vf \for(x,A) = (vf A)(\)(a-singleton x) by A1;
    then
A2: (vf \for(x,A)).a = ((vf A).a) \ ((a-singleton x).a) by PBOOLE:def 6
    .= (vf A).a \ {x} by AOFA_A00:6;
    x in {x} by TARSKI:def 1;
    hence thesis by A2,XBOOLE_0:def 5;
  end;

theorem Th114:
  L is vf-qc-correct implies
  for a being SortSymbol of S1 st x in X.a holds x nin (vf \ex(x,A)).a
  proof
    assume
A1: L is vf-qc-correct;
    let a be SortSymbol of S1; assume x in X.a;
    then vf \ex(x,A) = (vf A)(\)(a-singleton x) by A1;
    then
A2: (vf \ex(x,A)).a = ((vf A).a) \ ((a-singleton x).a) by PBOOLE:def 6
    .= (vf A).a \ {x} by AOFA_A00:6;
    x in {x} by TARSKI:def 1;
    hence thesis by A2,XBOOLE_0:def 5;
  end;

theorem Th115:
       L is subst-correct vf-qc-correct &
  A\impB in G implies (\for(x,A)\imp\for(x,B)) in G
  proof
    assume
A1: L is subst-correct vf-qc-correct;
    assume A\impB in G;
    then
A2: \for(x,A\impB) in G by Def39;
    \for(x,A\impB)\imp(\for(x,A)\imp\for(x,B)) in G by A1,Th109;
    hence thesis by A2,Def38;
  end;

theorem
       L is subst-correct vf-qc-correct implies
  \for(x,\notA\imp\notB)\imp(\for(x,B)\imp\for(x,A)) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
    (\notA\imp\notB)\imp(B\impA) in G by Def38;
    then
A2: \for(x,\notA\imp\notB)\imp(\for(x,B\impA)) in G by A1,Th115;
    \for(x,B\impA)\imp(\for(x,B)\imp\for(x,A)) in G by A1,Th109;
    hence \for(x,\notA\imp\notB)\imp(\for(x,B)\imp\for(x,A)) in G by A2,Th45;
  end;

theorem Th117:
       L is subst-correct vf-qc-correct implies
  \for(x,A\impB)\imp(\for(x,\notB)\imp\for(x,\notA)) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
    (A\impB)\imp(\notB\imp\notA) in G by Th57;
    then
A2: \for(x,A\impB)\imp(\for(x,\notB\imp\notA)) in G by A1,Th115;
    \for(x,\notB\imp\notA)\imp(\for(x,\notB)\imp\for(x,\notA)) in G
    by A1,Th109;
    hence \for(x,A\impB)\imp(\for(x,\notB)\imp\for(x,\notA)) in G by A2,Th45;
  end;

theorem
       L is subst-correct vf-qc-correct &
  A\iffB in G implies \for(x,A)\iff\for(x,B) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
    set p = A\impB, q = B\impA, pq = A\iffB;
    set a = \for(x,pq), b = \for(x,p), c = \for(x,A)\imp\for(x,B);
    pq\impp in G by Def38;
    then
A2: a\impb in G by A1,Th115;
    b\impc in G by A1,Th109;
    then
A3: (\for(x,pq))\imp(\for(x,A)\imp\for(x,B)) in G by A2,Th45;
    (A\iffB)\imp(B\impA) in G by Def38;
    then
A4: \for(x,A\iffB)\imp\for(x,B\impA) in G by A1,Th115;
    \for(x,B\impA)\imp(\for(x,B)\imp\for(x,A)) in G by A1,Th109;
    then
A5: \for(x,A\iffB)\imp(\for(x,B)\imp\for(x,A)) in G by A4,Th45;
    ((\for(x,A\iffB))\imp(\for(x,A)\imp\for(x,B)))\imp
    ((\for(x,A\iffB)\imp(\for(x,B)\imp\for(x,A)))\imp
    (\for(x,A\iffB)\imp((\for(x,A)\imp\for(x,B))\and(\for(x,B)\imp\for(x,A)))))
    in G by Th49;
    then ((\for(x,A\iffB)\imp(\for(x,B)\imp\for(x,A)))\imp
    (\for(x,A\iffB)\imp((\for(x,A)\imp\for(x,B))\and(\for(x,B)\imp\for(x,A)))))
    in G by A3,Def38;
    then
A6: \for(x,A\iffB)\imp((\for(x,A)\imp\for(x,B))\and(\for(x,B)\imp\for(x,A)))
    in G by A5,Def38;
    (\for(x,A)\imp\for(x,B))\and(\for(x,B)\imp\for(x,A))\imp
    (\for(x,A)\iff\for(x,B)) in G by Def38;
    then
A7: \for(x,A\iffB)\imp(\for(x,A)\iff\for(x,B)) in G by A6,Th45;
    assume A\iffB in G;
    then \for(x,A\iffB) in G by Def39;
    hence thesis by A7,Def38;
  end;

theorem
  \ex(x,\notA)\iff\not\for(x,A) in G by Def39;

theorem Th120:
  L is subst-correct vf-qc-correct implies
  for a being SortSymbol of J
  st x in X.a & x nin (vf B).a holds \for(x,A\impB)\imp(\ex(x,A)\impB) in G
  proof set Y = X extended_by ({},the carrier of S1);
    assume
A1: L is subst-correct vf-qc-correct;
    let a be SortSymbol of J;assume
A2: x in X.a & x nin (vf B).a;
A3: (A\impB)\imp(\notB\imp\notA) in G by Th57;
A4: \for(x,A\impB)\imp\for(x,\notB\imp\notA) in G by A1,A3,Th115;
    x nin (vf \notB).a by A1,A2;
    then \for(x,\notB\imp\notA)\imp(\notB\imp\for(x,\notA)) in G by A2,Def39;
    then
A5: \for(x,A\impB)\imp(\notB\imp\for(x,\notA)) in G by A4,Th45;
    \not\ex(x,A)\iff\for(x,\notA) in G &
    \not\ex(x,A)\iff\for(x,\notA)\imp
    (\for(x,\notA)\imp\not\ex(x,A)) in G by Def39,Def38;
    then \for(x,\notA)\imp\not\ex(x,A) in G by Def38;
    then
A6: \for(x,A\impB)\imp(\notB\imp\not\ex(x,A)) in G by A5,Th69;
    (\notB\imp\not\ex(x,A))\imp(\ex(x,A)\impB) in G by Def38;
    hence thesis by A6,Th45;
  end;

theorem Th121:
       L is subst-correct vf-qc-correct implies
  \for(x,A\impB)\imp(\ex(x,A)\imp\ex(x,B)) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
A2: \for(x,A\impB)\imp(\for(x,\notB)\imp\for(x,\notA)) in G by A1,Th117;
    \for(x,\notB)\imp\for(x,\notA)\imp(\not\for(x,\notA)\imp\not\for(x,\notB))
    in G by Th57;
    then
A3: \for(x,A\impB)\imp(\not\for(x,\notA)\imp\not\for(x,\notB)) in G by A2,Th45;
    \not\ex(x,A)\iff\for(x,\notA) in G by Def39;
    then \for(x,\notA)\imp\not\ex(x,A) in G by Th43;
    then \not\not\ex(x,A)\imp\not\for(x,\notA) in G &
    \ex(x,A)\imp\not\not\ex(x,A) in G by Th64,Th58;
    then
A4: \ex(x,A)\imp\not\for(x,\notA) in G by Th45;
    \not\ex(x,B)\iff\for(x,\notB) in G by Def39;
    then \not\ex(x,B)\imp\for(x,\notB) in G by Th43;
    then \not\for(x,\notB)\imp\not\not\ex(x,B) in G &
    (\not\not\ex(x,B))\imp\ex(x,B) in G by Th65,Th58;
    then \not\for(x,\notB)\imp\ex(x,B) in G by Th45;
    then \not\for(x,\notA)\imp\not\for(x,\notB)\imp(\ex(x,A)\imp\ex(x,B)) in G
    by A4,Th103;
    hence \for(x,A\impB)\imp(\ex(x,A)\imp\ex(x,B)) in G by A3,Th45;
  end;

theorem Th122:
       L is subst-correct vf-qc-correct implies
  \for(x,\notA)\iff\not\ex(x,A) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
    A\imp\not\notA in G by Th64;
    then \for(x,A\imp\not\notA) in G &
    \for(x,A\imp\not\notA)\imp(\ex(x,A)\imp\ex(x,\not\notA)) in G
    by A1,Def39,Th121;
    then
A2: \ex(x,A)\imp\ex(x,\not\notA) in G by Def38;
    \not\notA\impA in G by Th65;
    then \for(x,\not\notA\impA) in G &
    \for(x,\not\notA\impA)\imp(\ex(x,\not\notA)\imp\ex(x,A)) in G
    by A1,Def39,Th121;
    then \ex(x,\not\notA)\imp\ex(x,A) in G by Def38;
    then \ex(x,A)\iff\ex(x,\not\notA) in G &
    \ex(x,\not\notA)\iff\not\for(x,\notA) in G by Def39,A2,Th43; then
    \ex(x,A)\iff\not\for(x,\notA) in G by Th91; then
    \not\for(x,\notA)\iff\ex(x,A) in G by Th90; then
    \not\not\for(x,\notA)\iff\not\ex(x,A) in G by Th94;
    hence \for(x,\notA)\iff\not\ex(x,A) in G by Th95;
  end;

theorem
       L is subst-correct vf-qc-correct implies
  \for(x,y,A)\iff\not\ex(x,y,\notA) in G
  proof
    assume
A1: L is subst-correct vf-qc-correct;
A2: \for(x,y,A)\iff\not\ex(x,\not\for(y,A)) in G by Th106;
    \for(y,A)\iff\not\ex(y,\notA) in G &
    \ex(y,\notA)\iff\not\not\ex(y,\notA) in G by Th66,Th106;
    then \not\for(y,A)\iff\not\not\ex(y,\notA) in G &
    \not\not\ex(y,\notA)\iff\ex(y,\notA) in G by Th90,Th94;
    then \not\for(y,A)\iff\ex(y,\notA) in G by Th91;
    then \not\for(y,A)\imp\ex(y,\notA) in G &
    \ex(y,\notA)\imp\not\for(y,A) in G by Th43;
    then
A3: \for(x,\not\for(y,A)\imp\ex(y,\notA)) in G &
    \for(x,\ex(y,\notA)\imp\not\for(y,A)) in G by Def39;
    \for(x,\not\for(y,A)\imp\ex(y,\notA))\imp
    (\ex(x,\not\for(y,A))\imp\ex(x,\ex(y,\notA))) in G &
    \for(x,\ex(y,\notA)\imp\not\for(y,A))\imp
    (\ex(x,\ex(y,\notA))\imp\ex(x,\not\for(y,A))) in G by A1,Th121;
    then \ex(x,\not\for(y,A))\imp\ex(x,\ex(y,\notA)) in G &
    \ex(x,\ex(y,\notA))\imp\ex(x,\not\for(y,A)) in G by A3,Def38;
    then \ex(x,\not\for(y,A))\iff\ex(x,y,\notA) in G by Th43;
    then \not\ex(x,\not\for(y,A))\iff\not\ex(x,y,\notA) in G by Th94;
    hence thesis by A2,Th91;
  end;

theorem
       L is subst-correct vf-qc-correct implies
  \for(x,A)\iff\for(x,\not\notA) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
    A\imp\not\notA in G & \not\notA\impA in G by Th65,Th64;
    then \for(x,A)\imp\for(x,\not\notA) in G &
    \for(x,\not\notA)\imp\for(x,A) in G by A1,Th115;
    then
A2: (\for(x,A)\imp\for(x,\not\notA))\and
    (\for(x,\not\notA)\imp\for(x,A)) in G by Th35;
    (\for(x,A)\imp\for(x,\not\notA))\and
    (\for(x,\not\notA)\imp\for(x,A))\imp(\for(x,A)\iff\for(x,\not\notA)) in G
    by Def38;
    hence thesis by A2,Def38;
  end;

theorem Th125:
       L is subst-correct vf-qc-correct implies
  \for(x,A\andB)\imp(\for(x,A)\and\for(x,B)) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
    A\andB\impA in G by Def38;
    then
A2: \for(x,A\andB)\imp\for(x,A) in G by A1,Th115;
    A\andB\impB in G by Def38;
    then
A3: \for(x,A\andB)\imp\for(x,B) in G by A1,Th115;
    \for(x,A\andB)\imp\for(x,A)\imp(\for(x,A\andB)\imp\for(x,B)\imp
    (\for(x,A\andB)\imp\for(x,A)\and\for(x,B))) in G by Th49;
    then (\for(x,A\andB)\imp\for(x,B)\imp
    (\for(x,A\andB)\imp\for(x,A)\and\for(x,B))) in G by A2,Def38;
    hence thesis by A3,Def38;
  end;

theorem Th126:
       L is vf-qc-correct subst-correct implies
  (\for(x,A)\and\for(x,B))\imp\for(x,A\andB) in G
  proof set Y = X extended_by ({},the carrier of S1);
    assume
A1: L is vf-qc-correct subst-correct;
    then \for(x,A)\impA in G & \for(x,B)\impB in G by Th104;
    then \for(x,A)\and\for(x,B)\imp(A\andB) in G by Th72;
    then
A2: \for(x,\for(x,A)\and\for(x,B)\imp(A\andB)) in G by Def39;
    consider a being object such that
A3: a in dom X & x in X.a by CARD_5:2;
    J is Subsignature of S1 by Def2;
    then
A4: dom X = the carrier of J c= the carrier of S1 = dom Y
    by INSTALG1:10,PARTFUN1:def 2;
    reconsider a as SortSymbol of J by A3;
    x nin (vf \for(x,A)).a & x nin (vf \for(x,B)).a by A1,A3,A4,Th113;
    then x nin (vf \for(x,A)).a \/ (vf \for(x,B)).a by XBOOLE_0:def 3;
    then x nin ((vf \for(x,A)) (\/) (vf \for(x,B))).a by A4,PBOOLE:def 4;
    then x nin ((vf (\for(x,A)\and\for(x,B)))).a by A1;
    hence (\for(x,A)\and\for(x,B))\imp\for(x,A\andB) in G by A3,A2,Th108;
  end;

theorem Th127:
  L is subst-correct vf-qc-correct implies
  (\for(x,A)\or\for(x,B))\imp\for(x,A\orB) in G
  proof set Y = X extended_by ({},the carrier of S1);
    assume
A1: L is subst-correct vf-qc-correct;
    then \for(x,A)\impA in G & \for(x,B)\impB in G by Th104;
    then \for(x,A)\or\for(x,B)\imp(A\orB) in G by Th59;
    then
A2: \for(x,\for(x,A)\or\for(x,B)\imp(A\orB)) in G by Def39;
    consider a being object such that
A3: a in dom X & x in X.a by CARD_5:2;
    J is Subsignature of S1 by Def2;
    then
A4: the carrier of J c= the carrier of S1 = dom Y &
    dom X = the carrier of J by PARTFUN1:def 2,INSTALG1:10;
    reconsider a as SortSymbol of J by A3;
    reconsider b = a as SortSymbol of S1 by A4;
    x nin (vf \for(x,A)).b & x nin (vf \for(x,B)).b by A1,A3,Th113;
    then x nin (vf \for(x,A)).a \/ (vf \for(x,B)).a by XBOOLE_0:def 3;
    then x nin ((vf \for(x,A)) (\/) (vf \for(x,B))).b by PBOOLE:def 4;
    then x nin ((vf (\for(x,A)\or\for(x,B)))).a by A1;
    hence (\for(x,A)\or\for(x,B))\imp\for(x,A\orB) in G by A2,A3,Th108;
  end;

theorem Th128:
  L is subst-correct vf-qc-correct &
  A\impB in G implies \ex(x,A)\imp\ex(x,B) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
    assume
A2: A\impB in G;
    A\impB\imp(\notB\imp\notA) in G by Th57;
    then \notB\imp\notA in G by A2,Def38;
    then
A3: \for(x,\notB)\imp\for(x,\notA) in G by A1,Th115;
    \for(x,\notB)\imp\for(x,\notA)\imp(\not\for(x,\notA)\imp\not\for(x,\notB))
    in G by Th57;
    then
A4: \not\for(x,\notA)\imp\not\for(x,\notB) in G by A3,Def38;
    \ex(x,A)\iff\not\for(x,\notA) in G by Th105;
    then
A5: \ex(x,A)\imp\not\for(x,\notB) in G by A4,Th92;
    \ex(x,B)\iff\not\for(x,\notB) in G by Th105;
    then \not\for(x,\notB)\iff\ex(x,B) in G by Th90;
    hence thesis by A5,Th93;
  end;

theorem Th129:
  L is subst-correct vf-qc-correct &
  A\iffB in G implies \ex(x,A)\iff\ex(x,B) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
    assume
A2: A\iffB in G;
    (A\iffB)\imp(A\impB) in G & (A\iffB)\imp(B\impA) in G by Def38;
    then A\impB in G & B\impA in G by A2,Def38;
    then \ex(x,A)\imp\ex(x,B) in G & \ex(x,B)\imp\ex(x,A) in G by A1,Th128;
    then
A3: (\ex(x,A)\imp\ex(x,B))\and(\ex(x,B)\imp\ex(x,A)) in G by Th35;
    (\ex(x,A)\imp\ex(x,B))\and(\ex(x,B)\imp\ex(x,A))\imp(\ex(x,A)\iff\ex(x,B))
    in G by Def38;
    hence thesis by A3,Def38;
  end;

theorem
  L is subst-correct vf-qc-correct implies
  \ex(x,A)\iff\ex(x,\not\notA) in G
  proof
    A\iff\not\notA in G by Th66;
    hence thesis by Th129;
  end;

theorem
  L is subst-correct vf-qc-correct implies
  \ex(x,A)\or\ex(x,B)\iff\ex(x,A\orB) in G
  proof assume
A1: L is subst-correct vf-qc-correct;
    then \for(x,\notA\and\notB)\imp\for(x,\notA)\and\for(x,\notB) in G
    by Th125;
    then
A2: \not(\for(x,\notA)\and\for(x,\notB))\imp\not\for(x,\notA\and\notB)
    in G by Th58;
    \not\for(x,\notA)\or\not\for(x,\notB)\imp
    \not(\for(x,\notA)\and\for(x,\notB)) in G by Th73;
    then
A3: \not\for(x,\notA)\or\not\for(x,\notB)\imp\not\for(x,\notA\and\notB)
    in G by A2,Th45;
    \not(A\orB)\imp(\notA\and\notB) in G by Th71;
    then \for(x,\not(A\orB))\imp\for(x,\notA\and\notB) in G by A1,Th115;
    then \not\for(x,\notA\and\notB)\imp\not\for(x,\not(A\orB)) in G by Th58;
    then
A4: \not\for(x,\notA)\or\not\for(x,\notB)\imp\not\for(x,\not(A\orB)) in G
    by A3,Th45;
    \ex(x,A\orB)\iff\not\for(x,\not(A\orB)) in G by Th105;
    then \not\for(x,\not(A\orB))\iff\ex(x,A\orB) in G by Th90;
    then
A5: \not\for(x,\notA)\or\not\for(x,\notB)\imp\ex(x,A\orB) in G by A4,Th93;
    \ex(x,A)\iff\not\for(x,\notA) in G & \ex(x,B)\iff\not\for(x,\notB) in G
    by Th105;
    then \ex(x,A)\imp\not\for(x,\notA) in G &
    \ex(x,B)\imp\not\for(x,\notB) in G by Th43;
    then \ex(x,A)\or\ex(x,B)\imp(\not\for(x,\notA)\or\not\for(x,\notB)) in G
    by Th59;
    then
A6: \ex(x,A)\or\ex(x,B)\imp\ex(x,A\orB) in G by A5,Th45;
A7: \ex(x,A)\iff\not\for(x,\notA) in G & \ex(x,B)\iff\not\for(x,\notB) in G
    by Th105;
A8: \not\for(x,\notA)\imp\ex(x,A) in G &
    \not\for(x,\notB)\imp\ex(x,B) in G by A7,Th43;
    \ex(x,A\orB)\iff\not\for(x,\not(A\orB)) in G by Th105;
    then
A9: \ex(x,A\orB)\imp\not\for(x,\not(A\orB)) in G by Th43;
    \notA\and\notB\imp\not(A\orB) in G by Th74;
    then \for(x,\notA\and\notB)\imp\for(x,\not(A\orB)) in G by A1,Th115;
    then \not\for(x,\not(A\orB))\imp\not\for(x,\notA\and\notB) in G by Th58;
    then
A10: \ex(x,A\orB)\imp\not\for(x,\notA\and\notB) in G by A9,Th45;
A11: \not\for(x,\notA)\or\not\for(x,\notB)\imp\ex(x,A)\or\ex(x,B) in G
    by A8,Th59;
    \not(\for(x,\notA)\and\for(x,\notB))\imp\not\for(x,\notA)\or
    \not\for(x,\notB) in G by Th70;
    then
A12: \not(\for(x,\notA)\and\for(x,\notB))\imp\ex(x,A)\or\ex(x,B) in G
    by A11,Th45;
    (\for(x,\notA)\and\for(x,\notB))\imp\for(x,\notA\and\notB) in G
    by A1,Th126;
    then \not\for(x,\notA\and\notB)\imp\not(\for(x,\notA)\and\for(x,\notB))
    in G by Th58;
    then \ex(x,A\orB)\imp\not(\for(x,\notA)\and\for(x,\notB)) in G by A10,Th45;
    then \ex(x,A\orB)\imp\ex(x,A)\or\ex(x,B) in G by A12,Th45;
    hence thesis by A6,Th43;
  end;

theorem
  L is subst-correct implies
  for a being SortSymbol of J st x in X.a & x nin (vf A).a
  holds A\iff\for(x,A) in G
  proof
    assume
A1: L is subst-correct;
    let a be SortSymbol of J; assume
A2: x in X.a & x nin (vf A).a;
A3: \for(x,A\impA)\imp(\for(x,A)\impA) in G by A1,Th107;
    A\impA in G by Th34;
    then \for(x,A\impA) in G by Def39;
    then \for(x,A)\impA in G & A\imp\for(x,A) in G by A2,A3,Def38,Th108;
    hence thesis by Th43;
  end;

reserve a for SortSymbol of J;

theorem Th133:
  L is subst-correct vf-qc-correct &
  x in X.a & x nin (vf A).a implies \for(x,A\orB)\imp(A\or\for(x,B)) in G
  proof
    assume
A1: L is subst-correct vf-qc-correct;
    assume
A2: x in X.a & x nin (vf A).a;
    set c = a, a = \notA, b = B;
    x nin (vf a).c by A1,A2; then
A3: \for(x,a\impb)\imp(a\imp\for(x,b)) in G by A2,Def39;
    A\orb\imp(a\impb) in G by Th62;
    then \for(x,A\orB)\imp\for(x,a\impB) in G by A1,Th115;
    then
A4: \for(x,A\orB)\imp(a\imp\for(x,b)) in G by A3,Th45;
    \nota\impA in G & \for(x,B)\imp\for(x,B) in G by Th34,Th65;
    then \nota\or\for(x,B)\impA\or\for(x,B) in G &
    a\imp\for(x,B)\imp\nota\or\for(x,B) in G by Th59,Th82;
    then a\imp\for(x,B)\impA\or\for(x,B) in G by Th45;
    hence thesis by A4,Th45;
  end;

theorem Th134:
  L is subst-correct vf-qc-correct &
  x in X.a & x nin (vf A).a implies \ex(x,A\andB)\impA\and\ex(x,B) in G
  proof
    assume
A1: L is subst-correct vf-qc-correct;
    assume
A2: x in X.a & x nin (vf A).a;
    (\for(x,\notA)\or\for(x,\notB))\imp\for(x,\notA\or\notB) in G by A1,Th127;
    then
A3: \not\for(x,\notA\or\notB)\imp\not(\for(x,\notA)\or\for(x,\notB)) in G
    by Th58;
    \notA\or\notB\imp\not(A\andB) in G by Th73;
    then \ex(x,A\andB)\iff\not\for(x,\not(A\andB)) in G &
    \for(x,\notA\or\notB)\imp\for(x,\not(A\andB)) in G by A1,Th115,Th105;
    then \not\for(x,\not(A\andB))\imp\not\for(x,\notA\or\notB) in G &
    \ex(x,A\andB)\imp\not\for(x,\not(A\andB)) in G by Th43,Th58;
    then \ex(x,A\andB)\imp\not\for(x,\notA\or\notB) in G by Th45;
    then
A4: \ex(x,A\andB)\imp\not(\for(x,\notA)\or\for(x,\notB)) in G by A3,Th45;
    \ex(x,A)\iff\not\for(x,\notA) in G & \ex(x,B)\iff\not\for(x,\notB) in G
    by Th105;
    then \not\for(x,\notA)\imp\ex(x,A) in G &
    \not\for(x,\notB)\imp\ex(x,B) in G by Th43;
    then
A5: \not(\for(x,\notA))\and\not\for(x,\notB)\imp\ex(x,A)\and\ex(x,B) in G
    by Th72;
    \not(\for(x,\notA)\or\for(x,\notB))\imp
    \not\for(x,\notA)\and\not\for(x,\notB) in G by Th71;
    then \ex(x,A\andB)\imp\not\for(x,\notA)\and\not\for(x,\notB) in G
    by A4,Th45;
    then
A6: \ex(x,A\andB)\imp\ex(x,A)\and\ex(x,B) in G by A5,Th45;
    A\impA in G by Th34;
    then \for(x,A\impA) in G &
    \for(x,A\impA)\imp(\ex(x,A)\impA) in G by A1,A2,Th120,Def39;
    then \ex(x,A)\impA in G & \ex(x,B)\imp\ex(x,B) in G by Def38,Th34;
    then \ex(x,A)\and\ex(x,B)\impA\and\ex(x,B) in G by Th72;
    hence \ex(x,A\andB)\impA\and\ex(x,B) in G by A6,Th45;
  end;

theorem
  L is subst-correct vf-qc-correct &
  x in X.a & x nin (vf A).a implies \ex(x,A\andB)\iffA\and\ex(x,B) in G
  proof set Y = X extended_by ({},the carrier of S1);
    assume A1: L is subst-correct vf-qc-correct;
    assume A2: x in X.a;
    assume A3: x nin (vf A).a;
    vf \notA = vf A by A1;
    then \for(x,\notA\or\notB)\imp\notA\or\for(x,\notB) in G by A1,A2,A3,Th133;
    then
A4: \not(\notA\or\for(x,\notB))\imp\not\for(x,\notA\or\notB) in G by Th58;
    \for(x,\notB)\iff\not\ex(x,B) in G by A1,Th122;
    then \notA\imp\notA in G & \for(x,\notB)\imp\not\ex(x,B) in G by Th34,Th43;
    then \notA\or\not\ex(x,B)\imp\not(A\and\ex(x,B)) in G &
    (\notA\or\for(x,\notB))\imp(\notA\or\not\ex(x,B)) in G &
    (\notA\or\not\ex(x,B))\imp\not(A\and\ex(x,B)) in G by Th59,Th73;
    then (A\and\ex(x,B))\imp\not(\notA\or\not\ex(x,B)) in G &
    \not(\notA\or\not\ex(x,B))\imp\not(\notA\or\for(x,\notB)) in G
    by Th58,Th67;
    then (A\and\ex(x,B))\imp\not(\notA\or\for(x,\notB)) in G by Th45;
    then
A5: A\and\ex(x,B)\imp\not\for(x,\notA\or\notB) in G by A4,Th45;
    \ex(x,A\andB)\iff\not\for(x,\not(A\andB)) in G &
    \not(A\andB)\imp\notA\or\notB in G by Th70,Th105;
    then \not\for(x,\not(A\andB))\imp\ex(x,A\andB) in G &
    \for(x,\not(A\andB)\imp\notA\or\notB) in G &
    \for(x,\not(A\andB)\imp\notA\or\notB)\imp
    (\for(x,\not(A\andB))\imp\for(x,\notA\or\notB)) in G
    by A1,Def39,Th43,Th109;
    then \not\ex(x,A\andB)\imp\for(x,\not(A\andB)) in G &
    \for(x,\not(A\andB))\imp\for(x,\notA\or\notB) in G by Def38,Th68;
    then \not\ex(x,A\andB)\imp\for(x,\notA\or\notB) in G by Th45;
    then \not\for(x,\notA\or\notB)\imp\ex(x,A\andB) in G by Th68;
    then
A6: A\and\ex(x,B)\imp\ex(x,A\andB) in G by A5,Th45;
    \ex(x,A\andB)\impA\and\ex(x,B) in G by Th134,A1,A2,A3;
    hence \ex(x,A\andB)\iffA\and\ex(x,B) in G by A6,Th43;
  end;

theorem
  L is subst-correct vf-qc-correct &
  x in X.a & x nin (vf A).a implies \ex(x,A\impB)\imp(A\imp\ex(x,B)) in G
  proof
    assume
A1: L is subst-correct vf-qc-correct;
    assume
A2: x in X.a & x nin (vf A).a;
    A\impA in G by Th34;
    then \for(x,A\impA) in G by Def39;
    then A\imp\for(x,A) in G & \for(x,\notB)\imp\for(x,\notB) in G
    by A2,Th108,Th34;
    then
A3: A\and\for(x,\notB)\imp\for(x,A)\and\for(x,\notB) in G by Th72;
    \for(x,A)\and\for(x,\notB)\imp\for(x,A\and\notB) in G by A1,Th126;
    then A\and\for(x,\notB)\imp\for(x,A\and\notB) in G by A3,Th45;
    then
A4: \not\for(x,A\and\notB)\imp\not(A\and\for(x,\notB)) in G by Th58;
    \notA\imp\notA in G & B\imp\not\notB in G by Th34,Th64;
    then
A5: \notA\orB\imp\notA\or\not\notB in G by Th59;
    \notA\or\not\notB\imp\not(A\and\notB) in G by Th73;
    then A\and\notB\imp\not\not(A\and\notB) in G &
    \not\not(A\and\notB)\imp\not(\notA\or\not\notB) in G by Th58,Th64;
    then A\impB\imp\notA\orB in G & \not(\notA\or\not\notB)\imp\not(\notA\orB)
    in G & A\and\notB\imp\not(\notA\or\not\notB) in G by A5,Th82,Th58,Th45;
    then \not(\notA\orB)\imp\not(A\impB) in G &
    A\and\notB\imp\not(\notA\orB) in G by Th58,Th45;
    then A\and\notB\imp\not(A\impB) in G by Th45;
    then \for(x,A\and\notB)\imp\for(x,\not(A\impB)) in G by A1,Th115;
    then \ex(x,A\impB)\iff\not\for(x,\not(A\impB)) in G &
    \not\for(x,\not(A\impB))\imp\not\for(x,A\and\notB) in G by Th105,Th58;
    then \ex(x,A\impB)\imp\not\for(x,A\and\notB) in G by Th92;
    then
A6: \ex(x,A\impB)\imp\not(A\and\for(x,\notB)) in G by A4,Th45;
    \ex(x,B)\iff\not\for(x,\notB) in G by Th105;
    then \notA\imp\notA in G & \not\for(x,\notB)\imp\ex(x,B) in G by Th34,Th43;
    then \not(A\and\for(x,\notB))\imp\notA\or\not\for(x,\notB) in G &
    \notA\or\not\for(x,\notB)\imp\notA\or\ex(x,B) in G by Th59,Th70;
    then \not(A\and\for(x,\notB))\imp\notA\or\ex(x,B) in G by Th45;
    then
A7: \ex(x,A\impB)\imp\notA\or\ex(x,B) in G by A6,Th45;
    A\imp\not\notA in G & \ex(x,B)\imp\ex(x,B) in G by Th34,Th64;
    then \notA\or\ex(x,B)\imp(\not\notA\imp\ex(x,B)) in G &
    (\not\notA\imp\ex(x,B))\imp(A\imp\ex(x,B)) in G by Th62,Th103;
    then \notA\or\ex(x,B)\imp(A\imp\ex(x,B)) in G by Th45;
    hence \ex(x,A\impB)\imp(A\imp\ex(x,B)) in G by A7,Th45;
  end;

theorem
  L is vf-qc-correct implies
  \for(x,A)\imp\for(x,x,A) in G
  proof assume
A1: L is vf-qc-correct;
    consider a being object such that
A2: a in dom X & x in X.a by CARD_5:2;
    reconsider a as Element of J by A2;
    set Y = X extended_by({}, the carrier of S1);
A3: a is SortSymbol of S1 by Th8;
A4: x nin (vf\for(x,A)).a by A1,A2,A3,Th113;
    \for(x,A)\imp\for(x,A) in G by Th34;
    then \for(x,\for(x,A)\imp\for(x,A)) in G by Def39;
    hence thesis by A2,A4,Th108;
  end;

theorem Th138:
  L is vf-qc-correct subst-correct implies
  \for(x,y,A)\imp\for(y,x,A) in G
  proof
    assume A1: L is vf-qc-correct subst-correct;
    then \for(y,A)\impA in G by Th104;
    then
A2: \for(x,\for(y,A)\impA) in G by Def39;
    \for(x,\for(y,A)\impA)\imp(\for(x,\for(y,A))\imp\for(x,A)) in G
    by A1,Th109;
    then \for(x,\for(y,A))\imp\for(x,A) in G by A2,Def38;
    then
A3: \for(y,\for(x,\for(y,A))\imp\for(x,A)) in G by Def39;
    consider a being object such that
A4: a in dom X & y in X.a by CARD_5:2;
    consider b being object such that
A5: b in dom X & x in X.b by CARD_5:2;
    J is Subsignature of S1 by Def2;
    then dom X = the carrier of J c= the carrier of S1
    by PARTFUN1:def 2,INSTALG1:10;
    then reconsider a,b as Element of S1 by A4,A5;
    reconsider c = a as Element of J by A4;
    vf\for(x,y,A) = (vf\for(y,A))(\)(b-singleton(x)) by A1,A5;
    then (vf\for(x,y,A)).a = (vf\for(y,A)).a\(b-singleton(x)).a
    by PBOOLE:def 6;
    then y nin (vf\for(x,y,A)).c by A1,A4,Th113;
    hence \for(x,y,A)\imp\for(y,x,A) in G by A3,A4,Th108;
  end;

theorem
  L is vf-qc-correct subst-correct implies
  \ex(x,y,A)\imp\ex(y,x,A) in G
  proof
    assume A1: L is vf-qc-correct subst-correct;
    then \for(y,x,\notA)\imp\for(x,y,\notA) in G by Th138;
    then
A2: \not\for(x,y,\notA)\imp\not\for(y,x,\notA) in G by Th58;
    \ex(x,y,A)\iff\not\for(x,y,\notA) in G &
    \ex(y,x,A)\iff\not\for(y,x,\notA) in G by A1,Th111;
    then \ex(x,y,A)\imp\not\for(y,x,\notA) in G &
    \not\for(y,x,\notA)\iff\ex(y,x,A) in G by A2,Th90,Th92;
    hence \ex(x,y,A)\imp\ex(y,x,A) in G by Th93;
  end;

theorem
  L is vf-qc-correct subst-correct implies
  \ex(x,\for(y,A))\imp\for(y,\ex(x,A)) in G
  proof
    assume A1: L is vf-qc-correct subst-correct;
    then A\imp\ex(x,A) in G by Th112;
    then \for(y,A\imp\ex(x,A)) in G &
    \for(y,A\imp\ex(x,A))\imp(\for(y,A)\imp\for(y,\ex(x,A))) in G
    by A1,Def39,Th109;
    then \for(y,A)\imp\for(y,\ex(x,A)) in G by Def38;
    then
A2: \for(x,\for(y,A)\imp\for(y,\ex(x,A))) in G by Def39;
    consider a being object such that
A3: a in dom X & y in X.a by CARD_5:2;
    consider b being object such that
A4: b in dom X & x in X.b by CARD_5:2;
    J is Subsignature of S1 by Def2;
    then dom X = the carrier of J c= the carrier of S1
    by PARTFUN1:def 2,INSTALG1:10;
    then reconsider a,b as Element of S1 by A3,A4;
    reconsider c = b as Element of J by A4;
    vf\for(y,\ex(x,A)) = (vf\ex(x,A))(\)(a-singleton(y)) by A1,A3;
    then (vf\for(y,\ex(x,A))).b = (vf\ex(x,A)).b\(a-singleton(y)).b
    by PBOOLE:def 6;
    then x nin (vf\for(y,\ex(x,A))).c by A1,A4,Th114;
    then \for(x,\for(y,A)\imp\for(y,\ex(x,A)))\imp
    (\ex(x,\for(y,A))\imp\for(y,\ex(x,A))) in G by A1,A4,Th120;
    hence \ex(x,\for(y,A))\imp\for(y,\ex(x,A)) in G by A2,Def38;
  end;

theorem
  L is subst-correct vf-qc-correct implies
  \for(x,A\andA)\iff\for(x,A) in G
  proof
    assume A1: L is subst-correct vf-qc-correct;
    A\andA\impA in G & A\impA\andA in G by Def38,Th53;
    then
A2: \for(x,A\andA\impA) in G & \for(x,A\impA\andA) in G by Def39;
    \for(x,A\impA\andA)\imp(\for(x,A)\imp\for(x,A\andA)) in G &
    \for(x,A\andA\impA)\imp(\for(x,A\andA)\imp\for(x,A)) in G by A1,Th109;
    then (\for(x,A)\imp\for(x,A\andA)) in G &
    (\for(x,A\andA)\imp\for(x,A)) in G by A2,Def38;
    hence \for(x,A\andA)\iff\for(x,A) in G by Th43;
  end;

theorem
  L is subst-correct vf-qc-correct implies
  \for(x,A\orA)\iff\for(x,A) in G
  proof
    assume A1: L is subst-correct vf-qc-correct;
    A\orA\impA in G & A\impA\orA in G by Def38,Th52;
    then
A2: \for(x,A\orA\impA) in G & \for(x,A\impA\orA) in G by Def39;
    \for(x,A\impA\orA)\imp(\for(x,A)\imp\for(x,A\orA)) in G &
    \for(x,A\orA\impA)\imp(\for(x,A\orA)\imp\for(x,A)) in G by A1,Th109;
    then (\for(x,A)\imp\for(x,A\orA)) in G &
    (\for(x,A\orA)\imp\for(x,A)) in G by A2,Def38;
    hence \for(x,A\orA)\iff\for(x,A) in G by Th43;
  end;

theorem
  L is subst-correct vf-qc-correct implies
  \ex(x,A\orA)\iff\ex(x,A) in G
  proof
    A\orA\impA in G & A\impA\orA in G by Def38,Th52;
    then A\orA\iffA in G by Th43;
    hence thesis by Th129;
  end;

reserve
  L for non-empty T-extension Language of
  X extended_by ({},the carrier of S1), S1,
  G1 for QC-theory_with_equality of L,
  A,B,C,D for Formula of L,
  s,s1 for SortSymbol of S1,
  t,t9 for Element of L,s,
  t1,t2,t3 for Element of L,s1;

theorem
  L is subst-eq-correct & x0 in X.s & t1 '=' (t2,L) in G1
  implies (t1/(x0,t) '=' (t2/(x0,t),L)) in G1
  proof
    assume A1: L is subst-eq-correct;
    set Y = X extended_by({}, the carrier of S1);
    assume A2: x0 in X.s;
    then
A3: s in dom X = the carrier of J & dom Y = the carrier of S1
    by FUNCT_1:def 2,PARTFUN1:def 2;
    then reconsider x = x0 as Element of Union X by A2,CARD_5:2;
A4: Y.s = X.s by A3,Th1;
    assume t1 '=' (t2,L) in G1;
    then \for(x,t1 '=' (t2,L)) in G1 &
    \for(x,t1 '='(t2,L))\imp((t1 '=' (t2,L))/(x0,t)) in G1 by A3,A4,A2,Def39;
    then (t1 '=' (t2,L))/(x0,t) in G1 by Def38;
    hence (t1/(x0,t) '=' (t2/(x0,t),L)) in G1 by A1,A2;
  end;

theorem ThOne:
  L is subst-eq-correct vf-finite subst-correct2 subst-correct3 &
  s1 in the carrier of J & X.s1 is infinite implies
  t1 '=' (t2,L)\imp(t2 '=' (t1,L)) in G1
  proof
    assume that
A0: L is subst-eq-correct vf-finite subst-correct2 subst-correct3 and
A1: s1 in the carrier of J and
A3: X.s1 is infinite;
    set Y = X extended_by({}, the carrier of S1);
    vf t1 is finite-yielding by A0;
    then (vf t1).s1 is finite by FINSET_1:def 5;
    then
A4: the Element of X.s1\((vf t1).s1) in X.s1 &
    the Element of X.s1\((vf t1).s1) nin (vf t1).s1 by A3,XBOOLE_0:def 5;
    dom X = the carrier of J & dom Y = the carrier of S1 by PARTFUN1:def 2;
    then
A8: the Element of X.s1\((vf t1).s1) in Y.s1 by A1,A4,Th1;
    dom X = the carrier of J & X.s1\((vf t1).s1) c= X.s1 by PARTFUN1:def 2;
    then reconsider x = the Element of X.s1\((vf t1).s1) as Element of Union X
    by A1,A4,CARD_5:2;
    reconsider x0 = x as Element of Union Y by Th24;
    X.s1 c= (the Sorts of T).s1 = (the Sorts of L).s1
    by A1,Th16,PBOOLE:def 2,def 18;
    then reconsider t = x as Element of L,s1 by A4;
    reconsider j = s1 as SortSymbol of J by A1;
    reconsider q1 = t1, q2 = t2 as Element of T,j by Th16;
A2: (t1 '=' (t2,L))\imp(((x '=' (t1,L))/(x0,t1))\imp((x '=' (t1,L))/(x0,t2)))
    in G1 by A4,Def42;
    (t '=' (t1,L))/(x0,t1) = (t/(x0,t1)) '=' (t1/(x0,t1),L) by A0,A4
    .= (t/(x0,t1)) '=' (t1,L) by A0,A8
    .= q1 '=' (q1,L) by A0,A8;
    then
A9: (t '=' (t1,L))/(x0,t1) in G1 by Def42;
    (t '=' (t1,L))/(x0,t2) = (t/(x0,t2)) '=' (t1/(x0,t2),L) by A0,A4
    .= (t/(x0,t2)) '=' (t1,L) by A0,A8
    .= t2 '=' (t1,L) by A0,A8;
    hence thesis by A2,A9,Th46;
  end;

theorem
  L is subst-eq-correct vf-finite subst-correct2 subst-correct3 &
  s1 in the carrier of J & X.s1 is infinite implies
  t1 '=' (t2,L)\and(t2 '=' (t3,L))\imp(t1 '=' (t3,L)) in G1
  proof
    assume that
A0: L is subst-eq-correct vf-finite subst-correct2 subst-correct3 and
A1: s1 in the carrier of J and
A3: X.s1 is infinite;
    set Y = X extended_by({}, the carrier of S1);
    vf t3 is finite-yielding by A0;
    then (vf t3).s1 is finite by FINSET_1:def 5;
    then
A4: the Element of X.s1\((vf t3).s1) in X.s1 &
    the Element of X.s1\((vf t3).s1) nin (vf t3).s1 by A3,XBOOLE_0:def 5;
    dom X = the carrier of J & dom Y = the carrier of S1 by PARTFUN1:def 2;
    then
A8: the Element of X.s1\((vf t3).s1) in Y.s1 by A1,A4,Th1;
    dom X = the carrier of J & X.s1\((vf t1).s1) c= X.s1 by PARTFUN1:def 2;
    then reconsider x = the Element of X.s1\((vf t3).s1) as Element of Union X
    by A1,A4,CARD_5:2;
    reconsider x0 = x as Element of Union Y by Th24;
    X.s1 c= (the Sorts of T).s1 = (the Sorts of L).s1
    by A1,Th16,PBOOLE:def 2,def 18;
    then reconsider t = x as Element of L,s1 by A4;
A5: (t2 '=' (t1,L))\imp((t '=' (t3,L))/(x0,t2)\imp((t '=' (t3,L))/(x0,t1)))
    in G1 by A4,Def42;
    (t1 '=' (t2,L))\imp(t2 '=' (t1,L)) in G1 by A0,A1,A3,ThOne;
    then
A6: (t1 '=' (t2,L))\imp((t '=' (t3,L))/(x0,t2)\imp((t '=' (t3,L))/(x0,t1)))
    in G1 by A5,Th45;
A7: (t '=' (t3,L))/(x0,t2) = (t/(x0,t2)) '=' (t3/(x0,t2),L)
    by A0,A4
    .= (t/(x0,t2)) '=' (t3,L) by A0,A8
    .= t2 '=' (t3,L) by A0,A8;
A2: (t '=' (t3,L))/(x0,t1) = (t/(x0,t1)) '=' (t3/(x0,t1),L)
    by A0,A4
    .= (t/(x0,t1)) '=' (t3,L) by A0,A8
    .= t1 '=' (t3,L) by A0,A8;
    (t1 '=' (t2,L))\imp((t2 '=' (t3,L))\imp(t1 '=' (t3,L)))\imp
    (t1 '=' (t2,L)\and(t2 '=' (t3,L))\imp(t1 '=' (t3,L))) in G1 by Th48;
    hence thesis by A7,A6,A2,Def38;
  end;

theorem
  L is subst-correct3 vf-finite subst-correct2 subst-correct subst-eq-correct
  vf-qc-correct vf-eq-correct &
  x = x0 in X.s & y = y0 in X.s & x <> y nin (vf A).s & X.s is infinite implies
  \for(x,A\iff\ex(y, x '=' (y,L)\and(A/(x0,y0)))) in G1
  proof
    set Y = X extended_by({}, the carrier of S1);
    assume that
A0: L is subst-correct3 vf-finite subst-correct2 subst-correct subst-eq-correct
    vf-qc-correct vf-eq-correct and
A1: x = x0 in X.s & y = y0 in X.s & x <> y nin (vf A).s & X.s is infinite;
A2: s in dom X = the carrier of J by A1,FUNCT_1:def 2,PARTFUN1:def 2;
    then X.s c= (the Sorts of T).s = (the Sorts of L).s
    by Th16,PBOOLE:def 2,def 18;
    then reconsider t1 = x0, t2 = y0 as Element of L,s by A1;
    reconsider j = s as SortSymbol of J by A2;
    reconsider q1 = t1, q2 = t2 as Element of T,j by Th16;
A3: t2 '=' (t1,L)\imp(A/(x0,y0)/(y0,t2)\imp(A/(x0,y0)/(y0,t1))) in G1
    by A1,Def42;
    t1 '=' (t2,L)\imp(t2 '=' (t1,L)) in G1 by A0,A1,A2,ThOne;
    then
A8: t1 '=' (t2,L)\imp(A/(x0,y0)/(y0,t2)\imp(A/(x0,y0)/(y0,t1))) in G1
    by A3,Th45;
    dom Y = the carrier of S1 by PARTFUN1:def 2;
    then
A4: X.s = Y.s & (the Sorts of L).the formula-sort of S1 <> {} &
    Y is ManySortedSubset of the Sorts of L by A2,Th1,Th23;
    then
A5: A/(x0,y0)/(y0,t1) = A/(x0,y0)/(y0,x0) by A1,Th14
    .= A by A0,A1,A4;
A6: A/(x0,y0)/(y0,t2) = A/(x0,y0)/(y0,y0) by A1,A4,Th14
    .= A/(x0,y0) by A0,A1,A4;
    (t1 '=' (t2,L)\imp(A/(x0,y0)\impA))\imp
    (t1 '=' (t2,L)\and(A/(x0,y0))\impA) in G1 by Th48;
    then t1 '=' (t2,L)\and(A/(x0,y0))\impA in G1 by A8,A5,A6,Def38;
    then \for(y,t1 '=' (t2,L)\and(A/(x0,y0))\impA) in G1 &
    \for(y,t1 '=' (t2,L)\and(A/(x0,y0))\impA)\imp
    (\ex(y,t1 '=' (t2,L)\and(A/(x0,y0)))\impA) in G1
    by A0,A1,A2,Th120,Def39;
    then
A9: \ex(y,t1 '=' (t2,L)\and(A/(x0,y0)))\impA in G1 by Def38;
B1: (t1 '=' (t2,L)\and(A/(x0,y0)))/(y0,x0)\imp
    \ex(y, t1 '=' (t2,L)\and(A/(x0,y0))) in G1
    by A0,A1,A2,Th110;
    vf t1 = s-singleton x0 by A0,A1;
    then (vf t1).s = {x0} by AOFA_A00:6;
    then
B2: y0 nin (vf t1).s by A1,TARSKI:def 1;
B3: (t1 '=' (t2,L)\and(A/(x0,y0)))/(y0,x0)
    = ((t1 '=' (t2,L))/(y0,x0))\and(A/(x0,y0)/(y0,x0))
    by A0,A1,A4,Th27
    .= ((t1 '=' (t2,L))/(y0,x0))\andA by A0,A1,A4
    .= ((t1 '=' (t2,L))/(y0,t1))\andA by A1,A4,Th14
    .= t1/(y0,t1) '=' (t2/(y0,t1),L)\andA by A0,A1
    .= t1 '=' (t2/(y0,t1),L)\andA by B2,A0,A1,A4
    .= t1 '=' (t1,L)\andA by A0,A1,A4;
    q1 '=' (q1,L) in G1 by Def42;
    then A\imp(t1 '=' (t1,L)) in G1 & A\impA in G1 by Th34,Th44;
    then A\imp(t1 '=' (t1,L))\andA in G1 by Th201;
    then A\imp\ex(y, t1 '=' (t2,L)\and(A/(x0,y0))) in G1 by B1,B3,Th45;
    then A\iff\ex(y, t1 '=' (t2,L)\and(A/(x0,y0))) in G1 by A9,Th43;
    hence thesis by A1,Def39;
  end;

theorem
  L is subst-correct3 vf-finite subst-correct2 subst-correct subst-eq-correct
  vf-qc-correct vf-eq-correct &
  x = x0 in X.s & y = y0 in X.s & x <> y nin (vf A).s & X.s is infinite implies
  \for(x,A\iff\for(y, x '=' (y,L)\imp(A/(x0,y0)))) in G1
  proof
    set Y = X extended_by({}, the carrier of S1);
    assume that
A0: L is subst-correct3 vf-finite subst-correct2 subst-correct subst-eq-correct
    vf-qc-correct vf-eq-correct and
A1: x = x0 in X.s & y = y0 in X.s & x <> y nin (vf A).s & X.s is infinite;
A2: s in dom X = the carrier of J by A1,FUNCT_1:def 2,PARTFUN1:def 2;
    then X.s c= (the Sorts of T).s = (the Sorts of L).s
    by Th16,PBOOLE:def 2,def 18;
    then reconsider t1 = x0, t2 = y0 as Element of L,s by A1;
    reconsider j = s as SortSymbol of J by A2;
    reconsider q1 = t1, q2 = t2 as Element of T,j by Th16;
A3: t1 '=' (t2,L)\imp(A/(x0,y0)/(y0,t1)\imp(A/(x0,y0)/(y0,t2))) in G1
    by A1,Def42;
    dom Y = the carrier of S1 by PARTFUN1:def 2;
    then
A4: X.s = Y.s & (the Sorts of L).the formula-sort of S1 <> {} &
    Y is ManySortedSubset of the Sorts of L by A2,Th1,Th23;
    then
A5: A/(x0,y0)/(y0,t1) = A/(x0,y0)/(y0,x0) by A1,Th14
    .= A by A0,A1,A4;
A6: A/(x0,y0)/(y0,t2) = A/(x0,y0)/(y0,y0) by A1,A4,Th14
    .= A/(x0,y0) by A0,A1,A4;
    A\imp(t1 '=' (t2,L)\imp(A/(x0,y0))) in G1 by A3,A5,A6,Th38;
    then \for(y,A\imp(t1 '=' (t2,L)\imp(A/(x0,y0)))) in G1 by Def39;
    then
A9: A\imp\for(y,t1 '=' (t2,L)\imp(A/(x0,y0))) in G1 by A1,A2,Th108;
B1: (t1 '=' (t2,L)\and(\not(A/(x0,y0))))/(y0,x0)\imp
    \ex(y, t1 '=' (t2,L)\and(\not(A/(x0,y0)))) in G1
    by A0,A1,A2,Th110;
    vf t1 = s-singleton x0 by A0,A1;
    then (vf t1).s = {x0} by AOFA_A00:6;
    then
B2: y0 nin (vf t1).s by A1,TARSKI:def 1;
B3: (t1 '=' (t2,L)\and(\not(A/(x0,y0))))/(y0,x0)
    = ((t1 '=' (t2,L))/(y0,x0))\and(\not(A/(x0,y0))/(y0,x0))
    by A0,A1,A4,Th27
    .= ((t1 '=' (t2,L))/(y0,x0))\and(\not(A/(x0,y0)/(y0,x0))) by A0,A1,A4,Th27
    .= ((t1 '=' (t2,L))/(y0,x0))\and\notA by A0,A1,A4
    .= ((t1 '=' (t2,L))/(y0,t1))\and\notA by A1,A4,Th14
    .= t1/(y0,t1) '=' (t2/(y0,t1),L)\and\notA by A0,A1
    .= t1 '=' (t2/(y0,t1),L)\and\notA by B2,A0,A1,A4
    .= t1 '=' (t1,L)\and\notA by A0,A1,A4;
    q1 '=' (q1,L) in G1 by Def42;
    then \notA\imp(t1 '=' (t1,L)) in G1 & \notA\imp\notA in G1 by Th34,Th44;
    then \notA\imp(t1 '=' (t1,L))\and\notA in G1 by Th201;
    then (\notA)\imp\ex(y, t1 '=' (t2,L)\and(\not(A/(x0,y0)))) in G1
    by B1,B3,Th45;
    then
B4: \not\ex(y,t1 '=' (t2,L)\and(\not(A/(x0,y0))))\impA in G1 by Th68;
    (A/(x0,y0))\imp\not\not(A/(x0,y0)) in G1 &
    \not(t1 '=' (t2,L))\imp\not(t1 '=' (t2,L)) in G1 by Th34,Th64;
    then
    \not(t1 '=' (t2,L))\or\not\not(A/(x0,y0))\imp
    \not(t1 '=' (t2,L)\and\not(A/(x0,y0))) in G1 &
    \not(t1 '=' (t2,L))\or(A/(x0,y0))\imp
    \not(t1 '=' (t2,L))\or\not\not(A/(x0,y0)) in G1 by Th73,Th59;
    then
    \not(t1 '=' (t2,L))\or(A/(x0,y0))\imp\not(t1 '=' (t2,L)\and\not(A/(x0,y0)))
    in G1 &
    (t1 '=' (t2,L)\imp(A/(x0,y0)))\imp\not(t1 '=' (t2,L))\or(A/(x0,y0)) in G1
    by Th45,Th82;
    then
    (t1 '=' (t2,L)\imp(A/(x0,y0)))\imp\not(t1 '=' (t2,L)\and\not(A/(x0,y0)))
    in G1 by Th45;
    then
    (t1 '=' (t2,L)\and\not(A/(x0,y0)))\imp\not(t1 '=' (t2,L)\imp(A/(x0,y0)))
    in G1 by Th67;
    then
    \ex(y,t1 '=' (t2,L)\and\not(A/(x0,y0)))\imp
    \ex(y,\not(t1 '=' (t2,L)\imp(A/(x0,y0)))) in G1 by A0,Th128;
    then
    \not\ex(y,\not(t1 '=' (t2,L)\imp(A/(x0,y0))))\imp
    \not\ex(y,t1 '=' (t2,L)\and\not(A/(x0,y0))) in G1 by Th58;
    then
    \not\ex(y,\not(t1 '=' (t2,L)\imp(A/(x0,y0))))\impA in G1 &
    \for(y,(t1 '=' (t2,L)\imp(A/(x0,y0))))\iff
    \not\ex(y,\not(t1 '=' (t2,L)\imp(A/(x0,y0)))) in G by B4,Th45,Th106;
    then \for(y,(t1 '=' (t2,L)\imp(A/(x0,y0))))\impA in G1 by Th92;
    then A\iff\for(y, t1 '=' (t2,L)\imp(A/(x0,y0))) in G1 by A9,Th43;
    hence thesis by A1,Def39;
  end;

theorem
  L is subst-correct subst-eq-correct subst-correct3 vf-eq-correct &
  x in X.s & y in X.s & x <> y implies \for(x,\ex(y,x '=' (y,L))) in G1
  proof
    assume that
A0: L is subst-correct subst-eq-correct subst-correct3 vf-eq-correct and
A1: x in X.s & y in X.s & x <> y;
A2: s in dom X = the carrier of J by A1,FUNCT_1:def 2,PARTFUN1:def 2;
    then X.s c= (the Sorts of T).s = (the Sorts of L).s
    by Th16,PBOOLE:def 2,def 18;
    then reconsider t1 = x, t2 = y as Element of L,s by A1;
    reconsider j = s as SortSymbol of J by A2;
    reconsider q1 = t1, q2 = t2 as Element of T,j by Th16;
    set Y = X extended_by({}, the carrier of S1);
    reconsider y0 = y, x0 = x as Element of Union Y by Th24;
    dom Y = the carrier of S1 by PARTFUN1:def 2;
    then
A4: X.s = Y.s & (the Sorts of L).the formula-sort of S1 <> {} &
    Y is ManySortedSubset of the Sorts of L by A2,Th1,Th23;
    vf t1 = s-singleton x0 by A0,A1;
    then (vf t1).s = {x0} by AOFA_A00:6;
    then
B2: y0 nin (vf t1).s by A1,TARSKI:def 1;
A3: t1 '=' (t2,L)/(y0,x0)\imp\ex(y,t1 '=' (t2,L)) in G1 by A0,A1,A2,Th110;
A5: t1 '=' (t2,L)/(y0,x0)
    = ((t1 '=' (t2,L))/(y0,t1)) by A1,A4,Th14
    .= t1/(y0,t1) '=' (t2/(y0,t1),L) by A0,A1
    .= t1 '=' (t2/(y0,t1),L) by B2,A0,A1,A4
    .= t1 '=' (t1,L) by A0,A1,A4;
    q1 '=' (q1,L) in G1 by Def42;
    then \ex(y,x '=' (y,L)) in G1 by A3,A5,Def38;
    hence thesis by Def39;
  end;

theorem ThTwo:
  L is subst-correct & x = x0 in X.s & y = y0 in X.s implies
  A\and (x '=' (y,L))\imp(A/(x0,y0)) in G1
  proof
    assume that
A0: L is subst-correct and
A1: x = x0 in X.s & y = y0 in X.s;
A2: s in dom X = the carrier of J by A1,FUNCT_1:def 2,PARTFUN1:def 2;
    then X.s c= (the Sorts of T).s = (the Sorts of L).s
    by Th16,PBOOLE:def 2,def 18;
    then reconsider t1 = x, t2 = y as Element of L,s by A1;
    reconsider j = s as SortSymbol of J by A2;
    reconsider q1 = t1, q2 = t2 as Element of T,j by Th16;
    set Y = X extended_by({}, the carrier of S1);
    dom Y = the carrier of S1 by PARTFUN1:def 2;
    then
A4: X.s = Y.s & (the Sorts of L).the formula-sort of S1 <> {} &
    Y is ManySortedSubset of the Sorts of L by A2,Th1,Th23;
A3: t1 '=' (t2,L)\imp(A/(x0,t1)\imp(A/(x0,t2))) in G1 by A1,Def42;
A5: A/(x0,t1) = A/(x0,x0) by A1,A4,Th14 .= A by A0,A1,A4;
    A/(x0,t2) = A/(x0,y0) by A1,A4,Th14;
    then A\imp(t1 '=' (t2,L)\imp(A/(x0,y0))) in G1 &
    (A\imp(t1 '=' (t2,L)\imp(A/(x0,y0))))\imp
    (A\and(t1 '=' (t2,L))\imp(A/(x0,y0))) in G1 by A3,A5,Th38,Th48;
    hence thesis by Def38;
  end;

theorem
  L is subst-correct & x = x0 in X.s & y = y0 in X.s implies
  A\and\not(A/(x0,y0))\imp\not(x '=' (y,L)) in G1
  proof
    assume that
A0: L is subst-correct and
A1: x = x0 in X.s & y = y0 in X.s;
    s in dom X = the carrier of J by A1,FUNCT_1:def 2,PARTFUN1:def 2;
    then X.s c= (the Sorts of T).s = (the Sorts of L).s
    by Th16,PBOOLE:def 2,def 18;
    then reconsider t1 = x, t2 = y as Element of L,s by A1;
    A\and (x '=' (y,L))\imp(A/(x0,y0)) in G1 &
    (A\and(t1 '=' (t2,L))\imp(A/(x0,y0)))\imp
    (A\imp((t1 '=' (t2,L))\imp(A/(x0,y0)))) in G1 by A0,A1,ThTwo,Th47;
    then
    A\imp((t1 '=' (t2,L))\imp(A/(x0,y0))) in G1 &
   ((t1 '=' (t2,L))\imp(A/(x0,y0)))\imp(\not(A/(x0,y0))\imp\not(t1 '=' (t2,L)))
   in G1 by Def38,Th57;
   then
   A\imp(\not(A/(x0,y0))\imp\not(t1 '=' (t2,L))) in G1 &
   A\imp(\not(A/(x0,y0))\imp\not(t1 '=' (t2,L)))\imp
   (A\and\not(A/(x0,y0))\imp\not(t1 '=' (t2,L))) in G1 by Th45,Th48;
   hence thesis by Def38;
  end;

begin :: Algorithmic logic

reserve
  n for non empty natural number,
  J for non empty non void Signature,
  T for non-empty VarMSAlgebra over J,
  X for non-empty GeneratorSet of T,
  S for essential J-extension non empty non void n PC-correct QC-correct
  n AL-correct AlgLangSignature over Union X,
  L for non empty IfWhileAlgebra of X,S,
  M,M1,M2 for Algorithm of L,
  A,B,C,V for Formula of L,
  H for AL-theory of V,L,
  a for SortSymbol of J,
  x,y for (Element of X.a),
  t for Element of T,a;

theorem
  (M*(A\andB\andC))\iff(M*A)\and(M*B)\and(M*C) in H
  proof
A1: (M*(A\andB\andC))\iff(M*(A\andB))\and(M*C) in H by Def43;
    (M*(A\andB))\iff(M*A)\and(M*B) in H by Def43;
    hence thesis by A1,Th98;
  end;

theorem
  (M*(A\orB\orC))\iff(M*A)\or(M*B)\or(M*C) in H
  proof
A1: (M*(A\orB\orC))\iff(M*(A\orB))\or(M*C) in H by Def43;
    (M*(A\orB))\iff(M*A)\or(M*B) in H by Def43;
    hence thesis by A1,Th100;
  end;

theorem Th147:
  A\iffB in H implies \Cup(M,A)\iff\Cup(M,B) in H
  proof
    assume A\iffB in H;
    then A\impB in H & B\impA in H by Th43;
    then \Cup(M,A)\imp\Cup(M,B) in H & \Cup(M,B)\imp\Cup(M,A) in H by Def43;
    hence \Cup(M,A)\iff\Cup(M,B) in H by Th43;
  end;

theorem Th148:
  A\iffB in H implies \Cap(M,A)\iff\Cap(M,B) in H
  proof
    assume A\iffB in H;
    then A\impB in H & B\impA in H by Th43;
    then \Cap(M,A)\imp\Cap(M,B) in H & \Cap(M,B)\imp\Cap(M,A) in H by Def43;
    hence \Cap(M,A)\iff\Cap(M,B) in H by Th43;
  end;

theorem
  \Cup(M,A) \iff A\or(M*A)\or\Cup(M, (M\;M)*A) in H
  proof
A1: \Cup(M,A) \iff A\or\Cup(M, M*A) in H by Def43;
    \Cup(M,M*A) \iff (M*A)\or\Cup(M, M*(M*A)) in H by Def43;
    then
A2: \Cup(M,A) \iff A\or((M*A)\or\Cup(M, M*(M*A))) in H by A1,Th99;
    A\or(M*A)\or\Cup(M, M*(M*A))\iffA\or((M*A)\or\Cup(M, M*(M*A))) in H
    by Th76;
    then A\or((M*A)\or\Cup(M, M*(M*A)))\iffA\or(M*A)\or\Cup(M, M*(M*A)) in H
    by Th90;
    then
A3: \Cup(M,A) \iff A\or(M*A)\or\Cup(M, M*(M*A)) in H by A2,Th91;
    ((M\;M)*A)\iff(M*(M*A)) in H by Def43;
    then (M*(M*A)) \iff ((M\;M)*A) in H by Th90;
    then \Cup(M, M*(M*A))\iff\Cup(M, (M\;M)*A) in H by Th147;
    hence thesis by A3,Th99;
  end;

theorem
  \Cap(M,A) \iff A\and(M*A)\and\Cap(M, (M\;M)*A) in H
  proof
A1: \Cap(M,A) \iff A\and\Cap(M, M*A) in H by Def43;
    \Cap(M,M*A) \iff (M*A)\and\Cap(M, M*(M*A)) in H by Def43;
    then
A2: \Cap(M,A) \iff A\and((M*A)\and\Cap(M, M*(M*A))) in H by A1,Th97;
    A\and(M*A)\and\Cap(M, M*(M*A))\iffA\and((M*A)\and\Cap(M, M*(M*A))) in H
    by Th78;
    then A\and((M*A)\and\Cap(M, M*(M*A)))\iffA\and(M*A)\and\Cap(M, M*(M*A))
    in H by Th90;
    then
A3: \Cap(M,A) \iff A\and(M*A)\and\Cap(M, M*(M*A)) in H by A2,Th91;
    ((M\;M)*A)\iff(M*(M*A)) in H by Def43;
    then (M*(M*A)) \iff ((M\;M)*A) in H by Th90;
    then \Cap(M, M*(M*A))\iff\Cap(M, (M\;M)*A) in H by Th148;
    hence thesis by A3,Th97;
  end;

theorem
  for x0,y0 being Element of Union (X extended_by ({},the carrier of S))
  st x = x0 & y = y0 holds
  ((x:=(@y,L))*A) \iff (A/(x0,y0)) in H
  proof
    let x0,y0 be Element of Union (X extended_by ({},the carrier of S));
    reconsider b = a as SortSymbol of S by Th8;
    reconsider t = @y as Element of (the Sorts of L).b by Th16;
    assume A1: x = x0 & y = y0;
    then
A2: ((x:=(@y,L))*A) \iff (A/(x0,t)) in H by Def43;
A3: X extended_by ({}, the carrier of S) is ManySortedSubset of the Sorts of L
    by Th23;
    a in the carrier of J = dom X by PARTFUN1:def 2;
    then b in dom(X|the carrier of S) by RELAT_1:57;
    then (X extended_by ({}, the carrier of S)).b = (X|the carrier of S).b
    by FUNCT_4:13 .= X.b by FUNCT_1:49;
    hence thesis by A1,A2,A3,Th14;
  end;

theorem
  M*V in H & M*(M1*A) in H or M*\notV in H & M*(M2*A) in H implies
  if-then-else(M,M1,M2)*A in H
  proof
    assume M*V in H & M*(M1*A) in H or M*\notV in H & M*(M2*A) in H;
    then ((M*V)\and(M*(M1*A)) in H or (M*\notV)\and(M*(M2*A)) in H) &
    (M*V)\and(M*(M1*A))\imp((M*V)\and(M*(M1*A)))\or((M*\notV)\and(M*(M2*A)))
    in H &
    (M*\notV)\and(M*(M2*A))\imp((M*V)\and(M*(M1*A)))\or
    ((M*\notV)\and(M*(M2*A))) in H by Def38,Th35;
    then
A1: ((M*V)\and(M*(M1*A)))\or((M*\notV)\and(M*(M2*A))) in H by Def38;
    (if-then-else(M,M1,M2)*A) \iff
    ((M*V)\and(M*(M1*A)))\or((M*\notV)\and(M*(M2*A))) in H by Def43;
    then
    ((M*V)\and(M*(M1*A)))\or((M*\notV)\and(M*(M2*A)))\imp
    (if-then-else(M,M1,M2)*A) in H by Th43;
    hence thesis by Def38,A1;
  end;

theorem
  M*\notV in H & A in H or M*V in H & M*(M1*(while(M,M1)*A)) in H implies
  while(M,M1)*A in H
  proof
    assume M*\notV in H & A in H or M*V in H & M*(M1*(while(M,M1)*A)) in H;
    then
A1: (M*\notV)\andA in H or (M*V)\and(M*(M1*(while(M,M1)*A))) in H
    by Th35;
    ((M*\notV)\andA)\imp((M*\notV)\andA)\or
    ((M*V)\and(M*(M1*(while(M,M1)*A)))) in H &
    ((M*V)\and(M*(M1*(while(M,M1)*A))))\imp((M*\notV)\andA)\or
    ((M*V)\and(M*(M1*(while(M,M1)*A)))) in H by Def38;
    then
A2: ((M*\notV)\andA)\or((M*V)\and(M*(M1*(while(M,M1)*A)))) in H
    by A1,Def38;
    (while(M,M1)*A) \iff
    ((M*\notV)\andA)\or((M*V)\and(M*(M1*(while(M,M1)*A)))) in H by Def43;
    then
    ((M*\notV)\andA)\or((M*V)\and(M*(M1*(while(M,M1)*A))))\imp
    (while(M,M1)*A) in H by Th43;
    hence thesis by Def38,A2;
  end;


:: About Graph Sums
::  by Sebastian Koch
:: 
:: Received November 30, 2021
:: Copyright (c) 2021 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, FINSET_1, RELAT_1, FUNCT_1, XBOOLE_0, TARSKI, SUBSET_1,
      FINSEQ_1, NAT_1, FUNCT_4, FUNCOP_1, ZFMISC_1, CARD_1, ARYTM_3, CARD_2,
      ORDINAL2, XXREAL_0, PBOOLE, XCMPLX_0, RELAT_2, PARTFUN1, WELLORD1,
      RING_3, FUNCT_2, MCART_1, TREES_1, WAYBEL_0, MOD_4, FUNCT_7, GLIB_015,
      MSUALG_6, EQREL_1, ABIAN, TAXONOM2, GLIB_000, GLIB_001, GLIB_002, CHORD,
      SCMYCIEL, SIMPLEX0, GLIB_009, GLIB_006, GLIB_007, GLIB_010, GLIB_012,
      GLIB_013, GLIB_014;
 notations TARSKI, XBOOLE_0, ENUMSET1, XTUPLE_0, ZFMISC_1, SUBSET_1, RELAT_1,
      FUNCT_1, ORDINAL1, RELSET_1, PARTFUN1, MCART_1, FUNCT_2, DOMAIN_1,
      FUNCT_3, FUNCOP_1, FUNCT_4, ORDINAL2, FINSET_1, CARD_1, PBOOLE, CARD_3,
      NUMBERS, XCMPLX_0, XXREAL_0, NAT_1, CARD_2, FINSEQ_1, EQREL_1, FINSEQ_4,
      FUNCT_7, ABIAN, GLIB_000, TAXONOM2, COMPUT_1, GLIB_001, GLIB_002, CHORD,
      AOFA_I00, GLIB_006, GLIB_007, GLIB_008, GLIB_009, GLIB_010, GLIBPRE0,
      GLIB_012, GLIB_013, GLIB_014, GLIBPRE1;
 constructors DOMAIN_1, FUNCT_4, XXREAL_0, NAT_1, NAT_D, BINOP_2, CARD_2,
      FINSEQ_4, PBOOLE, ORDINAL3, WELLORD2, PARTFUN1, RELSET_1, FUNCT_3,
      FUNCT_7, GLIB_000, GLIB_001, GLIB_002, CHORD, GLIB_007, GLIB_008,
      GLIB_009, GLIB_010, GLIB_012, GLIB_013, GLIB_014, GLIBPRE0, GLIB_006,
      MCART_1, COMPUT_1, EQREL_1, ABIAN, CARD_3, TAXONOM2, AOFA_I00, PARTFUN2,
      ORDINAL1, FINSET_1, QC_LANG1, CQC_LANG, GLIBPRE1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, XREAL_0, NAT_1, CARD_1, FINSEQ_1, FINSEQ_4, FUNCT_2, PARTFUN1,
      RELSET_1, FUNCT_3, FUNCT_7, XTUPLE_0, COMPUT_1, INT_1, PRE_POLY,
      GLIB_000, GLIB_002, CHORD, GLIB_008, GLIB_009, GLIB_006, GLIBPRE0,
      GLIB_010, GLIB_012, GLIB_013, GLIB_014, ABIAN, CARD_3, EQREL_1, GLIBPRE1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions GLIB_010;
 equalities GLIB_000;
 theorems FUNCOP_1, ORDINAL1, FUNCT_1, TARSKI, RELSET_1, GLIB_010, GLIB_001,
      GLIB_000, PARTFUN1, RELAT_1, XBOOLE_1, FUNCT_2, GLIB_012, GLIB_013,
      GLIB_014, CARD_1, GLIBPRE0, ZFMISC_1, ENUMSET1, XBOOLE_0, FUNCT_3,
      XTUPLE_0, XREGULAR, GLIB_002, GLIB_008, FINSEQ_1, FUNCT_7, GLIB_009,
      COMPUT_1, GLIB_007, FUNCT_4, GLIB_006, MCART_1, DICKSON, TOPGEN_2,
      EQREL_1, CHORD, CARD_2, TAXONOM2, FINSEQ_2, CALCUL_1, GLIBPRE1;
 schemes FUNCT_1, PBOOLE, GLIB_009;

begin :: Replacing Vertices and Edges

Lm1:
  for X, Y being set, f being Function of X, Y
  for V being ManySortedSet of Y, E being one-to-one ManySortedSet of X
  holds V*f*(E") is Function of rng E, rng V
proof
  let X, Y be set, f be Function of X, Y;
  let V being ManySortedSet of Y, E be one-to-one ManySortedSet of X;
  per cases;
  suppose A1: Y <> {};
    rng f c= Y;
    then A2: rng f c= dom V by PARTFUN1:def 2;
    rng(E") = dom E by FUNCT_1:33
      .= X by PARTFUN1:def 2
      .= dom f by A1, PARTFUN1:def 2
      .= dom(V*f) by A2, RELAT_1:27;
    then A3: dom(V*f*(E")) = dom(E") by RELAT_1:27
      .= rng E by FUNCT_1:33;
    A4: rng(V*f*(E")) c= rng(V*f) by RELAT_1:26;
    rng(V*f) c= rng V by RELAT_1:26;
    hence thesis by A3, A4, XBOOLE_1:1, FUNCT_2:2;
  end;
  suppose Y = {};
    then A5: V*f = {} & rng V = {};
    then A6: V*f*(E") = {};
    then dom(V*f*(E")) = {} & rng(V*f*(E")) = {};
    then dom(V*f*(E")) c= rng E & rng(V*f*(E")) c= rng V by XBOOLE_1:2;
    then reconsider g = V*f*(E") as PartFunc of rng E, rng V by RELSET_1:4;
    g is quasi_total by A5, A6, FUNCT_2:def 1;
    hence thesis;
  end;
end;

definition
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  func replaceVerticesEdges(V,E) -> plain _Graph means
  :Def1:
  ex S,T being Function of rng E, rng V
  st S = V*(the_Source_of G)*(E") & T = V*(the_Target_of G)*(E") &
    it = createGraph(rng V,rng E,S,T);
  existence
  proof
    reconsider S = V*(the_Source_of G)*(E") as Function of rng E, rng V by Lm1;
    reconsider T = V*(the_Target_of G)*(E") as Function of rng E, rng V by Lm1;
    take createGraph(rng V,rng E,S,T), S,T;
    thus thesis;
  end;
  uniqueness;
end;

definition
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  func replaceVertices(V) -> plain _Graph equals
  replaceVerticesEdges(V,id the_Edges_of G);
  coherence;
end;

definition
  let G be _Graph, E be one-to-one ManySortedSet of the_Edges_of G;
  func replaceEdges(E) -> plain _Graph equals
  replaceVerticesEdges(id the_Vertices_of G, E);
  coherence;
end;

theorem Th1:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for E being one-to-one ManySortedSet of the_Edges_of G
  holds the_Vertices_of replaceVerticesEdges(V,E) = rng V &
    the_Edges_of replaceVerticesEdges(V,E) = rng E &
    the_Source_of replaceVerticesEdges(V,E) = V*(the_Source_of G)*(E") &
    the_Target_of replaceVerticesEdges(V,E) = V*(the_Target_of G)*(E")
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  consider S,T being Function of rng E, rng V such that
    A1: S = V*(the_Source_of G)*(E") & T = V*(the_Target_of G)*(E") and
    A2: replaceVerticesEdges(V,E) = createGraph(rng V,rng E,S,T) by Def1;
  thus thesis by A1, A2;
end;

theorem Th2:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  holds the_Vertices_of replaceVertices(V) = rng V &
    the_Edges_of replaceVertices(V) = the_Edges_of G &
    the_Source_of replaceVertices(V) = V*(the_Source_of G) &
    the_Target_of replaceVertices(V) = V*(the_Target_of G)
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  thus the_Vertices_of replaceVertices(V) = rng V by Th1;
  rng id the_Edges_of G = the_Edges_of G;
  hence the_Edges_of replaceVertices(V) = the_Edges_of G by Th1;
  A1: (id the_Edges_of G)" = id the_Edges_of G by FUNCT_1:45;
  dom(V*(the_Source_of G)) c= the_Edges_of G;
  then V*(the_Source_of G) = V*(the_Source_of G)*((id the_Edges_of G)")
    by A1, RELAT_1:51;
  hence the_Source_of replaceVertices(V) = V*(the_Source_of G) by Th1;
  dom(V*(the_Target_of G)) c= the_Edges_of G;
  then V*(the_Target_of G) = V*(the_Target_of G)*((id the_Edges_of G)")
    by A1, RELAT_1:51;
  hence the_Target_of replaceVertices(V) = V*(the_Target_of G) by Th1;
end;

theorem Th3:
  for G being _Graph
  for E being one-to-one ManySortedSet of the_Edges_of G
  holds the_Vertices_of replaceEdges(E) = the_Vertices_of G &
    the_Edges_of replaceEdges(E) = rng E &
    the_Source_of replaceEdges(E) = (the_Source_of G)*(E") &
    the_Target_of replaceEdges(E) = (the_Target_of G)*(E")
proof
  let G be _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  rng id the_Vertices_of G = the_Vertices_of G;
  hence the_Vertices_of replaceEdges(E) = the_Vertices_of G by Th1;
  thus the_Edges_of replaceEdges(E) = rng E by Th1;
  rng((the_Source_of G)*(E")) c= the_Vertices_of G;
  then (the_Source_of G)*(E")
     = (id the_Vertices_of G)*((the_Source_of G)*(E")) by RELAT_1:53
    .= (id the_Vertices_of G)*(the_Source_of G)*(E") by RELAT_1:36;
  hence the_Source_of replaceEdges(E) = (the_Source_of G)*(E") by Th1;
  rng((the_Target_of G)*(E")) c= the_Vertices_of G;
  then (the_Target_of G)*(E")
     = (id the_Vertices_of G)*((the_Target_of G)*(E")) by RELAT_1:53
    .= (id the_Vertices_of G)*(the_Target_of G)*(E") by RELAT_1:36;
  hence the_Target_of replaceEdges(E) = (the_Target_of G)*(E") by Th1;
end;

theorem Th4:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for E being one-to-one ManySortedSet of the_Edges_of G
  for e,v,w being object st e DJoins v,w,G
  holds E.e DJoins V.v,V.w,replaceVerticesEdges(V,E)
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  A1: dom V = the_Vertices_of G & dom E = the_Edges_of G by PARTFUN1:def 2;
  let e,v,w be object;
  assume A2: e DJoins v,w,G;
  then A3: e in the_Edges_of G by GLIB_000:def 14;
  then A4: e in dom the_Source_of G & e in dom the_Target_of G
    by FUNCT_2:def 1;
  E.e in rng E by A1, A3, FUNCT_1:3;
  then A5: E.e in dom(E") & E.e in the_Edges_of replaceVerticesEdges(V,E)
    by Th1, FUNCT_1:33;
  A6: V.v = V.((the_Source_of G).e) by A2, GLIB_000:def 14
    .= (V*(the_Source_of G)).e by A4, FUNCT_1:13
    .= (V*(the_Source_of G)).(E".(E.e)) by A1, A3, FUNCT_1:34
    .= (V*(the_Source_of G)*(E")).(E.e) by A5, FUNCT_1:13
    .= (the_Source_of replaceVerticesEdges(V,E)).(E.e) by Th1;
  V.w = V.((the_Target_of G).e) by A2, GLIB_000:def 14
    .= (V*(the_Target_of G)).e by A4, FUNCT_1:13
    .= (V*(the_Target_of G)).(E".(E.e)) by A1, A3, FUNCT_1:34
    .= (V*(the_Target_of G)*(E")).(E.e) by A5, FUNCT_1:13
    .= (the_Target_of replaceVerticesEdges(V,E)).(E.e) by Th1;
  hence E.e DJoins V.v,V.w,replaceVerticesEdges(V,E)
    by A5, A6, GLIB_000:def 14;
end;

theorem Th5:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for e,v,w being object st e DJoins v,w,G
  holds e DJoins V.v,V.w,replaceVertices(V)
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let e,v,w be object;
  assume A1: e DJoins v,w,G;
  (id the_Edges_of G).e DJoins V.v,V.w,replaceVertices(V) by A1, Th4;
  hence thesis by A1, FUNCT_1:18, GLIB_000:def 14;
end;

theorem Th6:
  for G being _Graph, E being one-to-one ManySortedSet of the_Edges_of G
  for e,v,w being object st e DJoins v,w,G
  holds E.e DJoins v,w,replaceEdges(E)
proof
  let G be _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  let e,v,w be object;
  assume A1: e DJoins v,w,G;
  then e Joins v,w,G by GLIB_000:16;
  then A2: v in the_Vertices_of G & w in the_Vertices_of G by GLIB_000:13;
  E.e DJoins (id the_Vertices_of G).v,(id the_Vertices_of G).w,
    replaceEdges(E) by A1, Th4;
  then E.e DJoins v,(id the_Vertices_of G).w,replaceEdges(E) by A2, FUNCT_1:18;
  hence thesis by A2, FUNCT_1:18;
end;

theorem
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for E being one-to-one ManySortedSet of the_Edges_of G
  for e,v,w being object st e Joins v,w,G
  holds E.e Joins V.v,V.w,replaceVerticesEdges(V,E)
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  let e,v,w be object;
  assume e Joins v,w,G;
  then per cases by GLIB_000:16;
  suppose e DJoins v,w,G;
    then E.e DJoins V.v,V.w,replaceVerticesEdges(V,E) by Th4;
    hence thesis by GLIB_000:16;
  end;
  suppose e DJoins w,v,G;
    then E.e DJoins V.w,V.v,replaceVerticesEdges(V,E) by Th4;
    hence thesis by GLIB_000:16;
  end;
end;

theorem
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for e,v,w being object st e Joins v,w,G
  holds e Joins V.v,V.w,replaceVertices(V)
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let e,v,w be object;
  assume e Joins v,w,G;
  then per cases by GLIB_000:16;
  suppose e DJoins v,w,G;
    then e DJoins V.v,V.w,replaceVertices(V) by Th5;
    hence thesis by GLIB_000:16;
  end;
  suppose e DJoins w,v,G;
    then e DJoins V.w,V.v,replaceVertices(V) by Th5;
    hence thesis by GLIB_000:16;
  end;
end;

theorem
  for G being _Graph, E being one-to-one ManySortedSet of the_Edges_of G
  for e,v,w being object st e Joins v,w,G
  holds E.e Joins v,w,replaceEdges(E)
proof
  let G be _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  let e,v,w be object;
  assume e Joins v,w,G;
  then per cases by GLIB_000:16;
  suppose e DJoins v,w,G;
    then E.e DJoins v,w,replaceEdges(E) by Th6;
    hence thesis by GLIB_000:16;
  end;
  suppose e DJoins w,v,G;
    then E.e DJoins w,v,replaceEdges(E) by Th6;
    hence thesis by GLIB_000:16;
  end;
end;

theorem Th10:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for E being one-to-one ManySortedSet of the_Edges_of G
  for e,v,w being object st e in dom E & v in dom V & w in dom V &
    E.e DJoins V.v,V.w,replaceVerticesEdges(V,E)
  holds e DJoins v,w,G
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  let e,v,w be object;
  assume A1: e in dom E & v in dom V & w in dom V;
  then A2: e in the_Edges_of G;
  assume A3: E.e DJoins V.v,V.w,replaceVerticesEdges(V,E);
  E.e in rng E by A1, FUNCT_1:3;
  then A4: E.e in dom(E") by FUNCT_1:33;
  A5: e in dom the_Source_of G & e in dom the_Target_of G by A2, FUNCT_2:def 1;
  (the_Source_of G).e in the_Vertices_of G &
    (the_Target_of G).e in the_Vertices_of G by A1, FUNCT_2:5;
  then A6: (the_Source_of G).e in dom V &
    (the_Target_of G).e in dom V by PARTFUN1:def 2;
  V.v = (the_Source_of replaceVerticesEdges(V,E)).(E.e) by A3, GLIB_000:def 14
    .= (V*(the_Source_of G)*(E")).(E.e) by Th1
    .= (V*(the_Source_of G)).(E".(E.e)) by A4, FUNCT_1:13
    .= (V*(the_Source_of G)).e by A1, FUNCT_1:34
    .= V.((the_Source_of G).e) by A5, FUNCT_1:13;
  then A7: v = (the_Source_of G).e by A1, A6, FUNCT_1:def 4;
  V.w = (the_Target_of replaceVerticesEdges(V,E)).(E.e) by A3, GLIB_000:def 14
    .= (V*(the_Target_of G)*(E")).(E.e) by Th1
    .= (V*(the_Target_of G)).(E".(E.e)) by A4, FUNCT_1:13
    .= (V*(the_Target_of G)).e by A1, FUNCT_1:34
    .= V.((the_Target_of G).e) by A5, FUNCT_1:13;
  then w = (the_Target_of G).e by A1, A6, FUNCT_1:def 4;
  hence e DJoins v,w,G by A1, A7, GLIB_000:def 14;
end;

theorem Th11:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for e,v,w being object
  st v in dom V & w in dom V & e DJoins V.v,V.w,replaceVertices(V)
  holds e DJoins v,w,G
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let e,v,w be object;
  assume A1: v in dom V & w in dom V & e DJoins V.v,V.w,replaceVertices(V);
  then e in the_Edges_of replaceVertices(V) by GLIB_000:def 14;
  then A2: e in the_Edges_of G by Th2;
  then A3: e in dom id the_Edges_of G;
  (id the_Edges_of G).e = e by A2, FUNCT_1:18;
  hence e DJoins v,w,G by A1, A3, Th10;
end;

theorem Th12:
  for G being _Graph, E being one-to-one ManySortedSet of the_Edges_of G
  for e,v,w being object st e in dom E & E.e DJoins v,w,replaceEdges(E)
  holds e DJoins v,w,G
proof
  let G be _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  let e,v,w be object;
  assume A1: e in dom E & E.e DJoins v,w,replaceEdges(E);
  then E.e Joins v,w,replaceEdges(E) by GLIB_000:16;
  then v in the_Vertices_of replaceEdges(E) &
    w in the_Vertices_of replaceEdges(E) by GLIB_000:13;
  then A2: v in the_Vertices_of G & w in the_Vertices_of G by Th3;
  then A3: v in dom id the_Vertices_of G & w in dom id the_Vertices_of G;
  (id the_Vertices_of G).v = v & (id the_Vertices_of G).w = w
    by A2, FUNCT_1:18;
  hence e DJoins v,w,G by A1, A3, Th10;
end;

theorem
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for E being one-to-one ManySortedSet of the_Edges_of G
  for e,v,w being object st e in dom E & v in dom V & w in dom V &
    E.e Joins V.v,V.w,replaceVerticesEdges(V,E)
  holds e Joins v,w,G
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  let e,v,w be object;
  assume A1: e in dom E & v in dom V & w in dom V;
  assume E.e Joins V.v,V.w,replaceVerticesEdges(V,E);
  then per cases by GLIB_000:16;
  suppose E.e DJoins V.v,V.w,replaceVerticesEdges(V,E);
    then e DJoins v,w,G by A1, Th10;
    hence thesis by GLIB_000:16;
  end;
  suppose E.e DJoins V.w,V.v,replaceVerticesEdges(V,E);
    then e DJoins w,v,G by A1, Th10;
    hence thesis by GLIB_000:16;
  end;
end;

theorem
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for e,v,w being object st v in dom V & w in dom V &
    e Joins V.v,V.w,replaceVertices(V)
  holds e Joins v,w,G
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let e,v,w be object;
  assume A1: v in dom V & w in dom V;
  assume e Joins V.v,V.w,replaceVertices(V);
  then per cases by GLIB_000:16;
  suppose e DJoins V.v,V.w,replaceVertices(V);
    then e DJoins v,w,G by A1, Th11;
    hence thesis by GLIB_000:16;
  end;
  suppose e DJoins V.w,V.v,replaceVertices(V);
    then e DJoins w,v,G by A1, Th11;
    hence thesis by GLIB_000:16;
  end;
end;

theorem
  for G being _Graph, E being one-to-one ManySortedSet of the_Edges_of G
  for e,v,w being object st e in dom E & E.e Joins v,w,replaceEdges(E)
  holds e Joins v,w,G
proof
  let G be _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  let e,v,w be object;
  assume A1: e in dom E;
  assume E.e Joins v,w,replaceEdges(E);
  then per cases by GLIB_000:16;
  suppose E.e DJoins v,w,replaceEdges(E);
    then e DJoins v,w,G by A1, Th12;
    hence thesis by GLIB_000:16;
  end;
  suppose E.e DJoins w,v,replaceEdges(E);
    then e DJoins w,v,G by A1, Th12;
    hence thesis by GLIB_000:16;
  end;
end;

theorem Th16:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for E being one-to-one ManySortedSet of the_Edges_of G
  ex F being PGraphMapping of G, replaceVerticesEdges(V,E)
  st F_V = V & F_E = E & F is Disomorphism
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  the_Vertices_of replaceVerticesEdges(V,E) = rng V &
    the_Vertices_of G = dom V by Th1, PARTFUN1:def 2;
  then reconsider f = V as Function of the_Vertices_of G,
    the_Vertices_of replaceVerticesEdges(V,E) by FUNCT_2:1;
  the_Edges_of replaceVerticesEdges(V,E) = rng E &
    the_Edges_of G = dom E by Th1, PARTFUN1:def 2;
  then reconsider g = E as Function of the_Edges_of G,
    the_Edges_of replaceVerticesEdges(V,E) by FUNCT_2:1;
  :: properties of PGM
  now
    hereby
      let e be object;
      set v = (the_Source_of G).e, w = (the_Target_of G).e;
      assume e in dom g;
      then A1: e Joins v,w,G by GLIB_000:def 13;
      dom f = the_Vertices_of G by PARTFUN1:def 2;
      hence v in dom f & w in dom f by A1, GLIB_000:13;
    end;
    let e,v,w be object;
    assume e in dom g & v in dom f & w in dom f;
    assume e DJoins v,w,G;
    hence g.e DJoins f.v,f.w,replaceVerticesEdges(V,E) by Th4;
  end;
  then reconsider F = [f,g] as
    directed PGraphMapping of G, replaceVerticesEdges(V,E) by GLIB_010:30;
  take F;
  the_Vertices_of G = dom F_V & the_Edges_of G = dom F_E by PARTFUN1:def 2;
  then A2: F is total by GLIB_010:def 11;
  the_Vertices_of replaceVerticesEdges(V,E) = rng F_V &
    the_Edges_of replaceVerticesEdges(V,E) = rng F_E by Th1;
  then A3: F is onto by GLIB_010:def 12;
  F_V is one-to-one & F_E is one-to-one;
  then F is one-to-one by GLIB_010:def 13;
  hence thesis by A2, A3;
end;

theorem Th17:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for E being one-to-one ManySortedSet of the_Edges_of G
  holds replaceVerticesEdges(V,E) is G-Disomorphic
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
    A1: F_V = V & F_E = E & F is Disomorphism by Th16;
  thus thesis by A1, GLIB_010:def 24;
end;

:: clusterings (from Disomorphic)

registration
  let G be loopless _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> loopless;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:89;
  end;
end;

registration
  let G be loopless _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> loopless;
  coherence;
end;

registration
  let G be loopless _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> loopless;
  coherence;
end;

registration
  let G be non loopless _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non loopless;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:89;
  end;
end;

registration
  let G be non loopless _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non loopless;
  coherence;
end;

registration
  let G be non loopless _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non loopless;
  coherence;
end;

registration
  let G be non-multi _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non-multi;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:89;
  end;
end;

registration
  let G be non-multi _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non-multi;
  coherence;
end;

registration
  let G be non-multi _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non-multi;
  coherence;
end;

registration
  let G be non non-multi _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non non-multi;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:89;
  end;
end;

registration
  let G be non non-multi _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non non-multi;
  coherence;
end;

registration
  let G be non non-multi _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non non-multi;
  coherence;
end;

registration
  let G be non-Dmulti _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non-Dmulti;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:90; :: # TODO correct GLIB_010:90
  end;
end;

registration
  let G be non-Dmulti _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non-Dmulti;
  coherence;
end;

registration
  let G be non-Dmulti _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non-Dmulti;
  coherence;
end;

registration
  let G be non non-Dmulti _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non non-Dmulti;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:90;
  end;
end;

registration
  let G be non non-Dmulti _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non non-Dmulti;
  coherence;
end;

registration
  let G be non non-Dmulti _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non non-Dmulti;
  coherence;
end;

registration
  let G be simple _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> simple;
  coherence;
end;

registration
  let G be simple _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> simple;
  coherence;
end;

registration
  let G be simple _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> simple;
  coherence;
end;

registration
  let G be Dsimple _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> Dsimple;
  coherence;
end;

registration
  let G be Dsimple _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> Dsimple;
  coherence;
end;

registration
  let G be Dsimple _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> Dsimple;
  coherence;
end;

registration
  let G be _trivial _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> _trivial;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:89;
  end;
end;

registration
  let G be _trivial _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> _trivial;
  coherence;
end;

registration
  let G be _trivial _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> _trivial;
  coherence;
end;

registration
  let G be non _trivial _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non _trivial;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:89;
  end;
end;

registration
  let G be non _trivial _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non _trivial;
  coherence;
end;

registration
  let G be non _trivial _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non _trivial;
  coherence;
end;

registration
  let G be vertex-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> vertex-finite;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_013:15;
  end;
end;

registration
  let G be vertex-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> vertex-finite;
  coherence;
end;

registration
  let G be vertex-finite _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> vertex-finite;
  coherence;
end;

registration
  let G be non vertex-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non vertex-finite;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_013:15;
  end;
end;

registration
  let G be non vertex-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non vertex-finite;
  coherence;
end;

registration
  let G be non vertex-finite _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non vertex-finite;
  coherence;
end;

registration
  let G be edge-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> edge-finite;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_013:15;
  end;
end;

registration
  let G be edge-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> edge-finite;
  coherence;
end;

registration
  let G be edge-finite _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> edge-finite;
  coherence;
end;

registration
  let G be non edge-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non edge-finite;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_013:15;
  end;
end;

registration
  let G be non edge-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non edge-finite;
  coherence;
end;

registration
  let G be non edge-finite _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non edge-finite;
  coherence;
end;

registration
  let G be finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> finite;
  coherence;
end;

registration
  let G be finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> finite;
  coherence;
end;

registration
  let G be finite _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> finite;
  coherence;
end;

registration
  let G be acyclic _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> acyclic;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:140;
  end;
end;

registration
  let G be acyclic _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> acyclic;
  coherence;
end;

registration
  let G be acyclic _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> acyclic;
  coherence;
end;

registration
  let G be non acyclic _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non acyclic;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:140;
  end;
end;

registration
  let G be non acyclic _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non acyclic;
  coherence;
end;

registration
  let G be non acyclic _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non acyclic;
  coherence;
end;

registration
  let G be connected _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> connected;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:140;
  end;
end;

registration
  let G be connected _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> connected;
  coherence;
end;

registration
  let G be connected _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> connected;
  coherence;
end;

registration
  let G be non connected _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non connected;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:140;
  end;
end;

registration
  let G be non connected _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non connected;
  coherence;
end;

registration
  let G be non connected _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non connected;
  coherence;
end;

registration
  let G be Tree-like _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> Tree-like;
  coherence;
end;

registration
  let G be Tree-like _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> Tree-like;
  coherence;
end;

registration
  let G be Tree-like _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> Tree-like;
  coherence;
end;

registration
  let G be chordal _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> chordal;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:140;
  end;
end;

registration
  let G be chordal _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> chordal;
  coherence;
end;

registration
  let G be chordal _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> chordal;
  coherence;
end;

:: clustering for non chordal graphs will be done after existence clustering
:: registration
  :: let G be non chordal _Graph;
  :: let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  :: let E be one-to-one ManySortedSet of the_Edges_of G;
  :: cluster replaceVerticesEdges(V,E) -> non chordal;
  :: coherence;
:: end;
::
:: registration
  :: let G be non chordal _Graph;
  :: let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  :: cluster replaceVertices(V) -> non chordal;
  :: coherence;
:: end;
::
:: registration
  :: let G be non chordal _Graph;
  :: let E be one-to-one ManySortedSet of the_Edges_of G;
  :: cluster replaceEdges(E) -> non chordal;
  :: coherence;
:: end;

registration
  let G be edgeless _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> edgeless;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_010:89;
  end;
end;

registration
  let G be edgeless _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> edgeless;
  coherence;
end;

registration
  let G be edgeless _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> edgeless;
  coherence;
end;

registration
  let G be non edgeless _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non edgeless;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1;
  end;
end;

registration
  let G be non edgeless _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non edgeless;
  coherence;
end;

registration
  let G be non edgeless _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non edgeless;
  coherence;
end;

registration
  let G be loopfull _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> loopfull;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_012:10;
  end;
end;

registration
  let G be loopfull _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> loopfull;
  coherence;
end;

registration
  let G be loopfull _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> loopfull;
  coherence;
end;

registration
  let G be non loopfull _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non loopfull;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_012:10;
  end;
end;

registration
  let G be non loopfull _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non loopfull;
  coherence;
end;

registration
  let G be non loopfull _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non loopfull;
  coherence;
end;

registration
  let G be locally-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> locally-finite;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_013:34;
  end;
end;

registration
  let G be locally-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> locally-finite;
  coherence;
end;

registration
  let G be locally-finite _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> locally-finite;
  coherence;
end;

registration
  let G be non locally-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> non locally-finite;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_013:34;
  end;
end;

registration
  let G be non locally-finite _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> non locally-finite;
  coherence;
end;

registration
  let G be non locally-finite _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> non locally-finite;
  coherence;
end;

registration
  let c be non zero Cardinal, G be c-vertex _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> c-vertex;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_013:22;
  end;
end;

registration
  let c be non zero Cardinal, G be c-vertex _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> c-vertex;
  coherence;
end;

registration
  let c be non zero Cardinal, G be c-vertex _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> c-vertex;
  coherence;
end;

registration
  let c be Cardinal, G be c-edge _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceVerticesEdges(V,E) -> c-edge;
  coherence
  proof
    consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
      A1: F_V = V & F_E = E & F is Disomorphism by Th16;
    thus thesis by A1, GLIB_013:22;
  end;
end;

registration
  let c be Cardinal, G be c-edge _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  cluster replaceVertices(V) -> c-edge;
  coherence;
end;

registration
  let c be Cardinal, G be c-edge _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  cluster replaceEdges(E) -> c-edge;
  coherence;
end;

theorem Th18:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for E being one-to-one ManySortedSet of the_Edges_of G
  for W1 being Walk of G ex W2 being Walk of replaceVerticesEdges(V,E)
  st V*(W1.vertexSeq()) = W2.vertexSeq() & E*(W1.edgeSeq()) = W2.edgeSeq()
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
    A1: F_V = V & F_E = E & F is Disomorphism by Th16;
  reconsider F as non empty PGraphMapping of G,replaceVerticesEdges(V,E) by A1;
  let W1 be Walk of G;
  reconsider W1 as F-defined Walk of G by A1, GLIB_010:121;
  take F.:W1;
  thus thesis by A1, GLIB_010:def 37;
end;

theorem
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for W1 being Walk of G ex W2 being Walk of replaceVertices(V)
  st V*(W1.vertexSeq()) = W2.vertexSeq() & W1.edgeSeq() = W2.edgeSeq()
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let W1 be Walk of G;
  consider W2 being Walk of replaceVertices(V) such that
    A1: V*(W1.vertexSeq()) = W2.vertexSeq() and
    A2: (id the_Edges_of G)*(W1.edgeSeq()) = W2.edgeSeq() by Th18;
  take W2;
  rng(W1.edgeSeq()) c= the_Edges_of G;
  hence thesis by A1, A2, RELAT_1:53;
end;

theorem
  for G being _Graph, E being one-to-one ManySortedSet of the_Edges_of G
  for W1 being Walk of G ex W2 being Walk of replaceEdges(E)
  st W1.vertexSeq() = W2.vertexSeq() & E*(W1.edgeSeq()) = W2.edgeSeq()
proof
  let G be _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  let W1 be Walk of G;
  consider W2 being Walk of replaceEdges(E) such that
    A1: (id the_Vertices_of G)*(W1.vertexSeq()) = W2.vertexSeq() and
    A2: E*(W1.edgeSeq()) = W2.edgeSeq() by Th18;
  take W2;
  rng(W1.vertexSeq()) c= the_Vertices_of G;
  hence thesis by A1, A2, RELAT_1:53;
end;

theorem Th21:
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for E being one-to-one ManySortedSet of the_Edges_of G
  for W2 being Walk of replaceVerticesEdges(V,E) ex W1 being Walk of G
  st V*(W1.vertexSeq()) = W2.vertexSeq() & E*(W1.edgeSeq()) = W2.edgeSeq()
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  consider F being PGraphMapping of G, replaceVerticesEdges(V,E) such that
    A1: F_V = V & F_E = E & F is Disomorphism by Th16;
  reconsider F as non empty one-to-one PGraphMapping of
    G,replaceVerticesEdges(V,E) by A1;
  let W2 be Walk of replaceVerticesEdges(V,E);
  reconsider W2 as F-valued Walk of replaceVerticesEdges(V,E)
    by A1, GLIB_010:122;
  take F"W2;
  thus thesis by A1, GLIB_010:def 39;
end;

theorem
  for G being _Graph
  for V being non empty one-to-one ManySortedSet of the_Vertices_of G
  for W2 being Walk of replaceVertices(V) ex W1 being Walk of G
  st V*(W1.vertexSeq()) = W2.vertexSeq() & W1.edgeSeq() = W2.edgeSeq()
proof
  let G be _Graph;
  let V be non empty one-to-one ManySortedSet of the_Vertices_of G;
  let W2 be Walk of replaceVertices(V);
  consider W1 being Walk of G such that
    A1: V*(W1.vertexSeq()) = W2.vertexSeq() and
    A2: (id the_Edges_of G)*(W1.edgeSeq()) = W2.edgeSeq() by Th21;
  take W1;
  rng(W1.edgeSeq()) c= the_Edges_of G;
  hence thesis by A1, A2, RELAT_1:53;
end;

theorem
  for G being _Graph, E being one-to-one ManySortedSet of the_Edges_of G
  for W2 being Walk of replaceEdges(E) ex W1 being Walk of G
  st W1.vertexSeq() = W2.vertexSeq() & E*(W1.edgeSeq()) = W2.edgeSeq()
proof
  let G be _Graph;
  let E be one-to-one ManySortedSet of the_Edges_of G;
  let W2 be Walk of replaceEdges(E);
  consider W1 being Walk of G such that
    A1: (id the_Vertices_of G)*(W1.vertexSeq()) = W2.vertexSeq() and
    A2: E*(W1.edgeSeq()) = W2.edgeSeq() by Th21;
  take W1;
  rng(W1.vertexSeq()) c= the_Vertices_of G;
  hence thesis by A1, A2, RELAT_1:53;
end;

begin :: Graph selectors of Graph-yielding Functions

definition
  let F be Graph-yielding Function;
  func the_Vertices_of F -> Function means
  :Def4:
  dom it = dom F &
    for x being object st x in dom F
    ex G being _Graph st G = F.x & it.x = the_Vertices_of G;
  existence
  proof
    defpred P[object,object] means
      ex G being _Graph st G = F.$1 & $2 = the_Vertices_of G;
    A1: for x,y1,y2 being object st x in dom F & P[x,y1] & P[x,y2]
      holds y1 = y2;
    A2: for x being object st x in dom F ex y being object st P[x,y]
    proof
      let x be object;
      assume x in dom F;
      then reconsider G = F.x as _Graph by GLIB_000:def 53;
      take the_Vertices_of G, G;
      thus thesis;
    end;
    consider f being Function such that
      A3: dom f = dom F & for x being object st x in dom F holds P[x,f.x]
      from FUNCT_1:sch 2(A1,A2);
    take f;
    thus thesis by A3;
  end;
  uniqueness
  proof
    let f1, f2 be Function;
    assume that
      A4: dom f1 = dom F & for x being object st x in dom F
        ex G being _Graph st G = F.x & f1.x = the_Vertices_of G and
      A5: dom f2 = dom F & for x being object st x in dom F
        ex G being _Graph st G = F.x & f2.x = the_Vertices_of G;
    now
      let x be object;
      assume A6: x in dom f1;
      then consider G1 being _Graph such that
        A7: G1 = F.x & f1.x = the_Vertices_of G1 by A4;
      consider G2 being _Graph such that
        A8: G2 = F.x & f2.x = the_Vertices_of G2 by A4, A5, A6;
      thus f1.x = f2.x by A7, A8;
    end;
    hence thesis by A4, A5, FUNCT_1:2;
  end;
  func the_Edges_of F -> Function means
  :Def5:
  dom it = dom F &
    for x being object st x in dom F
    ex G being _Graph st G = F.x & it.x = the_Edges_of G;
  existence
  proof
    defpred P[object,object] means
      ex G being _Graph st G = F.$1 & $2 = the_Edges_of G;
    A9: for x,y1,y2 being object st x in dom F & P[x,y1] & P[x,y2]
      holds y1 = y2;
    A10: for x being object st x in dom F ex y being object st P[x,y]
    proof
      let x be object;
      assume x in dom F;
      then reconsider G = F.x as _Graph by GLIB_000:def 53;
      take the_Edges_of G, G;
      thus thesis;
    end;
    consider f being Function such that
      A11: dom f = dom F & for x being object st x in dom F holds P[x,f.x]
      from FUNCT_1:sch 2(A9,A10);
    take f;
    thus thesis by A11;
  end;
  uniqueness
  proof
    let f1, f2 be Function;
    assume that
      A12: dom f1 = dom F & for x being object st x in dom F
        ex G being _Graph st G = F.x & f1.x = the_Edges_of G and
      A13: dom f2 = dom F & for x being object st x in dom F
        ex G being _Graph st G = F.x & f2.x = the_Edges_of G;
    now
      let x be object;
      assume A14: x in dom f1;
      then consider G1 being _Graph such that
        A15: G1 = F.x & f1.x = the_Edges_of G1 by A12;
      consider G2 being _Graph such that
        A16: G2 = F.x & f2.x = the_Edges_of G2 by A12, A13, A14;
      thus f1.x = f2.x by A15, A16;
    end;
    hence thesis by A12, A13, FUNCT_1:2;
  end;
  func the_Source_of F -> Function means
  :Def6:
  dom it = dom F &
    for x being object st x in dom F
    ex G being _Graph st G = F.x & it.x = the_Source_of G;
  existence
  proof
    defpred P[object,object] means
      ex G being _Graph st G = F.$1 & $2 = the_Source_of G;
    A17: for x,y1,y2 being object st x in dom F & P[x,y1] & P[x,y2]
      holds y1 = y2;
    A18: for x being object st x in dom F ex y being object st P[x,y]
    proof
      let x be object;
      assume x in dom F;
      then reconsider G = F.x as _Graph by GLIB_000:def 53;
      take the_Source_of G, G;
      thus thesis;
    end;
    consider f being Function such that
      A19: dom f = dom F & for x being object st x in dom F holds P[x,f.x]
      from FUNCT_1:sch 2(A17,A18);
    take f;
    thus thesis by A19;
  end;
  uniqueness
  proof
    let f1, f2 be Function;
    assume that
      A20: dom f1 = dom F & for x being object st x in dom F
        ex G being _Graph st G = F.x & f1.x = the_Source_of G and
      A21: dom f2 = dom F & for x being object st x in dom F
        ex G being _Graph st G = F.x & f2.x = the_Source_of G;
    now
      let x be object;
      assume A22: x in dom f1;
      then consider G1 being _Graph such that
        A23: G1 = F.x & f1.x = the_Source_of G1 by A20;
      consider G2 being _Graph such that
        A24: G2 = F.x & f2.x = the_Source_of G2 by A20, A21, A22;
      thus f1.x = f2.x by A23, A24;
    end;
    hence thesis by A20, A21, FUNCT_1:2;
  end;
  func the_Target_of F -> Function means
  :Def7:
  dom it = dom F &
    for x being object st x in dom F
    ex G being _Graph st G = F.x & it.x = the_Target_of G;
  existence
  proof
    defpred P[object,object] means
      ex G being _Graph st G = F.$1 & $2 = the_Target_of G;
    A25: for x,y1,y2 being object st x in dom F & P[x,y1] & P[x,y2]
      holds y1 = y2;
    A26: for x being object st x in dom F ex y being object st P[x,y]
    proof
      let x be object;
      assume x in dom F;
      then reconsider G = F.x as _Graph by GLIB_000:def 53;
      take the_Target_of G, G;
      thus thesis;
    end;
    consider f being Function such that
      A27: dom f = dom F & for x being object st x in dom F holds P[x,f.x]
      from FUNCT_1:sch 2(A25,A26);
    take f;
    thus thesis by A27;
  end;
  uniqueness
  proof
    let f1, f2 be Function;
    assume that
      A28: dom f1 = dom F & for x being object st x in dom F
        ex G being _Graph st G = F.x & f1.x = the_Target_of G and
      A29: dom f2 = dom F & for x being object st x in dom F
        ex G being _Graph st G = F.x & f2.x = the_Target_of G;
    now
      let x be object;
      assume A30: x in dom f1;
      then consider G1 being _Graph such that
        A31: G1 = F.x & f1.x = the_Target_of G1 by A28;
      consider G2 being _Graph such that
        A32: G2 = F.x & f2.x = the_Target_of G2 by A28, A29, A30;
      thus f1.x = f2.x by A31, A32;
    end;
    hence thesis by A28, A29, FUNCT_1:2;
  end;
end;

registration
  let F be Graph-yielding Function;
  cluster the_Source_of F -> Function-yielding;
  coherence
  proof
    now
      let x be object;
      assume x in dom the_Source_of F;
      then x in dom F by Def6;
      then consider G being _Graph such that
        A1: G = F.x & (the_Source_of F).x = the_Source_of G by Def6;
      thus (the_Source_of F).x is Function by A1;
    end;
    hence thesis by FUNCOP_1:def 6;
  end;
  cluster the_Target_of F -> Function-yielding;
  coherence
  proof
    now
      let x be object;
      assume x in dom the_Target_of F;
      then x in dom F by Def7;
      then consider G being _Graph such that
        A2: G = F.x & (the_Target_of F).x = the_Target_of G by Def7;
      thus (the_Target_of F).x is Function by A2;
    end;
    hence thesis by FUNCOP_1:def 6;
  end;
end;

registration
  let F be empty Graph-yielding Function;
  cluster the_Vertices_of F -> empty;
  coherence
  proof
    dom F = dom the_Vertices_of F by Def4;
    hence thesis;
  end;
  cluster the_Edges_of F -> empty;
  coherence
  proof
    dom F = dom the_Edges_of F by Def5;
    hence thesis;
  end;
  cluster the_Source_of F -> empty;
  coherence
  proof
    dom F = dom the_Source_of F by Def6;
    hence thesis;
  end;
  cluster the_Target_of F -> empty;
  coherence
  proof
    dom F = dom the_Target_of F by Def7;
    hence thesis;
  end;
end;

registration
  let F be non empty Graph-yielding Function;
  cluster the_Vertices_of F -> non empty;
  coherence
  proof
    dom F = dom the_Vertices_of F by Def4;
    hence thesis;
  end;
  cluster the_Edges_of F -> non empty;
  coherence
  proof
    dom F = dom the_Edges_of F by Def5;
    hence thesis;
  end;
  cluster the_Source_of F -> non empty;
  coherence
  proof
    dom F = dom the_Source_of F by Def6;
    hence thesis;
  end;
  cluster the_Target_of F -> non empty;
  coherence
  proof
    dom F = dom the_Target_of F by Def7;
    hence thesis;
  end;
end;

registration
  let F be Graph-yielding Function;
  cluster the_Vertices_of F -> non-empty;
  coherence
  proof
    now
      let x be object;
      assume x in dom the_Vertices_of F;
      then x in dom F by Def4;
      then consider G being _Graph such that
        A1: G = F.x & (the_Vertices_of F).x = the_Vertices_of G by Def4;
      thus (the_Vertices_of F).x is non empty by A1;
    end;
    hence thesis by FUNCT_1:def 9;
  end;
end;

definition
  let F be non empty Graph-yielding Function;
  redefine func the_Vertices_of F means
  :Def8:
  dom it = dom F &
    for x being Element of dom F holds it.x = the_Vertices_of (F.x);
  compatibility
  proof
    let f be Function;
    hereby
      assume A1: f = the_Vertices_of F;
      hence dom f = dom F by Def4;
      let x be Element of dom F;
      consider G being _Graph such that
        A2: G = F.x & f.x = the_Vertices_of G by A1, Def4;
      thus f.x = the_Vertices_of(F.x) by A2;
    end;
    assume A3: dom f = dom F &
      for x being Element of dom F holds f.x = the_Vertices_of (F.x);
    now
      let x be object;
      assume x in dom F;
      then reconsider x0 = x as Element of dom F;
      reconsider G = F.x0 as _Graph;
      take G;
      thus G = F.x & f.x = the_Vertices_of G by A3;
    end;
    hence thesis by A3, Def4;
  end;
  redefine func the_Edges_of F means
  :Def9:
  dom it = dom F &
    for x being Element of dom F holds it.x = the_Edges_of (F.x);
  compatibility
  proof
    let f be Function;
    hereby
      assume A4: f = the_Edges_of F;
      hence dom f = dom F by Def5;
      let x be Element of dom F;
      consider G being _Graph such that
        A5: G = F.x & f.x = the_Edges_of G by A4, Def5;
      thus f.x = the_Edges_of(F.x) by A5;
    end;
    assume A6: dom f = dom F &
      for x being Element of dom F holds f.x = the_Edges_of (F.x);
    now
      let x be object;
      assume x in dom F;
      then reconsider x0 = x as Element of dom F;
      reconsider G = F.x0 as _Graph;
      take G;
      thus G = F.x & f.x = the_Edges_of G by A6;
    end;
    hence thesis by A6, Def5;
  end;
  redefine func the_Source_of F means
  dom it = dom F &
    for x being Element of dom F holds it.x = the_Source_of (F.x);
  compatibility
  proof
    let f be Function;
    hereby
      assume A7: f = the_Source_of F;
      hence dom f = dom F by Def6;
      let x be Element of dom F;
      consider G being _Graph such that
        A8: G = F.x & f.x = the_Source_of G by A7, Def6;
      thus f.x = the_Source_of(F.x) by A8;
    end;
    assume A9: dom f = dom F &
      for x being Element of dom F holds f.x = the_Source_of (F.x);
    now
      let x be object;
      assume x in dom F;
      then reconsider x0 = x as Element of dom F;
      reconsider G = F.x0 as _Graph;
      take G;
      thus G = F.x & f.x = the_Source_of G by A9;
    end;
    hence thesis by A9, Def6;
  end;
  redefine func the_Target_of F means
  dom it = dom F &
    for x being Element of dom F holds it.x = the_Target_of (F.x);
  compatibility
  proof
    let f be Function;
    hereby
      assume A10: f = the_Target_of F;
      hence dom f = dom F by Def7;
      let x be Element of dom F;
      consider G being _Graph such that
        A11: G = F.x & f.x = the_Target_of G by A10, Def7;
      thus f.x = the_Target_of(F.x) by A11;
    end;
    assume A12: dom f = dom F &
      for x being Element of dom F holds f.x = the_Target_of (F.x);
    now
      let x be object;
      assume x in dom F;
      then reconsider x0 = x as Element of dom F;
      reconsider G = F.x0 as _Graph;
      take G;
      thus G = F.x & f.x = the_Target_of G by A12;
    end;
    hence thesis by A12, Def7;
  end;
end;

theorem
  for F being Graph-yielding Function
  holds the_Vertices_of rng F = rng the_Vertices_of F
proof
  let F be Graph-yielding Function;
  now
    let z be object;
    hereby
      assume z in the_Vertices_of rng F;
      then consider G1 being _Graph such that
        A1: G1 in rng F & z = the_Vertices_of G1 by GLIB_014:def 14;
      consider x being object such that
        A2: x in dom F & G1 = F.x by A1, FUNCT_1:def 3;
      consider G2 being _Graph such that
        A3: G2 = F.x & (the_Vertices_of F).x = the_Vertices_of G2 by A2, Def4;
      x in dom the_Vertices_of F by A2, Def4;
      hence z in rng the_Vertices_of F by A1, A2, A3, FUNCT_1:3;
    end;
    assume z in rng the_Vertices_of F;
    then consider x being object such that
      A4: x in dom the_Vertices_of F & z = (the_Vertices_of F).x
      by FUNCT_1:def 3;
    A5: x in dom F by A4, Def4;
    then consider G1 being _Graph such that
      A6: G1 = F.x & (the_Vertices_of F).x = the_Vertices_of G1 by Def4;
    G1 in rng F by A5, A6, FUNCT_1:3;
    hence z in the_Vertices_of rng F by A4, A6, GLIB_014:def 14;
  end;
  hence thesis by TARSKI:2;
end;

theorem
  for F being Graph-yielding Function
  holds the_Edges_of rng F = rng the_Edges_of F
proof
  let F be Graph-yielding Function;
  now
    let z be object;
    hereby
      assume z in the_Edges_of rng F;
      then consider G1 being _Graph such that
        A1: G1 in rng F & z = the_Edges_of G1 by GLIB_014:def 15;
      consider x being object such that
        A2: x in dom F & G1 = F.x by A1, FUNCT_1:def 3;
      consider G2 being _Graph such that
        A3: G2 = F.x & (the_Edges_of F).x = the_Edges_of G2 by A2, Def5;
      x in dom the_Edges_of F by A2, Def5;
      hence z in rng the_Edges_of F by A1, A2, A3, FUNCT_1:3;
    end;
    assume z in rng the_Edges_of F;
    then consider x being object such that
      A4: x in dom the_Edges_of F & z = (the_Edges_of F).x
      by FUNCT_1:def 3;
    A5: x in dom F by A4, Def5;
    then consider G1 being _Graph such that
      A6: G1 = F.x & (the_Edges_of F).x = the_Edges_of G1 by Def5;
    G1 in rng F by A5, A6, FUNCT_1:3;
    hence z in the_Edges_of rng F by A4, A6, GLIB_014:def 15;
  end;
  hence thesis by TARSKI:2;
end;

theorem
  for F being Graph-yielding Function
  holds the_Source_of rng F = rng the_Source_of F
proof
  let F be Graph-yielding Function;
  now
    let z be object;
    hereby
      assume z in the_Source_of rng F;
      then consider G1 being _Graph such that
        A1: G1 in rng F & z = the_Source_of G1 by GLIB_014:def 16;
      consider x being object such that
        A2: x in dom F & G1 = F.x by A1, FUNCT_1:def 3;
      consider G2 being _Graph such that
        A3: G2 = F.x & (the_Source_of F).x = the_Source_of G2 by A2, Def6;
      x in dom the_Source_of F by A2, Def6;
      hence z in rng the_Source_of F by A1, A2, A3, FUNCT_1:3;
    end;
    assume z in rng the_Source_of F;
    then consider x being object such that
      A4: x in dom the_Source_of F & z = (the_Source_of F).x
      by FUNCT_1:def 3;
    A5: x in dom F by A4, Def6;
    then consider G1 being _Graph such that
      A6: G1 = F.x & (the_Source_of F).x = the_Source_of G1 by Def6;
    G1 in rng F by A5, A6, FUNCT_1:3;
    hence z in the_Source_of rng F by A4, A6, GLIB_014:def 16;
  end;
  hence thesis by TARSKI:2;
end;

theorem
  for F being Graph-yielding Function
  holds the_Target_of rng F = rng the_Target_of F
proof
  let F be Graph-yielding Function;
  now
    let z be object;
    hereby
      assume z in the_Target_of rng F;
      then consider G1 being _Graph such that
        A1: G1 in rng F & z = the_Target_of G1 by GLIB_014:def 17;
      consider x being object such that
        A2: x in dom F & G1 = F.x by A1, FUNCT_1:def 3;
      consider G2 being _Graph such that
        A3: G2 = F.x & (the_Target_of F).x = the_Target_of G2 by A2, Def7;
      x in dom the_Target_of F by A2, Def7;
      hence z in rng the_Target_of F by A1, A2, A3, FUNCT_1:3;
    end;
    assume z in rng the_Target_of F;
    then consider x being object such that
      A4: x in dom the_Target_of F & z = (the_Target_of F).x
      by FUNCT_1:def 3;
    A5: x in dom F by A4, Def7;
    then consider G1 being _Graph such that
      A6: G1 = F.x & (the_Target_of F).x = the_Target_of G1 by Def7;
    G1 in rng F by A5, A6, FUNCT_1:3;
    hence z in the_Target_of rng F by A4, A6, GLIB_014:def 17;
  end;
  hence thesis by TARSKI:2;
end;

begin :: Isomorphisms between Graph-membered Sets or Graph-yielding Functions

definition
  let S1, S2 be Graph-membered set;
  pred S1, S2 are_Disomorphic means
  ex f being one-to-one Function st dom f = S1 & rng f = S2 &
    for G being _Graph st G in S1 holds f.G is G-Disomorphic _Graph;
  reflexivity
  proof
    let S be Graph-membered set;
    take id S;
    thus dom id S = S & rng id S = S;
    let G be _Graph;
    assume G in S;
    then (id S).G = G by FUNCT_1:18;
    hence thesis by GLIB_010:53;
  end;
  symmetry
  proof
    let S1, S2 be Graph-membered set;
    given f being one-to-one Function such that
      A1: dom f = S1 & rng f = S2 and
      A2: for G being _Graph st G in S1 holds f.G is G-Disomorphic _Graph;
    take f";
    thus dom(f") = S2 & rng(f") = S1 by A1, FUNCT_1:33;
    let G be _Graph;
    assume G in S2;
    then consider G0 being object such that
      A3: G0 in dom f & f.G0 = G by A1, FUNCT_1:def 3;
    reconsider G0 as _Graph by A1, A3;
    G is G0-Disomorphic by A1, A2, A3;
    then G0 is G-Disomorphic by GLIB_010:96;
    hence thesis by A3, FUNCT_1:34;
  end;
  pred S1, S2 are_isomorphic means
  ex f being one-to-one Function st dom f = S1 & rng f = S2 &
    for G being _Graph st G in S1 holds f.G is G-isomorphic _Graph;
  reflexivity
  proof
    let S be Graph-membered set;
    take id S;
    thus dom id S = S & rng id S = S;
    let G be _Graph;
    assume G in S;
    then (id S).G = G by FUNCT_1:18;
    hence thesis by GLIB_010:53;
  end;
  symmetry
  proof
    let S1, S2 be Graph-membered set;
    given f being one-to-one Function such that
      A4: dom f = S1 & rng f = S2 and
      A5: for G being _Graph st G in S1 holds f.G is G-isomorphic _Graph;
    take f";
    thus dom(f") = S2 & rng(f") = S1 by A4, FUNCT_1:33;
    let G be _Graph;
    assume G in S2;
    then consider G0 being object such that
      A6: G0 in dom f & f.G0 = G by A4, FUNCT_1:def 3;
    reconsider G0 as _Graph by A4, A6;
    G is G0-isomorphic by A4, A5, A6;
    then G0 is G-isomorphic by GLIB_010:95;
    hence thesis by A6, FUNCT_1:34;
  end;
end;

theorem
  for S1, S2, S3 being Graph-membered set
  st S1, S2 are_Disomorphic & S2, S3 are_Disomorphic
  holds S1, S3 are_Disomorphic
proof
  let S1, S2, S3 be Graph-membered set;
  assume S1, S2 are_Disomorphic;
  then consider f being one-to-one Function such that
    A1: dom f = S1 & rng f = S2 and
    A2: for G being _Graph st G in S1 holds f.G is G-Disomorphic _Graph;
  assume S2, S3 are_Disomorphic;
  then consider g being one-to-one Function such that
    A3: dom g = S2 & rng g = S3 and
    A4: for G being _Graph st G in S2 holds g.G is G-Disomorphic _Graph;
  take g*f;
  thus dom(g*f) = S1 by A1, A3, RELAT_1:27;
  thus rng(g*f) = S3 by A1, A3, RELAT_1:28;
  let G be _Graph;
  assume A5: G in S1;
  then reconsider G9 = f.G as G-Disomorphic _Graph by A2;
  G9 in rng f by A1, A5, FUNCT_1:def 3;
  then g.G9 is G9-Disomorphic _Graph by A1, A4;
  hence thesis by A1, A5, FUNCT_1:13;
end;

theorem
  for S1, S2, S3 being Graph-membered set
  st S1, S2 are_isomorphic & S2, S3 are_isomorphic
  holds S1, S3 are_isomorphic
proof
  let S1, S2, S3 be Graph-membered set;
  assume S1, S2 are_isomorphic;
  then consider f being one-to-one Function such that
    A1: dom f = S1 & rng f = S2 and
    A2: for G being _Graph st G in S1 holds f.G is G-isomorphic _Graph;
  assume S2, S3 are_isomorphic;
  then consider g being one-to-one Function such that
    A3: dom g = S2 & rng g = S3 and
    A4: for G being _Graph st G in S2 holds g.G is G-isomorphic _Graph;
  take g*f;
  thus dom(g*f) = S1 by A1, A3, RELAT_1:27;
  thus rng(g*f) = S3 by A1, A3, RELAT_1:28;
  let G be _Graph;
  assume A5: G in S1;
  then reconsider G9 = f.G as G-isomorphic _Graph by A2;
  G9 in rng f by A1, A5, FUNCT_1:def 3;
  then g.G9 is G9-isomorphic _Graph by A1, A4;
  hence thesis by A1, A5, FUNCT_1:13;
end;

theorem
  for S1, S2 being Graph-membered set st S1, S2 are_Disomorphic
  holds S1, S2 are_isomorphic
proof
  let S1, S2 be Graph-membered set;
  assume S1, S2 are_Disomorphic;
  then consider f being one-to-one Function such that
    A1: dom f = S1 & rng f = S2 and
    A2: for G being _Graph st G in S1 holds f.G is G-Disomorphic _Graph;
  take f;
  thus thesis by A1, A2;
end;

theorem
  for S1, S2 being Graph-membered set st S1, S2 are_Disomorphic
  holds card S1 = card S2 by CARD_1:70;

theorem
  for S1, S2 being Graph-membered set st S1, S2 are_isomorphic
  holds card S1 = card S2 by CARD_1:70;

theorem
  for S1, S2 being empty Graph-membered set holds S1, S2 are_Disomorphic;

theorem
  for G1, G2 being _Graph
  holds {G1}, {G2} are_Disomorphic iff G2 is G1-Disomorphic
proof
  let G1, G2 be _Graph;
  hereby
    assume {G1}, {G2} are_Disomorphic;
    then consider f being one-to-one Function such that
      A1: dom f = {G1} & rng f = {G2} and
      A2: for G being _Graph st G in {G1} holds f.G is G-Disomorphic _Graph;
    A3: f = {G1} --> G2 by A1, FUNCOP_1:9;
    G1 in {G1} by TARSKI:def 1;
    then f.G1 is G1-Disomorphic _Graph & f.G1 = G2 by A2, A3, FUNCOP_1:7;
    hence G2 is G1-Disomorphic;
  end;
  assume A4: G2 is G1-Disomorphic;
  reconsider f = G1 .--> G2 as one-to-one Function;
  take f;
  f = {G1} --> G2 by FUNCOP_1:def 9;
  hence dom f = {G1} & rng f = {G2} by FUNCOP_1:8;
  let G be _Graph;
  assume G in {G1};
  then G = G1 by TARSKI:def 1;
  hence f.G is G-Disomorphic _Graph by A4, FUNCOP_1:72;
end;

theorem
  for G1, G2 being _Graph
  holds {G1}, {G2} are_isomorphic iff G2 is G1-isomorphic
proof
  let G1, G2 be _Graph;
  hereby
    assume {G1}, {G2} are_isomorphic;
    then consider f being one-to-one Function such that
      A1: dom f = {G1} & rng f = {G2} and
      A2: for G being _Graph st G in {G1} holds f.G is G-isomorphic _Graph;
    A3: f = {G1} --> G2 by A1, FUNCOP_1:9;
    G1 in {G1} by TARSKI:def 1;
    then f.G1 is G1-isomorphic _Graph & f.G1 = G2 by A2, A3, FUNCOP_1:7;
    hence G2 is G1-isomorphic;
  end;
  assume A4: G2 is G1-isomorphic;
  reconsider f = G1 .--> G2 as one-to-one Function;
  take f;
  f = {G1} --> G2 by FUNCOP_1:def 9;
  hence dom f = {G1} & rng f = {G2} by FUNCOP_1:8;
  let G be _Graph;
  assume G in {G1};
  then G = G1 by TARSKI:def 1;
  hence f.G is G-isomorphic _Graph by A4, FUNCOP_1:72;
end;

theorem
  for S1, S2 being Graph-membered set st S1,S2 are_isomorphic holds
    (S1 is empty implies S2 is empty) &
    (S1 is loopless implies S2 is loopless) &
    (S1 is non-multi implies S2 is non-multi) &
    (S1 is simple implies S2 is simple) &
    (S1 is acyclic implies S2 is acyclic) &
    (S1 is connected implies S2 is connected) &
    (S1 is Tree-like implies S2 is Tree-like) &
    (S1 is chordal implies S2 is chordal) &
    (S1 is edgeless implies S2 is edgeless) &
    (S1 is loopfull implies S2 is loopfull)
proof
  let S1, S2 be Graph-membered set;
  assume S1,S2 are_isomorphic;
  then consider f being one-to-one Function such that
    A1: dom f = S1 & rng f = S2 and
    A2: for G being _Graph st G in S1 holds f.G is G-isomorphic _Graph;
  hereby
    assume S1 is empty;
    then f = {}  by A1;
    hence S2 is empty by A1;
  end;
  hereby
    assume A3: S1 is loopless;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A4: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A4;
      G2 is G1-isomorphic by A1, A2, A4;
      then consider G being PGraphMapping of G1, G2 such that
        A5: G is isomorphism by GLIB_010:def 23;
      thus G2 is loopless by A1, A3, A4, A5, GLIB_010:89;
    end;
    hence S2 is loopless by GLIB_014:def 3;
  end;
  hereby
    assume A6: S1 is non-multi;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A7: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A7;
      G2 is G1-isomorphic by A1, A2, A7;
      then consider G being PGraphMapping of G1, G2 such that
        A8: G is isomorphism by GLIB_010:def 23;
      thus G2 is non-multi by A1, A6, A7, A8, GLIB_010:89;
    end;
    hence S2 is non-multi by GLIB_014:def 4;
  end;
  hereby
    assume A9: S1 is simple;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A10: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A10;
      G2 is G1-isomorphic by A1, A2, A10;
      then consider G being PGraphMapping of G1, G2 such that
        A11: G is isomorphism by GLIB_010:def 23;
      thus G2 is simple by A1, A9, A10, A11, GLIB_010:89;
    end;
    hence S2 is simple by GLIB_014:def 6;
  end;
  hereby
    assume A12: S1 is acyclic;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A13: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A13;
      G2 is G1-isomorphic by A1, A2, A13;
      then consider G being PGraphMapping of G1, G2 such that
        A14: G is isomorphism by GLIB_010:def 23;
      thus G2 is acyclic by A1, A12, A13, A14, GLIB_010:140;
    end;
    hence S2 is acyclic by GLIB_014:def 8;
  end;
  hereby
    assume A15: S1 is connected;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A16: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A16;
      G2 is G1-isomorphic by A1, A2, A16;
      then consider G being PGraphMapping of G1, G2 such that
        A17: G is isomorphism by GLIB_010:def 23;
      thus G2 is connected by A1, A15, A16, A17, GLIB_010:140;
    end;
    hence S2 is connected by GLIB_014:def 9;
  end;
  hereby
    assume A18: S1 is Tree-like;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A19: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A19;
      G2 is G1-isomorphic by A1, A2, A19;
      then consider G being PGraphMapping of G1, G2 such that
        A20: G is isomorphism by GLIB_010:def 23;
      G2 is connected acyclic by A1, A18, A19, A20, GLIB_010:140;
      hence G2 is Tree-like;
    end;
    hence S2 is Tree-like by GLIB_014:def 10;
  end;
  hereby
    assume A21: S1 is chordal;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A22: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A22;
      G2 is G1-isomorphic by A1, A2, A22;
      then consider G being PGraphMapping of G1, G2 such that
        A23: G is isomorphism by GLIB_010:def 23;
      thus G2 is chordal by A1, A21, A22, A23, GLIB_010:140;
    end;
    hence S2 is chordal by GLIB_014:def 11;
  end;
  hereby
    assume A24: S1 is edgeless;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A25: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A25;
      G2 is G1-isomorphic by A1, A2, A25;
      then consider G being PGraphMapping of G1, G2 such that
        A26: G is isomorphism by GLIB_010:def 23;
      thus G2 is edgeless by A1, A24, A25, A26, GLIB_010:89;
    end;
    hence S2 is edgeless by GLIB_014:def 12;
  end;
  hereby
    assume A27: S1 is loopfull;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A28: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A28;
      G2 is G1-isomorphic by A1, A2, A28;
      then consider G being PGraphMapping of G1, G2 such that
        A29: G is isomorphism by GLIB_010:def 23;
      thus G2 is loopfull by A1, A27, A28, A29, GLIB_012:10;
    end;
    hence S2 is loopfull by GLIB_014:def 13;
  end;
end;

theorem
  for S1, S2 being Graph-membered set st S1,S2 are_Disomorphic holds
    (S1 is non-Dmulti implies S2 is non-Dmulti) &
    (S1 is Dsimple implies S2 is Dsimple)
proof
  let S1, S2 be Graph-membered set;
  assume S1,S2 are_Disomorphic;
  then consider f being one-to-one Function such that
    A1: dom f = S1 & rng f = S2 and
    A2: for G being _Graph st G in S1 holds f.G is G-Disomorphic _Graph;
  hereby
    assume A3: S1 is non-Dmulti;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A4: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A4;
      G2 is G1-Disomorphic by A1, A2, A4;
      then consider G being PGraphMapping of G1, G2 such that
        A5: G is Disomorphism by GLIB_010:def 24;
      thus G2 is non-Dmulti by A1, A3, A4, A5, GLIB_010:90;
    end;
    hence S2 is non-Dmulti by GLIB_014:def 5;
  end;
  hereby
    assume A6: S1 is Dsimple;
    now
      let G2 be _Graph;
      assume G2 in S2;
      then consider G1 being object such that
        A7: G1 in dom f & f.G1 = G2 by A1, FUNCT_1:def 3;
      reconsider G1 as _Graph by A1, A7;
      G2 is G1-Disomorphic by A1, A2, A7;
      then consider G being PGraphMapping of G1, G2 such that
        A8: G is Disomorphism by GLIB_010:def 24;
      thus G2 is Dsimple by A1, A6, A7, A8, GLIB_010:90;
    end;
    hence S2 is Dsimple by GLIB_014:def 7;
  end;
end;

definition
  let F1, F2 being Graph-yielding Function;
  pred F1, F2 are_Disomorphic means
  ex p being one-to-one Function st dom p = dom F1 & rng p = dom F2 &
    for x being object st x in dom F1
    ex G1, G2 being _Graph st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
  reflexivity
  proof
    let F be Graph-yielding Function;
    reconsider p = id dom F as one-to-one Function;
    take p;
    thus dom p = dom F & rng p = dom F;
    let x be object;
    assume A1: x in dom F;
    then reconsider G = F.x as _Graph by GLIB_000:def 53;
    take G,G;
    thus G = F.x;
    thus G = F.(p.x) by A1, FUNCT_1:18;
    thus G is G-Disomorphic by GLIB_010:53;
  end;
  symmetry
  proof
    let F1, F2 be Graph-yielding Function;
    given p being one-to-one Function such that
      A2: dom p = dom F1 & rng p = dom F2 and
      A3: for x being object st x in dom F1 ex G1, G2 being _Graph
        st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
    take p";
    thus dom(p") = dom F2 & rng(p") = dom F1 by A2, FUNCT_1:33;
    let y be object;
    assume y in dom F2;
    then consider x being object such that
      A4: x in dom p & p.x = y by A2, FUNCT_1:def 3;
    consider G1, G2 being _Graph such that
      A5: G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic by A2, A3, A4;
    take G2, G1;
    thus G2 = F2.y by A4, A5;
    thus G1 = F1.(p".y) by A4, A5, FUNCT_1:34;
    thus G1 is G2-Disomorphic by A5, GLIB_010:96;
  end;
  pred F1, F2 are_isomorphic means
  ex p being one-to-one Function st dom p = dom F1 & rng p = dom F2 &
    for x being object st x in dom F1
    ex G1, G2 being _Graph st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
  reflexivity
  proof
    let F be Graph-yielding Function;
    reconsider p = id dom F as one-to-one Function;
    take p;
    thus dom p = dom F & rng p = dom F;
    let x be object;
    assume A6: x in dom F;
    then reconsider G = F.x as _Graph by GLIB_000:def 53;
    take G,G;
    thus G = F.x;
    thus G = F.(p.x) by A6, FUNCT_1:18;
    thus G is G-isomorphic by GLIB_010:53;
  end;
  symmetry
  proof
    let F1, F2 be Graph-yielding Function;
    given p being one-to-one Function such that
      A7: dom p = dom F1 & rng p = dom F2 and
      A8: for x being object st x in dom F1 ex G1, G2 being _Graph
        st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
    take p";
    thus dom(p") = dom F2 & rng(p") = dom F1 by A7, FUNCT_1:33;
    let y be object;
    assume y in dom F2;
    then consider x being object such that
      A9: x in dom p & p.x = y by A7, FUNCT_1:def 3;
    consider G1, G2 being _Graph such that
      A10: G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic by A7, A8, A9;
    take G2, G1;
    thus G2 = F2.y by A9, A10;
    thus G1 = F1.(p".y) by A9, A10, FUNCT_1:34;
    thus G1 is G2-isomorphic by A10, GLIB_010:95;
  end;
end;

theorem Th38:
  for F1, F2 being non empty Graph-yielding Function st dom F1 = dom F2 &
    for x1 being Element of dom F1, x2 being Element of dom F2 st x1 = x2
    holds F2.x2 is F1.x1-Disomorphic
  holds F1, F2 are_Disomorphic
proof
  let F1, F2 be non empty Graph-yielding Function;
  assume A1: dom F1 = dom F2;
  assume A2: for x1 being Element of dom F1, x2 being Element of dom F2
    st x1 = x2 holds F2.x2 is F1.x1-Disomorphic;
  reconsider p = id dom F1 as one-to-one Function;
  take p;
  thus dom p = dom F1 & rng p = dom F2 by A1;
  let x be object;
  assume A3: x in dom F1;
  then reconsider G1 = F1.x as _Graph;
  reconsider G2 = F2.x as _Graph by A1, A3;
  take G1, G2;
  thus G1 = F1.x & G2 = F2.(p.x) by A3, FUNCT_1:18;
  thus G2 is G1-Disomorphic by A1, A2, A3;
end;

theorem
  for F1, F2 being non empty Graph-yielding Function st dom F1 = dom F2 &
    for x1 being Element of dom F1, x2 being Element of dom F2 st x1 = x2
    holds F2.x2 is F1.x1-isomorphic
  holds F1, F2 are_isomorphic
proof
  let F1, F2 be non empty Graph-yielding Function;
  assume A1: dom F1 = dom F2;
  assume A2: for x1 being Element of dom F1, x2 being Element of dom F2
    st x1 = x2 holds F2.x2 is F1.x1-isomorphic;
  reconsider p = id dom F1 as one-to-one Function;
  take p;
  thus dom p = dom F1 & rng p = dom F2 by A1;
  let x be object;
  assume A3: x in dom F1;
  then reconsider G1 = F1.x as _Graph;
  reconsider G2 = F2.x as _Graph by A1, A3;
  take G1, G2;
  thus G1 = F1.x & G2 = F2.(p.x) by A3, FUNCT_1:18;
  thus G2 is G1-isomorphic by A1, A2, A3;
end;

theorem Th40:
  for F1, F2, F3 being Graph-yielding Function
  st F1, F2 are_Disomorphic & F2, F3 are_Disomorphic
  holds F1, F3 are_Disomorphic
proof
  let F1, F2, F3 be Graph-yielding Function;
  assume F1, F2 are_Disomorphic;
  then consider p being one-to-one Function such that
    A1: dom p = dom F1 & rng p = dom F2 and
    A2: for x being object st x in dom F1 ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
  assume F2, F3 are_Disomorphic;
  then consider q being one-to-one Function such that
    A3: dom q = dom F2 & rng q = dom F3 and
    A4: for x being object st x in dom F2 ex G2, G3 being _Graph
      st G2 = F2.x & G3 = F3.(q.x) & G3 is G2-Disomorphic;
  take q*p;
  dom(q*p) = dom p & rng(q*p) = rng q by A1, A3, RELAT_1:27, RELAT_1:28;
  hence A5: dom(q*p) = dom F1 & rng(q*p) = dom F3 by A1, A3;
  let x be object;
  assume x in dom F1;
  then A6: x in dom p & p.x in dom q by A5, FUNCT_1:11;
  then consider G1, G2 be _Graph such that
    A7: G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic by A1, A2;
  consider G9,G3 being _Graph such that
    A8: G9 = F2.(p.x) & G3 = F3.(q.(p.x)) & G3 is G9-Disomorphic by A3, A4, A6;
  take G1, G3;
  thus G1 = F1.x by A7;
  thus G3 = F3.((q*p).x) by A6, A8, FUNCT_1:13;
  thus thesis by A7, A8;
end;

theorem Th41:
  for F1, F2, F3 being Graph-yielding Function
  st F1, F2 are_isomorphic & F2, F3 are_isomorphic
  holds F1, F3 are_isomorphic
proof
  let F1, F2, F3 be Graph-yielding Function;
  assume F1, F2 are_isomorphic;
  then consider p being one-to-one Function such that
    A1: dom p = dom F1 & rng p = dom F2 and
    A2: for x being object st x in dom F1 ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
  assume F2, F3 are_isomorphic;
  then consider q being one-to-one Function such that
    A3: dom q = dom F2 & rng q = dom F3 and
    A4: for x being object st x in dom F2 ex G2, G3 being _Graph
      st G2 = F2.x & G3 = F3.(q.x) & G3 is G2-isomorphic;
  take q*p;
  dom(q*p) = dom p & rng(q*p) = rng q by A1, A3, RELAT_1:27, RELAT_1:28;
  hence A5: dom(q*p) = dom F1 & rng(q*p) = dom F3 by A1, A3;
  let x be object;
  assume x in dom F1;
  then A6: x in dom p & p.x in dom q by A5, FUNCT_1:11;
  then consider G1, G2 be _Graph such that
    A7: G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic by A1, A2;
  consider G9,G3 being _Graph such that
    A8: G9 = F2.(p.x) & G3 = F3.(q.(p.x)) & G3 is G9-isomorphic by A3, A4, A6;
  take G1, G3;
  thus G1 = F1.x by A7;
  thus G3 = F3.((q*p).x) by A6, A8, FUNCT_1:13;
  thus thesis by A7, A8;
end;

theorem Th42:
  for F1, F2 being Graph-yielding Function
  st F1, F2 are_Disomorphic holds F1, F2 are_isomorphic
proof
  let F1, F2 be Graph-yielding Function;
  assume F1, F2 are_Disomorphic;
  then consider p being one-to-one Function such that
    A1: dom p = dom F1 & rng p = dom F2 and
    A2: for x being object st x in dom F1 ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
  take p;
  thus dom p = dom F1 & rng p = dom F2 by A1;
  let x be object;
  assume x in dom F1;
  then consider G1, G2 being _Graph such that
    A3: G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic by A2;
  take G1, G2;
  thus thesis by A3;
end;

:: might require Proof outside this article
theorem
  for F1, F2 being empty Graph-yielding Function
  holds F1, F2 are_Disomorphic & F1, F2 are_isomorphic;

theorem
  for F1, F2 being Graph-yielding Function
  st F1, F2 are_Disomorphic holds card F1 = card F2
proof
  let F1, F2 be Graph-yielding Function;
  assume F1, F2 are_Disomorphic;
  then consider p being one-to-one Function such that
    A1: dom p = dom F1 & rng p = dom F2 and
    for x being object st x in dom F1 ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
  thus card F1 = card dom F1 by CARD_1:62
    .= card dom F2 by A1, CARD_1:70
    .= card F2 by CARD_1:62;
end;

theorem
  for F1, F2 being Graph-yielding Function
  st F1, F2 are_isomorphic holds card F1 = card F2
proof
  let F1, F2 be Graph-yielding Function;
  assume F1, F2 are_isomorphic;
  then consider p being one-to-one Function such that
    A1: dom p = dom F1 & rng p = dom F2 and
    for x being object st x in dom F1 ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
  thus card F1 = card dom F1 by CARD_1:62
    .= card dom F2 by A1, CARD_1:70
    .= card F2 by CARD_1:62;
end;

theorem
  for G1, G2 being _Graph, x,y being object
  holds x .--> G1, y .--> G2 are_Disomorphic iff G2 is G1-Disomorphic
proof
  let G1, G2 be _Graph, x,y be object;
  hereby
    assume x .--> G1, y .--> G2 are_Disomorphic;
    then consider p being one-to-one Function such that
      A1: dom p = dom(x .--> G1) & rng p = dom(y .--> G2) and
      A2: for z being object st z in dom(x .--> G1) ex G3, G4 being _Graph
        st G3 = (x .--> G1).z & G4 = (y .--> G2).(p.z) & G4 is G3-Disomorphic;
    dom p = dom{[x,G1]} & rng p = dom{[y,G2]} by A1, FUNCT_4:82;
    then dom p = {x} & rng p = {y} by RELAT_1:9;
    then A3: p = x .--> y by FUNCT_4:112;
    dom(x .--> G1) = dom{[x,G1]} by FUNCT_4:82
      .= {x} by RELAT_1:9;
    then x in dom(x .--> G1) by TARSKI:def 1;
    then consider G3, G4 being _Graph such that
      A4: G3 = (x .--> G1).x & G4 = (y .--> G2).(p.x) & G4 is G3-Disomorphic
      by A2;
    A5: G3 = G1 by A4, FUNCOP_1:72;
    G4 = (y .--> G2).y by A3, A4, FUNCOP_1:72
      .= G2 by FUNCOP_1:72;
    hence G2 is G1-Disomorphic by A4, A5;
  end;
  assume A6: G2 is G1-Disomorphic;
  take p = x .--> y;
  thus dom p = dom{[x,y]} by FUNCT_4:82
    .= {x} by RELAT_1:9
    .= dom{[x,G1]} by RELAT_1:9
    .= dom(x .--> G1) by FUNCT_4:82;
  p = {x} --> y by FUNCOP_1:def 9;
  hence rng p = {y} by FUNCOP_1:8
    .= dom{[y,G2]} by RELAT_1:9
    .= dom(y .--> G2) by FUNCT_4:82;
  let z be object;
  assume z in dom(x .--> G1);
  then A7: z = x by TARSKI:def 1;
  take G1, G2;
  thus G1 = (x .--> G1).z by A7, FUNCOP_1:72;
  thus G2 = (y .--> G2).y by FUNCOP_1:72
    .= (y .--> G2).(p.z) by A7, FUNCOP_1:72;
  thus thesis by A6;
end;

theorem
  for G1, G2 being _Graph, x,y being object
  holds x .--> G1, y .--> G2 are_isomorphic iff G2 is G1-isomorphic
proof
  let G1, G2 be _Graph, x,y be object;
  hereby
    assume x .--> G1, y .--> G2 are_isomorphic;
    then consider p being one-to-one Function such that
      A1: dom p = dom(x .--> G1) & rng p = dom(y .--> G2) and
      A2: for z being object st z in dom(x .--> G1) ex G3, G4 being _Graph
        st G3 = (x .--> G1).z & G4 = (y .--> G2).(p.z) & G4 is G3-isomorphic;
    dom p = dom{[x,G1]} & rng p = dom{[y,G2]} by A1, FUNCT_4:82;
    then dom p = {x} & rng p = {y} by RELAT_1:9;
    then A3: p = x .--> y by FUNCT_4:112;
    dom(x .--> G1) = dom{[x,G1]} by FUNCT_4:82
      .= {x} by RELAT_1:9;
    then x in dom(x .--> G1) by TARSKI:def 1;
    then consider G3, G4 being _Graph such that
      A4: G3 = (x .--> G1).x & G4 = (y .--> G2).(p.x) & G4 is G3-isomorphic
      by A2;
    A5: G3 = G1 by A4, FUNCOP_1:72;
    G4 = (y .--> G2).y by A3, A4, FUNCOP_1:72
      .= G2 by FUNCOP_1:72;
    hence G2 is G1-isomorphic by A4, A5;
  end;
  assume A6: G2 is G1-isomorphic;
  take p = x .--> y;
  thus dom p = dom{[x,y]} by FUNCT_4:82
    .= {x} by RELAT_1:9
    .= dom{[x,G1]} by RELAT_1:9
    .= dom(x .--> G1) by FUNCT_4:82;
  p = {x} --> y by FUNCOP_1:def 9;
  hence rng p = {y} by FUNCOP_1:8
    .= dom{[y,G2]} by RELAT_1:9
    .= dom(y .--> G2) by FUNCT_4:82;
  let z be object;
  assume z in dom(x .--> G1);
  then A7: z = x by TARSKI:def 1;
  take G1, G2;
  thus G1 = (x .--> G1).z by A7, FUNCOP_1:72;
  thus G2 = (y .--> G2).y by FUNCOP_1:72
    .= (y .--> G2).(p.z) by A7, FUNCOP_1:72;
  thus thesis by A6;
end;

theorem Th48:
  for F1, F2 being Graph-yielding Function st F1, F2 are_isomorphic holds
    (F1 is empty implies F2 is empty) &
    (F1 is loopless implies F2 is loopless) &
    (F1 is non-multi implies F2 is non-multi) &
    (F1 is simple implies F2 is simple) &
    (F1 is acyclic implies F2 is acyclic) &
    (F1 is connected implies F2 is connected) &
    (F1 is Tree-like implies F2 is Tree-like) &
    (F1 is chordal implies F2 is chordal) &
    (F1 is edgeless implies F2 is edgeless) &
    (F1 is loopfull implies F2 is loopfull)
proof
  let F1, F2 be Graph-yielding Function;
  assume F1,F2 are_isomorphic;
  then consider p being one-to-one Function such that
    A1: dom p = dom F1 & rng p = dom F2 and
    A2: for x being object st x in dom F1 ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
  hereby
    assume F1 is empty;
    then p = {} by A1;
    hence F2 is empty by A1;
  end;
  hereby
    assume A3: F1 is loopless;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A4: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A5: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-isomorphic by A1, A2, A4;
      take G2;
      thus F2.x = G2 by A4, A5;
      consider G9 being _Graph such that
        A6: F1.x0 = G9 & G9 is loopless by A1, A3, A4, GLIB_000:def 59;
      thus G2 is loopless by A5, A6;
    end;
    hence F2 is loopless by GLIB_000:def 59;
  end;
  hereby
    assume A7: F1 is non-multi;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A8: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A9: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-isomorphic by A1, A2, A8;
      take G2;
      thus F2.x = G2 by A8, A9;
      consider G9 being _Graph such that
        A10: F1.x0 = G9 & G9 is non-multi by A1, A7, A8, GLIB_000:def 62;
      consider G being PGraphMapping of G1, G2 such that
        A11: G is isomorphism by A9, GLIB_010:def 23;
      thus G2 is non-multi by A9, A10, A11, GLIB_010:89;
    end;
    hence F2 is non-multi by GLIB_000:def 62;
  end;
  hereby
    assume A12: F1 is simple;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A13: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A14: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-isomorphic by A1, A2, A13;
      take G2;
      thus F2.x = G2 by A13, A14;
      consider G9 being _Graph such that
        A15: F1.x0 = G9 & G9 is simple by A1, A12, A13, GLIB_000:def 64;
      consider G being PGraphMapping of G1, G2 such that
        A16: G is isomorphism by A14, GLIB_010:def 23;
      thus G2 is simple by A14, A15, A16, GLIB_010:89;
    end;
    hence F2 is simple by GLIB_000:def 64;
  end;
  hereby
    assume A17: F1 is acyclic;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A18: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A19: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-isomorphic by A1, A2, A18;
      take G2;
      thus F2.x = G2 by A18, A19;
      consider G9 being _Graph such that
        A20: F1.x0 = G9 & G9 is acyclic by A1, A17, A18, GLIB_002:def 13;
      consider G being PGraphMapping of G1, G2 such that
        A21: G is isomorphism by A19, GLIB_010:def 23;
      thus G2 is acyclic by A19, A20, A21, GLIB_010:140;
    end;
    hence F2 is acyclic by GLIB_002:def 13;
  end;
  hereby
    assume A22: F1 is connected;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A23: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A24: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-isomorphic by A1, A2, A23;
      take G2;
      thus F2.x = G2 by A23, A24;
      consider G9 being _Graph such that
        A25: F1.x0 = G9 & G9 is connected by A1, A22, A23, GLIB_002:def 12;
      consider G being PGraphMapping of G1, G2 such that
        A26: G is isomorphism by A24, GLIB_010:def 23;
      thus G2 is connected by A24, A25, A26, GLIB_010:140;
    end;
    hence F2 is connected by GLIB_002:def 12;
  end;
  hereby
    assume A27: F1 is Tree-like;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A28: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A29: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-isomorphic by A1, A2, A28;
      take G2;
      thus F2.x = G2 by A28, A29;
      consider G9 being _Graph such that
        A30: F1.x0 = G9 & G9 is Tree-like by A1, A27, A28, GLIB_002:def 14;
      consider G being PGraphMapping of G1, G2 such that
        A31: G is isomorphism by A29, GLIB_010:def 23;
      G2 is connected acyclic by A29, A30, A31, GLIB_010:140;
      hence G2 is Tree-like;
    end;
    hence F2 is Tree-like by GLIB_002:def 14;
  end;
  hereby
    assume A32: F1 is chordal;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A33: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A34: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-isomorphic by A1, A2, A33;
      take G2;
      thus F2.x = G2 by A33, A34;
      consider G9 being _Graph such that
        A35: F1.x0 = G9 & G9 is chordal by A1, A32, A33, GLIBPRE0:def 4;
      consider G being PGraphMapping of G1, G2 such that
        A36: G is isomorphism by A34, GLIB_010:def 23;
      thus G2 is chordal by A34, A35, A36, GLIB_010:140;
    end;
    hence F2 is chordal by GLIBPRE0:def 4;
  end;
  hereby
    assume A37: F1 is edgeless;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A38: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A39: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-isomorphic by A1, A2, A38;
      take G2;
      thus F2.x = G2 by A38, A39;
      consider G9 being _Graph such that
        A40: F1.x0 = G9 & G9 is edgeless by A1, A37, A38, GLIB_008:def 2;
      consider G being PGraphMapping of G1, G2 such that
        A41: G is isomorphism by A39, GLIB_010:def 23;
      thus G2 is edgeless by A39, A40, A41, GLIB_010:89;
    end;
    hence F2 is edgeless by GLIB_008:def 2;
  end;
  hereby
    assume A42: F1 is loopfull;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A43: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A44: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-isomorphic by A1, A2, A43;
      take G2;
      thus F2.x = G2 by A43, A44;
      consider G9 being _Graph such that
        A45: F1.x0 = G9 & G9 is loopfull by A1, A42, A43, GLIB_012:def 2;
      consider G being PGraphMapping of G1, G2 such that
        A46: G is isomorphism by A44, GLIB_010:def 23;
      thus G2 is loopfull by A44, A45, A46, GLIB_012:10;
    end;
    hence F2 is loopfull by GLIB_012:def 2;
  end;
end;

theorem Th49:
  for F1, F2 being Graph-yielding Function st F1, F2 are_Disomorphic holds
    (F1 is non-Dmulti implies F2 is non-Dmulti) &
    (F1 is Dsimple implies F2 is Dsimple)
proof
  let F1, F2 be Graph-yielding Function;
  assume F1,F2 are_Disomorphic;
  then consider p being one-to-one Function such that
    A1: dom p = dom F1 & rng p = dom F2 and
    A2: for x being object st x in dom F1 ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
  hereby
    assume A3: F1 is non-Dmulti;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A4: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A5: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-Disomorphic by A1, A2, A4;
      take G2;
      thus F2.x = G2 by A4, A5;
      consider G9 being _Graph such that
        A6: F1.x0 = G9 & G9 is non-Dmulti by A1, A3, A4, GLIB_000:def 63;
      consider G being PGraphMapping of G1, G2 such that
        A7: G is Disomorphism by A5, GLIB_010:def 24;
      thus G2 is non-Dmulti by A5, A6, A7, GLIB_010:90;
    end;
    hence F2 is non-Dmulti by GLIB_000:def 63;
  end;
  hereby
    assume A8: F1 is Dsimple;
    now
      let x be object;
      assume x in dom F2;
      then consider x0 being object such that
        A9: x0 in dom p & p.x0 = x by A1, FUNCT_1:def 3;
      consider G1, G2 being _Graph such that
        A10: G1 = F1.x0 & G2 = F2.(p.x0) & G2 is G1-Disomorphic by A1, A2, A9;
      take G2;
      thus F2.x = G2 by A9, A10;
      consider G9 being _Graph such that
        A11: F1.x0 = G9 & G9 is Dsimple by A1, A8, A9, GLIB_000:def 65;
      consider G being PGraphMapping of G1, G2 such that
        A12: G is Disomorphism by A10, GLIB_010:def 24;
      thus G2 is Dsimple by A10, A11, A12, GLIB_010:90;
    end;
    hence F2 is Dsimple by GLIB_000:def 65;
  end;
end;

definition
  let I be set, F1, F2 being Graph-yielding ManySortedSet of I;
  redefine pred F1, F2 are_Disomorphic means
  ex p being Permutation of I st
  for x being object st x in I
  ex G1, G2 being _Graph st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
  compatibility
  proof
    hereby
      assume F1, F2 are_Disomorphic;
      then consider p being one-to-one Function such that
        A1: dom p = dom F1 & rng p = dom F2 and
        A2: for x being object st x in dom F1 ex G1, G2 being _Graph
          st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
      A3: dom p = I & rng p = I by A1, PARTFUN1:def 2;
      then reconsider p as one-to-one Function of I,I by FUNCT_2:1;
      p is onto by A3, FUNCT_2:def 3;
      then reconsider p as Permutation of I;
      take p;
      let x be object;
      assume x in I;
      then x in dom F1 by PARTFUN1:def 2;
      then consider G1, G2 being _Graph such that
        A4: G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic by A2;
      take G1, G2;
      thus G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic by A4;
    end;
    given p being Permutation of I such that
      A5: for x being object st x in I ex G1, G2 being _Graph
        st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
    reconsider p as one-to-one Function;
    take p;
    thus dom p = I by PARTFUN1:def 2
      .= dom F1 by PARTFUN1:def 2;
    thus rng p = I by FUNCT_2:def 3
      .= dom F2 by PARTFUN1:def 2;
    let x be object;
    assume x in dom F1;
    hence thesis by A5;
  end;
  reflexivity
  proof
    let F be Graph-yielding ManySortedSet of I;
    reconsider p = id I as Permutation of I;
    take p;
    let x be object;
    assume A6: x in I;
    then x in dom F by PARTFUN1:def 2;
    then reconsider G = F.x as _Graph by GLIB_000:def 53;
    take G, G;
    thus thesis by A6, FUNCT_1:18, GLIB_010:53;
  end;
  symmetry
  proof
    let F1, F2 be Graph-yielding ManySortedSet of I;
    assume ex p being Permutation of I st
      for x being object st x in I ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
    then consider p being Permutation of I such that
      A7: for x being object st x in I ex G1, G2 being _Graph
        st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
    reconsider q = p" as Permutation of I;
    take q;
    let y be object;
    assume y in I;
    then A8: y in dom q by FUNCT_2:def 1;
    then q.y in rng q by FUNCT_1:3;
    then consider G1, G2 being _Graph such that
      A9: G1 = F1.(q.y) & G2 = F2.(p.(q.y)) & G2 is G1-Disomorphic by A7;
    take G2, G1;
    y in rng p by A8, FUNCT_1:33;
    hence G2 = F2.y by A9, FUNCT_1:35;
    thus thesis by A9, GLIB_010:96;
  end;
  redefine pred F1, F2 are_isomorphic means
  ex p being Permutation of I st
  for x being object st x in I
  ex G1, G2 being _Graph st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
  compatibility
  proof
    hereby
      assume F1, F2 are_isomorphic;
      then consider p being one-to-one Function such that
        A10: dom p = dom F1 & rng p = dom F2 and
        A11: for x being object st x in dom F1 ex G1, G2 being _Graph
          st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
      A12: dom p = I & rng p = I by A10, PARTFUN1:def 2;
      then reconsider p as one-to-one Function of I,I by FUNCT_2:1;
      p is onto by A12, FUNCT_2:def 3;
      then reconsider p as Permutation of I;
      take p;
      let x be object;
      assume x in I;
      then x in dom F1 by PARTFUN1:def 2;
      then consider G1, G2 being _Graph such that
        A13: G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic by A11;
      take G1, G2;
      thus G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic by A13;
    end;
    given p being Permutation of I such that
      A14: for x being object st x in I ex G1, G2 being _Graph
        st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
    reconsider p as one-to-one Function;
    take p;
    thus dom p = I by PARTFUN1:def 2
      .= dom F1 by PARTFUN1:def 2;
    thus rng p = I by FUNCT_2:def 3
      .= dom F2 by PARTFUN1:def 2;
    let x be object;
    assume x in dom F1;
    hence thesis by A14;
  end;
  reflexivity
  proof
    let F be Graph-yielding ManySortedSet of I;
    reconsider p = id I as Permutation of I;
    take p;
    let x be object;
    assume A15: x in I;
    then x in dom F by PARTFUN1:def 2;
    then reconsider G = F.x as _Graph by GLIB_000:def 53;
    take G, G;
    thus thesis by A15, FUNCT_1:18, GLIB_010:53;
  end;
  symmetry
  proof
    let F1, F2 be Graph-yielding ManySortedSet of I;
    assume ex p being Permutation of I st
      for x being object st x in I ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
    then consider p being Permutation of I such that
      A16: for x being object st x in I ex G1, G2 being _Graph
        st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
    reconsider q = p" as Permutation of I;
    take q;
    let y be object;
    assume y in I;
    then A17: y in dom q by FUNCT_2:def 1;
    then q.y in rng q by FUNCT_1:3;
    then consider G1, G2 being _Graph such that
      A18: G1 = F1.(q.y) & G2 = F2.(p.(q.y)) & G2 is G1-isomorphic by A16;
    take G2, G1;
    y in rng p by A17, FUNCT_1:33;
    hence G2 = F2.y by A18, FUNCT_1:35;
    thus thesis by A18, GLIB_010:95;
  end;
end;

begin :: Distinguishing the Vertex and Edge Sets of several Graphs from each other

definition
  let S being Graph-membered set;
  attr S is vertex-disjoint means
  :Def18:
  for G1, G2 being _Graph st G1 in S & G2 in S & G1 <> G2
  holds the_Vertices_of G1 misses the_Vertices_of G2;
  attr S is edge-disjoint means
  :Def19:
  for G1, G2 being _Graph st G1 in S & G2 in S & G1 <> G2
  holds the_Edges_of G1 misses the_Edges_of G2;
end;

:: might require Proof outside this article
theorem
  for S being Graph-membered set holds S is vertex-disjoint edge-disjoint iff
    for G1, G2 being _Graph st G1 in S & G2 in S & G1 <> G2
    holds the_Vertices_of G1 misses the_Vertices_of G2 &
      the_Edges_of G1 misses the_Edges_of G2;

registration
  cluster trivial -> vertex-disjoint edge-disjoint for Graph-membered set;
  coherence by ZFMISC_1:def 10;
  cluster edgeless -> edge-disjoint for Graph-membered set;
  coherence
  proof
    let S be Graph-membered set;
    assume A1: S is edgeless;
    let G1, G2 be _Graph;
    assume G1 in S & G2 in S & G1 <> G2;
    then the_Edges_of G1 = {} & the_Edges_of G2 = {} by A1;
    hence thesis by XBOOLE_1:65;
  end;
  cluster edge-disjoint -> \/-tolerating for Graph-membered set;
  coherence
  proof
    let S be Graph-membered set;
    assume A2: S is edge-disjoint;
    now
      let G1, G2 be _Graph;
      assume A3: G1 in S & G2 in S;
      per cases;
      suppose G1 = G2;
        hence G1 tolerates G2;
      end;
      suppose G1 <> G2;
        then the_Edges_of G1 misses the_Edges_of G2 by A2, A3;
        hence G1 tolerates G2 by GLIB_014:12;
      end;
    end;
    hence thesis by GLIB_014:def 23;
  end;
  cluster vertex-disjoint \/-tolerating -> edge-disjoint
    for Graph-membered set;
  coherence
  proof
    let S be Graph-membered set;
    assume A4: S is vertex-disjoint \/-tolerating;
    let G1, G2 be _Graph;
    assume A5: G1 in S & G2 in S & G1 <> G2;
    the_Edges_of G1 /\ the_Edges_of G2 = {}
    proof
      assume the_Edges_of G1 /\ the_Edges_of G2 <> {};
      then consider e being object such that
        A6: e in the_Edges_of G1 /\ the_Edges_of G2 by XBOOLE_0:def 1;
      set v1 = (the_Source_of G1).e, w1 = (the_Target_of G1).e;
      set v2 = (the_Source_of G2).e, w2 = (the_Target_of G2).e;
      e in the_Edges_of G1 & e in the_Edges_of G2 by A6, XBOOLE_0:def 4;
      then A7: e DJoins v1,w1,G1 & e DJoins v2,w2,G2 by GLIB_000:def 14;
      G1 tolerates G2 by A4, A5, GLIB_014:def 23;
      then A8: v1 = v2 by A7, GLIB_014:17;
      e Joins v1,w1,G1 & e Joins v2,w2,G2 by A7, GLIB_000:16;
      then v1 in the_Vertices_of G1 & v2 in the_Vertices_of G2 by GLIB_000:13;
      hence contradiction by A4, A5, A8, XBOOLE_0:3;
    end;
    hence thesis by XBOOLE_0:def 7;
  end;
end;

registration
  let G be _Graph;
  cluster {G} -> vertex-disjoint edge-disjoint;
  coherence;
end;

theorem
  for G1, G2 being _Graph holds {G1, G2} is vertex-disjoint
    iff G1 = G2 or the_Vertices_of G1 misses the_Vertices_of G2
proof
  let G1, G2 be _Graph;
  hereby
    assume A1: {G1, G2} is vertex-disjoint;
    assume A2: G1 <> G2;
    G1 in {G1, G2} & G2 in {G1, G2} by TARSKI:def 2;
    hence the_Vertices_of G1 misses the_Vertices_of G2 by A1, A2;
  end;
  assume G1 = G2 or the_Vertices_of G1 misses the_Vertices_of G2;
  then per cases;
  suppose G1 = G2;
    then {G1, G2} = {G1} by ENUMSET1:29;
    hence thesis;
  end;
  suppose A3: the_Vertices_of G1 misses the_Vertices_of G2;
    let G3, G4 be _Graph;
    assume G3 in {G1,G2} & G4 in {G1,G2} & G3 <> G4;
    then (G3=G1 or G3=G2) & (G4=G1 or G4=G2) & G3 <> G4 by TARSKI:def 2;
    hence thesis by A3;
  end;
end;

theorem
  for G1, G2 being _Graph holds {G1, G2} is edge-disjoint
    iff G1 = G2 or the_Edges_of G1 misses the_Edges_of G2
proof
  let G1, G2 be _Graph;
  hereby
    assume A1: {G1, G2} is edge-disjoint;
    assume A2: G1 <> G2;
    G1 in {G1, G2} & G2 in {G1, G2} by TARSKI:def 2;
    hence the_Edges_of G1 misses the_Edges_of G2 by A1, A2;
  end;
  assume G1 = G2 or the_Edges_of G1 misses the_Edges_of G2;
  then per cases;
  suppose G1 = G2;
    then {G1, G2} = {G1} by ENUMSET1:29;
    hence thesis;
  end;
  suppose A3: the_Edges_of G1 misses the_Edges_of G2;
    let G3, G4 be _Graph;
    assume G3 in {G1,G2} & G4 in {G1,G2} & G3 <> G4;
    then (G3=G1 or G3=G2) & (G4=G1 or G4=G2) & G3 <> G4 by TARSKI:def 2;
    hence thesis by A3;
  end;
end;

registration
  cluster non empty \/-tolerating vertex-disjoint edge-disjoint acyclic
    simple Dsimple loopless non-multi non-Dmulti for Graph-membered set;
  existence
  proof
    take {the Tree-like _Graph};
    thus thesis;
  end;
end;

:: note that the other direction does not work,
:: for example take S = {G,H} with G == H <> G
registration
  let S be vertex-disjoint Graph-membered set;
  cluster the_Vertices_of S -> mutually-disjoint;
  coherence
  proof
    now
      let x,y be set;
      assume x in the_Vertices_of S;
      then consider G being _Graph such that
        A1: G in S & x = the_Vertices_of G by GLIB_014:def 14;
      assume y in the_Vertices_of S;
      then consider H being _Graph such that
        A2: H in S & y = the_Vertices_of H by GLIB_014:def 14;
      assume x <> y;
      then H <> G by A1, A2;
      hence x misses y by A1, A2, Def18;
    end;
    hence the_Vertices_of S is mutually-disjoint by TAXONOM2:def 5;
  end;
end;

registration
  let S be edge-disjoint Graph-membered set;
  cluster the_Edges_of S -> mutually-disjoint;
  coherence
  proof
    now
      let x,y be set;
      assume x in the_Edges_of S;
      then consider G being _Graph such that
        A1: G in S & x = the_Edges_of G by GLIB_014:def 15;
      assume y in the_Edges_of S;
      then consider H being _Graph such that
        A2: H in S & y = the_Edges_of H by GLIB_014:def 15;
      assume x <> y;
      then H <> G by A1, A2;
      hence x misses y by A1, A2, Def19;
    end;
    hence the_Edges_of S is mutually-disjoint by TAXONOM2:def 5;
  end;
end;

registration
  let S be vertex-disjoint Graph-membered set;
  cluster -> vertex-disjoint for Subset of S;
  coherence by Def18;
end;

registration
  let S1 be vertex-disjoint Graph-membered set;
  let S2 be set;
  cluster S1 /\ S2 -> vertex-disjoint;
  coherence
  proof
    S1 /\ S2 c= S1 by XBOOLE_1:17;
    hence thesis;
  end;
  cluster S1 \ S2 -> vertex-disjoint;
  coherence;
end;

registration
  let S be edge-disjoint Graph-membered set;
  cluster -> edge-disjoint for Subset of S;
  coherence by Def19;
end;

registration
  let S1 be edge-disjoint Graph-membered set;
  let S2 be set;
  cluster S1 /\ S2 -> edge-disjoint;
  coherence
  proof
    S1 /\ S2 c= S1 by XBOOLE_1:17;
    hence thesis;
  end;
  cluster S1 \ S2 -> edge-disjoint;
  coherence;
end;

theorem
  for S1, S2 being Graph-membered set st S1 \/ S2 is vertex-disjoint
  holds S1 is vertex-disjoint & S2 is vertex-disjoint
proof
  let S1, S2 be Graph-membered set;
  assume A1: S1 \/ S2 is vertex-disjoint;
  hereby
    let G1, G2 be _Graph;
    assume G1 in S1 & G2 in S1 & G1 <> G2;
    then G1 in S1 \/ S2 & G2 in S1 \/ S2 & G1 <> G2 by XBOOLE_0:def 3;
    hence the_Vertices_of G1 misses the_Vertices_of G2 by A1;
  end;
  let G1, G2 be _Graph;
  assume G1 in S2 & G2 in S2 & G1 <> G2;
  then G1 in S1 \/ S2 & G2 in S1 \/ S2 & G1 <> G2 by XBOOLE_0:def 3;
  hence the_Vertices_of G1 misses the_Vertices_of G2 by A1;
end;

theorem
  for S1, S2 being Graph-membered set st S1 \/ S2 is edge-disjoint
  holds S1 is edge-disjoint & S2 is edge-disjoint
proof
  let S1, S2 be Graph-membered set;
  assume A1: S1 \/ S2 is edge-disjoint;
  hereby
    let G1, G2 be _Graph;
    assume G1 in S1 & G2 in S1 & G1 <> G2;
    then G1 in S1 \/ S2 & G2 in S1 \/ S2 & G1 <> G2 by XBOOLE_0:def 3;
    hence the_Edges_of G1 misses the_Edges_of G2 by A1;
  end;
  let G1, G2 be _Graph;
  assume G1 in S2 & G2 in S2 & G1 <> G2;
  then G1 in S1 \/ S2 & G2 in S1 \/ S2 & G1 <> G2 by XBOOLE_0:def 3;
  hence the_Edges_of G1 misses the_Edges_of G2 by A1;
end;

theorem Th55:
  for S1, S2 being vertex-disjoint GraphUnionSet
  for G1 being (GraphUnion of S1), G2 being GraphUnion of S2
  st S1,S2 are_Disomorphic holds G2 is G1-Disomorphic
proof
  let S1, S2 be vertex-disjoint GraphUnionSet, G1 be GraphUnion of S1;
  let G2 be GraphUnion of S2;
  assume S1,S2 are_Disomorphic;
  :: first get a function that associates each graph of S1 with an Disomorphism
  then consider h being one-to-one Function such that
    A1: dom h = S1 & rng h = S2 and
    A2: for G being _Graph st G in S1 holds h.G is G-Disomorphic _Graph;
  h is S1-defined by A1, RELAT_1:def 18;
  then reconsider h as ManySortedSet of S1 by A1, PARTFUN1:def 2;
  for x being object st x in dom h holds h.x is _Graph by A2;
  then reconsider h as Graph-yielding ManySortedSet of S1 by GLIB_000:def 53;
  defpred P0[object,object] means
    ex G being Element of S1, F being PGraphMapping of G, h.G
    st $1 = G & $2 = F & F is Disomorphism;
  A3: for G being Element of S1 ex F being object st P0[G,F]
  proof
    let G be Element of S1;
    h.G is G-Disomorphic by A2;
    then consider F being PGraphMapping of G, h.G such that
      A4: F is Disomorphism by GLIB_010:def 24;
    take F,G,F;
    thus thesis by A4;
  end;
  consider H being ManySortedSet of S1 such that
    A5: for G being Element of S1 holds P0[G,H.G] from PBOOLE:sch 6(A3);
  A6: for G being Element of S1 ex F being PGraphMapping of G, h.G st
    H.G = F & F is Disomorphism
  proof
    let G be Element of S1;
    consider G9 being Element of S1, F being PGraphMapping of G9, h.G9
      such that A7: G = G9 & H.G = F & F is Disomorphism by A5;
    thus thesis by A7;
  end;
  :: construct the vertex and edge mappings
  set V = rng pr1 H, E = rng pr2 H;
  for y being object st y in V holds y is Function
  proof
    let y be object;
    assume y in V;
    then consider x being object such that
      A8: x in dom pr1 H & (pr1 H).x = y by FUNCT_1:def 3;
    A9: x in dom H by A8, MCART_1:def 12;
    then reconsider x as Element of S1;
    consider F being PGraphMapping of x, h.x such that
      A10: H.x = F & F is Disomorphism by A6;
    y = F_V by A8, A9, A10, MCART_1:def 12;
    hence thesis;
  end;
  then reconsider V as functional set by FUNCT_1:def 13;
  for f1, f2 being Function st f1 in V & f2 in V holds f1 tolerates f2
  proof
    let f1, f2 be Function;
    assume A11: f1 in V & f2 in V;
    then consider x1 being object such that
      A12: x1 in dom pr1 H & (pr1 H).x1 = f1 by FUNCT_1:def 3;
    A13: x1 in dom H by A12, MCART_1:def 12;
    then reconsider x1 as Element of S1;
    consider F1 being PGraphMapping of x1, h.x1 such that
      A14: H.x1 = F1 & F1 is Disomorphism by A6;
    A15: f1 = F1_V by A12, A13, A14, MCART_1:def 12;
    then A16: dom f1 = the_Vertices_of x1 by A14, GLIB_010:def 11;
    consider x2 being object such that
      A17: x2 in dom pr1 H & (pr1 H).x2 = f2 by A11, FUNCT_1:def 3;
    A18: x2 in dom H by A17, MCART_1:def 12;
    then reconsider x2 as Element of S1;
    consider F2 being PGraphMapping of x2, h.x2 such that
      A19: H.x2 = F2 & F2 is Disomorphism by A6;
    A20: f2 = F2_V by A17, A18, A19, MCART_1:def 12;
    then A21: dom f2 = the_Vertices_of x2 by A19, GLIB_010:def 11;
    per cases;
    suppose x1 = x2;
      then F1 = F2 by A14, A19;
      hence thesis by A15, A20;
    end;
    suppose x1 <> x2;
      then dom f1 misses dom f2 by A16, A21, Def18;
      hence thesis by PARTFUN1:56;
    end;
  end;
  then reconsider V as functional compatible set by COMPUT_1:def 1;
  for y being object st y in E holds y is Function
  proof
    let y be object;
    assume y in E;
    then consider x being object such that
      A22: x in dom pr2 H & (pr2 H).x = y by FUNCT_1:def 3;
    A23: x in dom H by A22, MCART_1:def 13;
    then reconsider x as Element of S1;
    consider F being PGraphMapping of x, h.x such that
      A24: H.x = F & F is Disomorphism by A6;
    y = F_E by A22, A23, A24, MCART_1:def 13;
    hence thesis;
  end;
  then reconsider E as functional set by FUNCT_1:def 13;
  for g1, g2 being Function st g1 in E & g2 in E holds g1 tolerates g2
  proof
    let f1, f2 be Function;
    assume A25: f1 in E & f2 in E;
    then consider x1 being object such that
      A26: x1 in dom pr2 H & (pr2 H).x1 = f1 by FUNCT_1:def 3;
    A27: x1 in dom H by A26, MCART_1:def 13;
    then reconsider x1 as Element of S1;
    consider F1 being PGraphMapping of x1, h.x1 such that
      A28: H.x1 = F1 & F1 is Disomorphism by A6;
    A29: f1 = F1_E by A26, A27, A28, MCART_1:def 13;
    then A30: dom f1 = the_Edges_of x1 by A28, GLIB_010:def 11;
    consider x2 being object such that
      A31: x2 in dom pr2 H & (pr2 H).x2 = f2 by A25, FUNCT_1:def 3;
    A32: x2 in dom H by A31, MCART_1:def 13;
    then reconsider x2 as Element of S1;
    consider F2 being PGraphMapping of x2, h.x2 such that
      A33: H.x2 = F2 & F2 is Disomorphism by A6;
    A34: f2 = F2_E by A31, A32, A33, MCART_1:def 13;
    then A35: dom f2 = the_Edges_of x2 by A33, GLIB_010:def 11;
    per cases;
    suppose x1 = x2;
      then F1 = F2 by A28, A33;
      hence thesis by A29, A34;
    end;
    suppose x1 <> x2;
      then dom f1 misses dom f2 by A30, A35, Def19;
      hence thesis by PARTFUN1:56;
    end;
  end;
  then reconsider E as functional compatible set by COMPUT_1:def 1;
  set f = union V, g = union E;
  :: show that dom f = V(G1)
  now
    let x be object;
    hereby
      assume x in dom union V;
      then [x,(union V).x] in union V by FUNCT_1:1;
      then consider y being set such that
        A36: [x,(union V).x] in y & y in V by TARSKI:def 4;
      consider z being object such that
        A37: z in dom pr1 H & (pr1 H).z = y by A36, FUNCT_1:def 3;
      A38: z in dom H by A37, MCART_1:def 12;
      then reconsider z as Element of S1;
      take Y = the_Vertices_of z;
      consider F being PGraphMapping of z,h.z such that
        A39: H.z = F & F is Disomorphism by A6;
      y = F_V by A37, A38, A39, MCART_1:def 12;
      then x in dom F_V by A36, FUNCT_1:1;
      hence x in Y;
      thus Y in the_Vertices_of S1 by GLIB_014:def 14;
    end;
    given Y being set such that
      A40: x in Y & Y in the_Vertices_of S1;
    consider z being _Graph such that
      A41: z in S1 & Y = the_Vertices_of z by A40, GLIB_014:def 14;
    reconsider z as Element of S1 by A41;
    consider F being PGraphMapping of z,h.z such that
      A42: H.z = F & F is Disomorphism by A6;
    A43: z in dom H by A41, PARTFUN1:def 2;
    x in dom F_V by A40, A41, A42, GLIB_010:def 11;
    then [x,F_V.x] in F_V by FUNCT_1:1;
    then A44: [x,F_V.x] in (pr1 H).z by A42, A43, MCART_1:def 12;
    z in dom pr1 H by A43, MCART_1:def 12;
    then (pr1 H).z in rng pr1 H by FUNCT_1:3;
    then [x,F_V.x] in union V by A44, TARSKI:def 4; :: V = rng pr1 H
    hence x in dom union V by FUNCT_1:1;
  end;
  then A45: dom f = union the_Vertices_of S1 by TARSKI:def 4
    .= the_Vertices_of G1 by GLIB_014:def 25;
  :: show that rng f = V(G2)
  now
    let y be object;
    hereby
      assume y in rng union V;
      then consider x being object such that
        A46: x in dom union V & (union V).x = y by FUNCT_1:def 3;
      [x,y] in union V by A46, FUNCT_1:1;
      then consider Z being set such that
        A47: [x,y] in Z & Z in V by TARSKI:def 4;
      consider z being object such that
        A48: z in dom pr1 H & (pr1 H).z = Z by A47, FUNCT_1:def 3;
      A49: z in dom H by A48, MCART_1:def 12;
      then reconsider z as Element of S1;
      h.z in rng h by A1, FUNCT_1:3;
      then reconsider G = h.z as Element of S2 by A1;
      consider F being PGraphMapping of z,G such that
        A50: H.z = F & F is Disomorphism by A6;
      take Y = the_Vertices_of G;
      Z = F_V by A48, A49, A50, MCART_1:def 12;
      then y in rng F_V by A47, XTUPLE_0:def 13;
      hence y in Y;
      thus Y in the_Vertices_of S2 by GLIB_014:def 14;
    end;
    given Y being set such that
      A51: y in Y & Y in the_Vertices_of S2;
    consider G being _Graph such that
      A52: G in S2 & Y = the_Vertices_of G by A51, GLIB_014:def 14;
    consider z being object such that
      A53: z in dom h & h.z = G by A1, A52, FUNCT_1:def 3;
    reconsider z as Element of S1 by A53;
    consider F being PGraphMapping of z,G such that
      A54: H.z = F & F is Disomorphism by A6, A53;
    y in rng F_V by A51, A52, A54, GLIB_010:def 12;
    then consider x being object such that
      A55: x in dom F_V & F_V.x = y by FUNCT_1:def 3;
    z in S1;
    then A56: z in dom H by PARTFUN1:def 2;
    A57: F_V = (pr1 H).z by A54, A56, MCART_1:def 12;
    z in dom pr1 H by A56, MCART_1:def 12;
    then A58: (pr1 H).z in rng pr1 H by FUNCT_1:3;
    [x,y] in (pr1 H).z by A55, A57, FUNCT_1:1;
    then [x,y] in union V by A58, TARSKI:def 4; :: V = rng pr1 H
    hence y in rng union V by XTUPLE_0:def 13;
  end;
  then A59: rng f = union the_Vertices_of S2 by TARSKI:def 4
    .= the_Vertices_of G2 by GLIB_014:def 25;
  then reconsider f as Function of the_Vertices_of G1, the_Vertices_of G2
    by A45, FUNCT_2:1;
  :: show that dom g = E(G1)
  now
    let x be object;
    hereby
      assume x in dom union E;
      then [x,(union E).x] in union E by FUNCT_1:1;
      then consider y being set such that
        A60: [x,(union E).x] in y & y in E by TARSKI:def 4;
      consider z being object such that
        A61: z in dom pr2 H & (pr2 H).z = y by A60, FUNCT_1:def 3;
      A62: z in dom H by A61, MCART_1:def 13;
      then reconsider z as Element of S1;
      take Y = the_Edges_of z;
      consider F being PGraphMapping of z,h.z such that
        A63: H.z = F & F is Disomorphism by A6;
      y = F_E by A61, A62, A63, MCART_1:def 13;
      then x in dom F_E by A60, FUNCT_1:1;
      hence x in Y;
      thus Y in the_Edges_of S1 by GLIB_014:def 15;
    end;
    given Y being set such that
      A64: x in Y & Y in the_Edges_of S1;
    consider z being _Graph such that
      A65: z in S1 & Y = the_Edges_of z by A64, GLIB_014:def 15;
    reconsider z as Element of S1 by A65;
    consider F being PGraphMapping of z,h.z such that
      A66: H.z = F & F is Disomorphism by A6;
    A67: z in dom H by A65, PARTFUN1:def 2;
    x in dom F_E by A64, A65, A66, GLIB_010:def 11;
    then [x,F_E.x] in F_E by FUNCT_1:1;
    then A68: [x,F_E.x] in (pr2 H).z by A66, A67, MCART_1:def 13;
    z in dom pr2 H by A67, MCART_1:def 13;
    then (pr2 H).z in rng pr2 H by FUNCT_1:3;
    then [x,F_E.x] in union E by A68, TARSKI:def 4; :: E = rng pr2 H
    hence x in dom union E by FUNCT_1:1;
  end;
  then A69: dom g = union the_Edges_of S1 by TARSKI:def 4
    .= the_Edges_of G1 by GLIB_014:def 25;
  :: show that rng g = E(G2)
  now
    let y be object;
    hereby
      assume y in rng union E;
      then consider x being object such that
        A70: x in dom union E & (union E).x = y by FUNCT_1:def 3;
      [x,y] in union E by A70, FUNCT_1:1;
      then consider Z being set such that
        A71: [x,y] in Z & Z in E by TARSKI:def 4;
      consider z being object such that
        A72: z in dom pr2 H & (pr2 H).z = Z by A71, FUNCT_1:def 3;
      A73: z in dom H by A72, MCART_1:def 13;
      then reconsider z as Element of S1;
      h.z in rng h by A1, FUNCT_1:3;
      then reconsider G = h.z as Element of S2 by A1;
      consider F being PGraphMapping of z,G such that
        A74: H.z = F & F is Disomorphism by A6;
      take Y = the_Edges_of G;
      Z = F_E by A72, A73, A74, MCART_1:def 13;
      then y in rng F_E by A71, XTUPLE_0:def 13;
      hence y in Y;
      thus Y in the_Edges_of S2 by GLIB_014:def 15;
    end;
    given Y being set such that
      A75: y in Y & Y in the_Edges_of S2;
    consider G being _Graph such that
      A76: G in S2 & Y = the_Edges_of G by A75, GLIB_014:def 15;
    consider z being object such that
      A77: z in dom h & h.z = G by A1, A76, FUNCT_1:def 3;
    reconsider z as Element of S1 by A77;
    consider F being PGraphMapping of z,G such that
      A78: H.z = F & F is Disomorphism by A6, A77;
    y in rng F_E by A75, A76, A78, GLIB_010:def 12;
    then consider x being object such that
      A79: x in dom F_E & F_E.x = y by FUNCT_1:def 3;
    z in S1;
    then A80: z in dom H by PARTFUN1:def 2;
    A81: F_E = (pr2 H).z by A78, A80, MCART_1:def 13;
    z in dom pr2 H by A80, MCART_1:def 13;
    then A82: (pr2 H).z in rng pr2 H by FUNCT_1:3;
    [x,y] in (pr2 H).z by A79, A81, FUNCT_1:1;
    then [x,y] in union E by A82, TARSKI:def 4; :: E = rng pr2 H
    hence y in rng union E by XTUPLE_0:def 13;
  end;
  then A83: rng g = union the_Edges_of S2 by TARSKI:def 4
    .= the_Edges_of G2 by GLIB_014:def 25;
  then reconsider g as Function of the_Edges_of G1, the_Edges_of G2
    by A69, FUNCT_2:1;
  :: show f is one-to-one
  now
    let f1 be Function;
    assume f1 in V;
    then consider z1 being object such that
      A84: z1 in dom pr1 H & (pr1 H).z1 = f1 by FUNCT_1:def 3;
    A85: z1 in dom H by A84, MCART_1:def 12;
    then reconsider z1 as Element of S1;
    consider F1 being PGraphMapping of z1,h.z1 such that
      A86: H.z1 = F1 & F1 is Disomorphism by A6;
    A87: f1 = F1_V by A84, A85, A86, MCART_1:def 12;
    hence f1 is one-to-one by A86;
    let f2 be Function;
    assume A88: f2 in V & f1 <> f2;
    then consider z2 being object such that
      A89: z2 in dom pr1 H & (pr1 H).z2 = f2 by FUNCT_1:def 3;
    A90: z2 in dom H by A89, MCART_1:def 12;
    then reconsider z2 as Element of S1;
    consider F2 being PGraphMapping of z2,h.z2 such that
      A91: H.z2 = F2 & F2 is Disomorphism by A6;
    A92: f2 = F2_V by A89, A90, A91, MCART_1:def 12;
    then z1 <> z2 by A86, A87, A88, A91;
    then A93: h.z1 <> h.z2 by A1, FUNCT_1:def 4;
    h.z1 in S2 & h.z2 in S2 by A1, FUNCT_1:3;
    then the_Vertices_of h.z1 misses the_Vertices_of h.z2 by A93, Def18;
    then rng F1_V misses the_Vertices_of h.z2 by A86, GLIB_010:def 12;
    hence rng f1 misses rng f2 by A87, A91, A92, GLIB_010:def 12;
  end;
  then A94: f is one-to-one by GLIBPRE1:16;
  :: show g is one-to-one
  now
    let g1 be Function;
    assume g1 in E;
    then consider z1 being object such that
      A95: z1 in dom pr2 H & (pr2 H).z1 = g1 by FUNCT_1:def 3;
    A96: z1 in dom H by A95, MCART_1:def 13;
    then reconsider z1 as Element of S1;
    consider F1 being PGraphMapping of z1,h.z1 such that
      A97: H.z1 = F1 & F1 is Disomorphism by A6;
    A98: g1 = F1_E by A95, A96, A97, MCART_1:def 13;
    hence g1 is one-to-one by A97;
    let g2 be Function;
    assume A99: g2 in E & g1 <> g2;
    then consider z2 being object such that
      A100: z2 in dom pr2 H & (pr2 H).z2 = g2 by FUNCT_1:def 3;
    A101: z2 in dom H by A100, MCART_1:def 13;
    then reconsider z2 as Element of S1;
    consider F2 being PGraphMapping of z2,h.z2 such that
      A102: H.z2 = F2 & F2 is Disomorphism by A6;
    A103: g2 = F2_E by A100, A101, A102, MCART_1:def 13;
    then z1 <> z2 by A97, A98, A99, A102;
    then A104: h.z1 <> h.z2 by A1, FUNCT_1:def 4;
    h.z1 in S2 & h.z2 in S2 by A1, FUNCT_1:3;
    then the_Edges_of h.z1 misses the_Edges_of h.z2 by A104, Def19;
    then rng F1_E misses the_Edges_of h.z2 by A97, GLIB_010:def 12;
    hence rng g1 misses rng g2 by A98, A102, A103, GLIB_010:def 12;
  end;
  then A105: g is one-to-one by GLIBPRE1:16;
  :: verify the Disomorphism
  now
    hereby
      let e be object;
      assume e in dom g;
      then [e,g.e] in g by FUNCT_1:1;
      then consider Y being set such that
        A106: [e,g.e] in Y & Y in E by TARSKI:def 4;
      consider z being object such that
        A107: z in dom pr2 H & (pr2 H).z = Y by A106, FUNCT_1:def 3;
      A108: z in dom H by A107, MCART_1:def 13;
      then reconsider z as Element of S1;
      consider F being PGraphMapping of z,h.z such that
        A109: H.z = F & F is Disomorphism by A6;
      Y = F_E by A107, A108, A109, MCART_1:def 13;
      then A110: e in dom F_E by A106, FUNCT_1:1;
      then A111: (the_Source_of z).e in dom F_V &
        (the_Target_of z).e in dom F_V by GLIB_010:5;
      A112: e in the_Edges_of z & e is set by A110;
      set v = (the_Source_of G1).e, w = (the_Target_of G1).e;
      z is Subgraph of G1 by GLIB_014:21;
      then A113: v in dom F_V & w in dom F_V by A111, A112, GLIB_000:def 32;
      A114: F_V = (pr1 H).z by A108, A109, MCART_1:def 12;
      z in dom pr1 H by A108, MCART_1:def 12;
      then A115: F_V in V by A114, FUNCT_1:def 3; :: V = rng pr1 H
      [v,F_V.v] in F_V & [w,F_V.w] in F_V by A113, FUNCT_1:1;
      then [v,F_V.v] in f & [w,F_V.w] in f by A115, TARSKI:def 4;
      hence v in dom f & w in dom f by FUNCT_1:1;
    end;
    let e,v,w be object;
    assume e in dom g & v in dom f & w in dom f;
    assume e DJoins v,w,G1;
    then consider z being Element of S1 such that
      A116: e DJoins v,w,z by GLIBPRE1:116;
    consider F being PGraphMapping of z,h.z such that
      A117: H.z = F & F is Disomorphism by A6;
    e in the_Edges_of z by A116, GLIB_000:def 14;
    then A118: e in dom F_E by A117, GLIB_010:def 11;
    e Joins v,w,z by A116, GLIB_000:16;
    then v in the_Vertices_of z & w in the_Vertices_of z by GLIB_000:13;
    then A119: v in dom F_V & w in dom F_V by A117, GLIB_010:def 11;
    then A120: F_E.e DJoins F_V.v,F_V.w,h.z
      by A116, A117, A118, GLIB_010:def 14;
    h.z in S2 by A1, FUNCT_1:3;
    then A121: h.z is Subgraph of G2 by GLIB_014:21;
    A122: F_E.e DJoins F_V.v,F_V.w,G2 by A120, A121, GLIB_000:72;
    z in S1;
    then A123: z in dom H by PARTFUN1:def 2;
    then z in dom pr1 H by MCART_1:def 12;
    then A124: (pr1 H).z in V by FUNCT_1:3;
    z in dom pr2 H by A123, MCART_1:def 13;
    then A125: (pr2 H).z in E by FUNCT_1:3;
    F_V = (pr1 H).z by A117, A123, MCART_1:def 12;
    then A126: F_V.v = f.v & F_V.w = f.w by A119, A124, COMPUT_1:13;
    F_E = (pr2 H).z by A117, A123, MCART_1:def 13;
    then F_E.e = g.e by A118, A125, COMPUT_1:13;
    hence g.e DJoins f.v,f.w,G2 by A126, A122;
  end;
  then reconsider F = [f,g] as directed PGraphMapping of G1, G2
    by GLIB_010:30;
  F_V = f & F_E = g;
  then A127: F is one-to-one by A94, A105, GLIB_010:def 13;
  F_V = f & F_E = g;
  then F is total onto by A45, A59, A69, A83, GLIB_010:def 11, GLIB_010:def 12;
  hence thesis by A127, GLIB_010:def 24;
end;

theorem Th56:
  for S1, S2 being vertex-disjoint GraphUnionSet
  for G1 being (GraphUnion of S1), G2 being GraphUnion of S2
  st S1,S2 are_isomorphic
  ex S3 being vertex-disjoint GraphUnionSet, E being Subset of the_Edges_of G2,
    G3 being GraphUnion of S3
  st S1,S3 are_Disomorphic & G3 is reverseEdgeDirections of G2, E
proof
  let S1, S2 be vertex-disjoint GraphUnionSet;
  let G1 be (GraphUnion of S1), G2 be GraphUnion of S2;
  assume S1,S2 are_isomorphic;
  :: first get a function that associates each graph of S1 with an isomorphism
  then consider h being one-to-one Function such that
    A1: dom h = S1 & rng h = S2 and
    A2: for G being _Graph st G in S1 holds h.G is G-isomorphic _Graph;
  reconsider h as ManySortedSet of S1 by A1, RELAT_1:def 18, PARTFUN1:def 2;
  for x being object st x in dom h holds h.x is _Graph by A2;
  then reconsider h as Graph-yielding ManySortedSet of S1 by GLIB_000:def 53;
  defpred P0[object,object] means
    ex G being Element of S1, F being PGraphMapping of G, h.G
    st $1 = G & $2 = F & F is isomorphism;
  A3: for G being Element of S1 ex F being object st P0[G,F]
  proof
    let G be Element of S1;
    h.G is G-isomorphic by A2;
    then consider F being PGraphMapping of G, h.G such that
      A4: F is isomorphism by GLIB_010:def 23;
    take F,G,F;
    thus thesis by A4;
  end;
  consider H being ManySortedSet of S1 such that
    A5: for G being Element of S1 holds P0[G,H.G] from PBOOLE:sch 6(A3);
  A6: for G being Element of S1 ex F being PGraphMapping of G, h.G st
    H.G = F & F is isomorphism
  proof
    let G be Element of S1;
    consider G9 being Element of S1, F being PGraphMapping of G9, h.G9
      such that A7: G = G9 & H.G = F & F is isomorphism by A5;
    thus thesis by A7;
  end;
  :: associate every graph with the set of edges to be changed
  defpred P1[object,object] means
    ex G being Element of S1, E being Subset of the_Edges_of h.G
    st $1 = G & $2 = E & for G9 being reverseEdgeDirections of h.G, E
    ex F being PGraphMapping of G,G9 st F = H.G & F is Disomorphism;
  A8: for G being Element of S1 ex E being object st P1[G,E]
  proof
    let G be Element of S1;
    consider F0 being PGraphMapping of G, h.G such that
      A9: H.G = F0 & F0 is isomorphism by A6;
    F0_E is one-to-one by A9;
    then consider E being Subset of the_Edges_of h.G such that
      A10: for G9 being reverseEdgeDirections of h.G, E
        ex F being PGraphMapping of G, G9 st F = F0 & F is directed &
          (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
          (F0 is strong_SG-embedding implies F is strong_SG-embedding) &
          (F0 is isomorphism implies F is isomorphism) by GLIBPRE0:89;
    take E,G,E;
    thus G = G & E = E;
    let G9 be reverseEdgeDirections of h.G, E;
    consider F being PGraphMapping of G, G9 such that
      A11: F = F0 & F is directed and
      (F0 is weak_SG-embedding implies F is weak_SG-embedding) &
      (F0 is strong_SG-embedding implies F is strong_SG-embedding) and
      A12: F0 is isomorphism implies F is isomorphism by A10;
    take F;
    thus thesis by A9, A11, A12;
  end;
  consider A being ManySortedSet of S1 such that
    A13: for G being Element of S1 holds P1[G,A.G] from PBOOLE:sch 6(A8);
  A14: for G being Element of S1 holds A.G is Subset of the_Edges_of h.G
  proof
    let G be Element of S1;
    consider G0 being Element of S1, E0 being Subset of the_Edges_of h.G0
      such that A15: G = G0 & A.G = E0 and
      for G9 being reverseEdgeDirections of h.G0, E0
      ex F being PGraphMapping of G0,G9 st F = H.G0 & F is Disomorphism by A13;
    thus thesis by A15;
  end;
  A16: for G being Element of S1, G9 being reverseEdgeDirections of h.G, A.G
    ex F being PGraphMapping of G,G9 st F = H.G & F is Disomorphism
  proof
    let G be Element of S1;
    consider G0 being Element of S1, E0 being Subset of the_Edges_of h.G0
      such that A17: G = G0 & A.G = E0 and
      A18: for G9 being reverseEdgeDirections of h.G0, E0
      ex F being PGraphMapping of G0,G9 st F = H.G0 & F is Disomorphism by A13;
    thus thesis by A17, A18;
  end;
  :: associate every graph with a graph with the appropriate edges reversed
  deffunc P2(Element of S1) = the reverseEdgeDirections of h.$1, A.$1;
  consider B being ManySortedSet of S1 such that
    A19: for G being Element of S1 holds B.G = P2(G) from PBOOLE:sch 5;
  now
    let x be object;
    assume x in dom B;
    then reconsider G = x as Element of S1;
    B.G = the reverseEdgeDirections of h.G, A.G by A19;
    hence B.x is _Graph;
  end;
  then reconsider B as Graph-yielding ManySortedSet of S1 by GLIB_000:def 53;
  :: rng B is the needed set S3, confirm properties
  now
    let x1, x2 be object;
    assume A20: x1 in dom B & x2 in dom B & B.x1 = B.x2;
    then reconsider H1 = x1 as Element of S1;
    reconsider H2 = x2 as Element of S1 by A20;
    H1 in S1 & H2 in S1;
    then A21: x1 in dom h & x2 in dom h by A1;
    then A22: h.x1 in S2 & h.x2 in S2 by A1, FUNCT_1:3;
    B.H1 = the reverseEdgeDirections of h.H1, A.H1 by A19;
    then A23: the_Vertices_of B.H1 = the_Vertices_of h.H1 by GLIB_007:4;
    B.H2 = the reverseEdgeDirections of h.H2, A.H2 by A19;
    then the_Vertices_of h.H1 = the_Vertices_of h.H2 by A20, A23, GLIB_007:4;
    hence x1 = x2 by A21, A22, Def18, FUNCT_1:def 4;
  end;
  then A24: B is one-to-one by FUNCT_1:def 4;
  now
    let H3, H4 be _Graph;
    assume A25: H3 in rng B & H4 in rng B & H3 <> H4;
    then consider H1 being object such that
      A26: H1 in dom B & B.H1 = H3 by FUNCT_1:def 3;
    consider H2 being object such that
      A27: H2 in dom B & B.H2 = H4 by A25, FUNCT_1:def 3;
    reconsider H1, H2 as Element of S1 by A26, A27;
    B.H1 = the reverseEdgeDirections of h.H1, A.H1 by A19;
    then A28: the_Vertices_of B.H1 = the_Vertices_of h.H1 by GLIB_007:4;
    B.H2 = the reverseEdgeDirections of h.H2, A.H2 by A19;
    then A29: the_Vertices_of B.H2 = the_Vertices_of h.H2 by GLIB_007:4;
    A30: h.H1 in S2 & h.H2 in S2 by A1, FUNCT_1:3;
    H1 <> H2 by A25, A26, A27;
    then h.H1 <> h.H2 by A1, FUNCT_1:def 4;
    then the_Vertices_of h.H1 misses the_Vertices_of h.H2 by A30, Def18;
    hence the_Vertices_of H3 misses the_Vertices_of H4 by A26, A27, A28, A29;
  end;
  then A31: rng B is vertex-disjoint;
  now
    let H3, H4 be _Graph;
    assume A32: H3 in rng B & H4 in rng B & H3 <> H4;
    then consider H1 being object such that
      A33: H1 in dom B & B.H1 = H3 by FUNCT_1:def 3;
    consider H2 being object such that
      A34: H2 in dom B & B.H2 = H4 by A32, FUNCT_1:def 3;
    reconsider H1, H2 as Element of S1 by A33, A34;
    B.H1 = the reverseEdgeDirections of h.H1, A.H1 by A19;
    then A35: the_Edges_of B.H1 = the_Edges_of h.H1 by GLIB_007:4;
    B.H2 = the reverseEdgeDirections of h.H2, A.H2 by A19;
    then A36: the_Edges_of B.H2 = the_Edges_of h.H2 by GLIB_007:4;
    A37: h.H1 in S2 & h.H2 in S2 by A1, FUNCT_1:3;
    H1 <> H2 by A32, A33, A34;
    then h.H1 <> h.H2 by A1, FUNCT_1:def 4;
    then the_Edges_of h.H1 misses the_Edges_of h.H2 by A37, Def19;
    hence the_Edges_of H3 misses the_Edges_of H4 by A33, A34, A35, A36;
  end;
  then A38: rng B is edge-disjoint;
  dom B = S1 by PARTFUN1:def 2;
  then B is non empty;
  then reconsider S3 = rng B as vertex-disjoint GraphUnionSet by A31, A38;
  for y being object st y in union rng A holds y in the_Edges_of G2
  proof
    let y be object;
    assume y in union rng A;
    then consider Y being set such that
      A39: y in Y & Y in rng A by TARSKI:def 4;
    consider x being object such that
      A40: x in dom A & A.x = Y by A39, FUNCT_1:def 3;
    reconsider x as Element of S1 by A40;
    consider G0 being Element of S1, E0 being Subset of the_Edges_of h.G0
      such that A41: x = G0 & A.x = E0 and
      for G9 being reverseEdgeDirections of h.G0, E0
      ex F being PGraphMapping of G0,G9 st F = H.G0 & F is Disomorphism by A13;
    y in E0 by A39, A40, A41;
    then A42: y in the_Edges_of h.x by A41;
    h.x in S2 by A1, FUNCT_1:3;
    then h.x is Subgraph of G2 by GLIB_014:21;
    then the_Edges_of h.x c= the_Edges_of G2 by GLIB_000:def 32;
    hence thesis by A42;
  end;
  then reconsider E = union rng A as Subset of the_Edges_of G2 by TARSKI:def 3;
  take S3, E, G3 = the GraphUnion of S3;
  now
    reconsider f = B as one-to-one Function by A24;
    take f;
    thus dom f = S1 & rng f = S3 by PARTFUN1:def 2;
    let G be _Graph;
    assume G in S1;
    then reconsider G0 = G as Element of S1;
    B.G0 = the reverseEdgeDirections of h.G0, A.G0 by A19;
    then consider F being PGraphMapping of G,B.G0 such that
      A43: F = H.G0 & F is Disomorphism by A16;
    thus f.G is G-Disomorphic _Graph by A43, GLIB_010:def 24;
  end;
  hence S1, S3 are_Disomorphic;
  :: reverseEdgeDirections properties
  now
    now
      let x be object;
      hereby
        assume x in the_Vertices_of S2;
        then consider G being _Graph such that
          A44: G in S2 & x = the_Vertices_of G by GLIB_014:def 14;
        consider z being object such that
          A45: z in dom h & h.z = G by A1, A44, FUNCT_1:def 3;
        reconsider z as Element of S1 by A45;
        z in dom B by A1, A45, PARTFUN1:def 2;
        then A46: B.z in rng B by FUNCT_1:3;
        B.z = the reverseEdgeDirections of h.z, A.z by A19;
        then the_Vertices_of B.z = x by A44, A45, GLIB_007:4;
        hence x in the_Vertices_of rng B by A46, GLIB_014:def 14;
      end;
      assume x in the_Vertices_of rng B;
      then consider G being _Graph such that
        A47: G in rng B & x = the_Vertices_of G by GLIB_014:def 14;
      consider z being object such that
        A48: z in dom B & B.z = G by A47, FUNCT_1:def 3;
      reconsider z as Element of S1 by A48;
      A49: h.z in S2 by A1, FUNCT_1:3;
      B.z = the reverseEdgeDirections of h.z, A.z by A19;
      then the_Vertices_of h.z = x by A47, A48, GLIB_007:4;
      hence x in the_Vertices_of S2 by A49, GLIB_014:def 14;
    end;
    then A50: the_Vertices_of S2 = the_Vertices_of rng B by TARSKI:2;
    thus the_Vertices_of G3 = union the_Vertices_of rng B
        by GLIB_014:def 25
      .= the_Vertices_of G2 by A50, GLIB_014:def 25;
    now
      let x be object;
      hereby
        assume x in the_Edges_of S2;
        then consider G being _Graph such that
          A51: G in S2 & x = the_Edges_of G by GLIB_014:def 15;
        consider z being object such that
          A52: z in dom h & h.z = G by A1, A51, FUNCT_1:def 3;
        reconsider z as Element of S1 by A52;
        z in dom B by A1, A52, PARTFUN1:def 2;
        then A53: B.z in rng B by FUNCT_1:3;
        B.z = the reverseEdgeDirections of h.z, A.z by A19;
        then the_Edges_of B.z = x by A51, A52, GLIB_007:4;
        hence x in the_Edges_of rng B by A53, GLIB_014:def 15;
      end;
      assume x in the_Edges_of rng B;
      then consider G being _Graph such that
        A54: G in rng B & x = the_Edges_of G by GLIB_014:def 15;
      consider z being object such that
        A55: z in dom B & B.z = G by A54, FUNCT_1:def 3;
      reconsider z as Element of S1 by A55;
      A56: h.z in S2 by A1, FUNCT_1:3;
      B.z = the reverseEdgeDirections of h.z, A.z by A19;
      then the_Edges_of h.z = x by A54, A55, GLIB_007:4;
      hence x in the_Edges_of S2 by A56, GLIB_014:def 15;
    end;
    then A57: the_Edges_of S2 = the_Edges_of rng B by TARSKI:2;
    thus A58: the_Edges_of G3 = union the_Edges_of rng B by GLIB_014:def 25
      .= the_Edges_of G2 by A57, GLIB_014:def 25;
    A59: dom the_Source_of G3 = the_Edges_of G3 by FUNCT_2:def 1
      .= the_Edges_of G2 \/ (the_Edges_of G2 /\ E) by A58, XBOOLE_1:22
      .= dom the_Source_of G2 \/ (the_Edges_of G2 /\ E) by FUNCT_2:def 1
      .= dom the_Source_of G2 \/ (dom the_Target_of G2 /\ E) by FUNCT_2:def 1
      .= dom the_Source_of G2 \/ (dom((the_Target_of G2)|E)) by RELAT_1:61
      .= dom(the_Source_of G2 +* ((the_Target_of G2) | E)) by FUNCT_4:def 1;
    now
      let x be object;
      assume x in dom the_Source_of G3;
      then x in the_Edges_of G3;
      then x in union the_Edges_of rng B by GLIB_014:def 25;
      then consider X be set such that
        A60: x in X & X in the_Edges_of rng B by TARSKI:def 4;
      consider G being _Graph such that
        A61: G in rng B & X = the_Edges_of G by A60, GLIB_014:def 15;
      consider z being object such that
        A62: z in dom B & B.z = G by A61, FUNCT_1:def 3;
      reconsider z as Element of S1 by A62;
      A63: z in dom h by A1;
      A64: h.z in S2 by A1, FUNCT_1:3;
      B.z in rng B by A62, FUNCT_1:3;
      then A65: the_Source_of B.z in the_Source_of rng B by GLIB_014:def 16;
      A66: B.z = the reverseEdgeDirections of h.z, A.z by A19;
      A67: A.z is Subset of the_Edges_of h.z by A14;
      A68: the_Source_of h.z in the_Source_of S2 by A64, GLIB_014:def 16;
      A69: the_Target_of h.z in the_Target_of S2 by A64, GLIB_014:def 17;
      A70: x in dom the_Source_of B.z by A60, A61, A62, FUNCT_2:def 1;
      A71: the_Edges_of B.z = the_Edges_of h.z by A66, GLIB_007:4;
      then A72: x in dom the_Source_of h.z by A60, A61, A62, FUNCT_2:def 1;
      A73: x in dom the_Target_of h.z by A60, A61, A62, A71, FUNCT_2:def 1;
      per cases;
      suppose A74: not x in A.z;
        then not x in the_Edges_of h.z /\ A.z by TARSKI:def 3, XBOOLE_1:17;
        then not x in dom the_Target_of h.z /\ A.z by FUNCT_2:def 1;
        then A75: not x in dom((the_Target_of h.z) | (A.z)) by RELAT_1:61;
        not x in E
        proof
          assume x in E;
          then consider Y being set such that
            A76: x in Y & Y in rng A by TARSKI:def 4;
          consider z9 being object such that
            A77: z9 in dom A & A.z9 = Y by A76, FUNCT_1:def 3;
          reconsider z9 as Element of S1 by A77;
          A78: x in A.z9 by A76, A77;
          A.z9 is Subset of the_Edges_of h.z9 by A14;
          then A79: x in the_Edges_of h.z9 by A78;
          A80: z9 in dom h by A1;
          A81: h.z9 in S2 by A1, FUNCT_1:3;
          the_Edges_of h.z = the_Edges_of G by A62, A66, GLIB_007:4;
          then x in the_Edges_of h.z by A60, A61;
          then the_Edges_of h.z meets the_Edges_of h.z9 by A79, XBOOLE_0:3;
          then z = z9 by A63, A64, A80, A81, Def19, FUNCT_1:def 4;
          hence contradiction by A74, A78;
        end;
        then not x in the_Edges_of G2 /\ E by TARSKI:def 3, XBOOLE_1:17;
        then not x in dom the_Target_of G2 /\ E by FUNCT_2:def 1;
        then A82: not x in dom((the_Target_of G2) | E) by RELAT_1:61;
        thus (the_Source_of G3).x
           = (union the_Source_of S3).x by GLIB_014:def 25
          .= (the_Source_of B.z).x by A65, A70, COMPUT_1:13
          .= ((the_Source_of h.z) +* ((the_Target_of h.z) | (A.z))).x
            by A66, A67, GLIB_007:def 1
          .= (the_Source_of h.z).x by A75, FUNCT_4:11
          .= (union the_Source_of S2).x by A68, A72, COMPUT_1:13
          .= (the_Source_of G2).x by GLIB_014:def 25
          .= (the_Source_of G2 +* ((the_Target_of G2) | E)).x
            by A82, FUNCT_4:11;
      end;
      suppose A83: x in A.z;
        then x in the_Edges_of h.z /\ A.z by A67, XBOOLE_1:28;
        then x in dom the_Target_of h.z /\ A.z by FUNCT_2:def 1;
        then A84: x in dom((the_Target_of h.z) | (A.z)) by RELAT_1:61;
        z in S1;
        then z in dom A by PARTFUN1:def 2;
        then A.z in rng A by FUNCT_1:3;
        then A85: x in E by A83, TARSKI:def 4;
        then x in the_Edges_of G2 /\ E by XBOOLE_1:28;
        then x in dom the_Target_of G2 /\ E by FUNCT_2:def 1;
        then A86: x in dom((the_Target_of G2) | E) by RELAT_1:61;
        thus (the_Source_of G3).x
           = (union the_Source_of S3).x by GLIB_014:def 25
          .= (the_Source_of B.z).x by A65, A70, COMPUT_1:13
          .= ((the_Source_of h.z) +* ((the_Target_of h.z) | (A.z))).x
            by A66, A67, GLIB_007:def 1
          .= ((the_Target_of h.z) | (A.z)).x by A84, FUNCT_4:13
          .= (the_Target_of h.z).x by A83, FUNCT_1:49
          .= (union the_Target_of S2).x by A69, A73, COMPUT_1:13
          .= (the_Target_of G2).x by GLIB_014:def 25
          .= ((the_Target_of G2) | E).x by A85, FUNCT_1:49
          .= (the_Source_of G2 +* ((the_Target_of G2) | E)).x
            by A86, FUNCT_4:13;
      end;
    end;
    hence the_Source_of G3 = the_Source_of G2 +* ((the_Target_of G2) | E)
      by A59, FUNCT_1:2;
    A87: dom the_Target_of G3 = the_Edges_of G3 by FUNCT_2:def 1
      .= the_Edges_of G2 \/ (the_Edges_of G2 /\ E) by A58, XBOOLE_1:22
      .= dom the_Target_of G2 \/ (the_Edges_of G2 /\ E) by FUNCT_2:def 1
      .= dom the_Target_of G2 \/ (dom the_Source_of G2 /\ E) by FUNCT_2:def 1
      .= dom the_Target_of G2 \/ (dom((the_Source_of G2)|E)) by RELAT_1:61
      .= dom(the_Target_of G2 +* ((the_Source_of G2) | E)) by FUNCT_4:def 1;
    now
      let x be object;
      assume x in dom the_Target_of G3;
      then x in the_Edges_of G3;
      then x in union the_Edges_of rng B by GLIB_014:def 25;
      then consider X be set such that
        A88: x in X & X in the_Edges_of rng B by TARSKI:def 4;
      consider G being _Graph such that
        A89: G in rng B & X = the_Edges_of G by A88, GLIB_014:def 15;
      consider z being object such that
        A90: z in dom B & B.z = G by A89, FUNCT_1:def 3;
      reconsider z as Element of S1 by A90;
      A91: z in dom h by A1;
      A92: h.z in S2 by A1, FUNCT_1:3;
      B.z in rng B by A90, FUNCT_1:3;
      then A93: the_Target_of B.z in the_Target_of rng B by GLIB_014:def 17;
      A94: B.z = the reverseEdgeDirections of h.z, A.z by A19;
      A95: A.z is Subset of the_Edges_of h.z by A14;
      A96: the_Target_of h.z in the_Target_of S2 by A92, GLIB_014:def 17;
      A97: the_Source_of h.z in the_Source_of S2 by A92, GLIB_014:def 16;
      A98: x in dom the_Target_of B.z by A88, A89, A90, FUNCT_2:def 1;
      A99: the_Edges_of B.z = the_Edges_of h.z by A94, GLIB_007:4;
      then A100: x in dom the_Target_of h.z by A88, A89, A90, FUNCT_2:def 1;
      A101: x in dom the_Source_of h.z by A88, A89, A90, A99, FUNCT_2:def 1;
      per cases;
      suppose A102: not x in A.z;
        then not x in the_Edges_of h.z /\ A.z by TARSKI:def 3, XBOOLE_1:17;
        then not x in dom the_Source_of h.z /\ A.z by FUNCT_2:def 1;
        then A103: not x in dom((the_Source_of h.z) | (A.z)) by RELAT_1:61;
        not x in E
        proof
          assume x in E;
          then consider Y being set such that
            A104: x in Y & Y in rng A by TARSKI:def 4;
          consider z9 being object such that
            A105: z9 in dom A & A.z9 = Y by A104, FUNCT_1:def 3;
          reconsider z9 as Element of S1 by A105;
          A106: x in A.z9  by A104, A105;
          A.z9 is Subset of the_Edges_of h.z9 by A14;
          then A107: x in the_Edges_of h.z9 by A106;
          A108: z9 in dom h by A1;
          A109: h.z9 in S2 by A1, FUNCT_1:3;
          the_Edges_of h.z = the_Edges_of G by A90, A94, GLIB_007:4;
          then x in the_Edges_of h.z by A88, A89;
          then the_Edges_of h.z meets the_Edges_of h.z9 by A107, XBOOLE_0:3;
          then z = z9 by A91, A92, A108, A109, Def19, FUNCT_1:def 4;
          hence contradiction by A102, A106;
        end;
        then not x in the_Edges_of G2 /\ E by TARSKI:def 3, XBOOLE_1:17;
        then not x in dom the_Source_of G2 /\ E by FUNCT_2:def 1;
        then A110: not x in dom((the_Source_of G2) | E) by RELAT_1:61;
        thus (the_Target_of G3).x
           = (union the_Target_of S3).x by GLIB_014:def 25
          .= (the_Target_of B.z).x by A93, A98, COMPUT_1:13
          .= ((the_Target_of h.z) +* ((the_Source_of h.z) | (A.z))).x
            by A94, A95, GLIB_007:def 1
          .= (the_Target_of h.z).x by A103, FUNCT_4:11
          .= (union the_Target_of S2).x by A96, A100, COMPUT_1:13
          .= (the_Target_of G2).x by GLIB_014:def 25
          .= (the_Target_of G2 +* ((the_Source_of G2) | E)).x
            by A110, FUNCT_4:11;
      end;
      suppose A111: x in A.z;
        then x in the_Edges_of h.z /\ A.z by A95, XBOOLE_1:28;
        then x in dom the_Source_of h.z /\ A.z by FUNCT_2:def 1;
        then A112: x in dom((the_Source_of h.z) | (A.z)) by RELAT_1:61;
        z in S1;
        then z in dom A by PARTFUN1:def 2;
        then A.z in rng A by FUNCT_1:3;
        then A113: x in E by A111, TARSKI:def 4;
        then x in the_Edges_of G2 /\ E by XBOOLE_1:28;
        then x in dom the_Source_of G2 /\ E by FUNCT_2:def 1;
        then A114: x in dom((the_Source_of G2) | E) by RELAT_1:61;
        thus (the_Target_of G3).x
           = (union the_Target_of S3).x by GLIB_014:def 25
          .= (the_Target_of B.z).x by A93, A98, COMPUT_1:13
          .= ((the_Target_of h.z) +* ((the_Source_of h.z) | (A.z))).x
            by A94, A95, GLIB_007:def 1
          .= ((the_Source_of h.z) | (A.z)).x by A112, FUNCT_4:13
          .= (the_Source_of h.z).x by A111, FUNCT_1:49
          .= (union the_Source_of S2).x by A97, A101, COMPUT_1:13
          .= (the_Source_of G2).x by GLIB_014:def 25
          .= ((the_Source_of G2) | E).x by A113, FUNCT_1:49
          .= (the_Target_of G2 +* ((the_Source_of G2) | E)).x
            by A114, FUNCT_4:13;
      end;
    end;
    hence the_Target_of G3 = the_Target_of G2 +* ((the_Source_of G2) | E)
      by A87, FUNCT_1:2;
  end;
  hence G3 is reverseEdgeDirections of G2, E by GLIB_007:def 1;
end;

theorem Th57:
  for S1, S2 being vertex-disjoint GraphUnionSet
  for G1 being (GraphUnion of S1), G2 being GraphUnion of S2
  st S1,S2 are_isomorphic holds G2 is G1-isomorphic
proof
  let S1, S2 be vertex-disjoint GraphUnionSet, G1 be GraphUnion of S1;
  let G2 be GraphUnion of S2;
  assume S1,S2 are_isomorphic;
  then consider S3 being vertex-disjoint GraphUnionSet,
      E being Subset of the_Edges_of G2, G3 being GraphUnion of S3 such that
    A1: S1,S3 are_Disomorphic and
    A2: G3 is reverseEdgeDirections of G2, E by Th56;
  A3: G3 is G1-Disomorphic by A1, Th55;
  G3 is G2-isomorphic by A2, GLIBPRE0:80;
  then G2 is G3-isomorphic by GLIB_010:95;
  hence thesis by A3;
end;

theorem Th58:
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S
  for W being Walk of G ex H being Element of S st W is Walk of H
proof
  let S be vertex-disjoint GraphUnionSet, G be GraphUnion of S;
  defpred P[Walk of G] means ex H being Element of S st $1 is Walk of H;
  A1: for W being trivial Walk of G holds P[W]
  proof
    let W be trivial Walk of G;
    consider v being Vertex of G such that
      A2: W = G.walkOf(v) by GLIB_001:128;
    the_Vertices_of G = union the_Vertices_of S by GLIB_014:def 25;
    then consider X being set such that
      A3: v in X & X in the_Vertices_of S by TARSKI:def 4;
    consider H being _Graph such that
      A4: H in S & X = the_Vertices_of H by A3, GLIB_014:def 14;
    reconsider H as Element of S by A4;
    take H;
    reconsider w = v as Vertex of H by A3, A4;
    W = <* w *> by A2, GLIB_001:def 4
      .= H.walkOf(w) by GLIB_001:def 4;
    hence thesis;
  end;
  A5: for W being Walk of G, e being object
    st e in W.last().edgesInOut() & P[W] holds P[W.addEdge(e)]
  proof
    let W be Walk of G, e be object;
    assume A6: e in W.last().edgesInOut() & P[W];
    then consider H being Element of S such that
      A7: W is Walk of H;
    reconsider H9 = H as Subgraph of G by GLIB_014:21;
    reconsider W9 = W as Walk of H9 by A7;
    A8: W.last() = W9.last() by GLIB_001:16;
    e Joins W.last(),W.last().adj(e),G by A6, GLIB_000:67;
    then consider H0 being Element of S such that
      A9: e Joins W.last(),W.last().adj(e),H0 by GLIBPRE1:117;
    W9.last() in the_Vertices_of H0 by A8, A9, GLIB_000:13;
    then the_Vertices_of H meets the_Vertices_of H0 by XBOOLE_0:3;
    then e Joins W9.last(),W.last().adj(e),H9 by A8, A9, Def18;
    then e in W9.last().edgesInOut() by GLIB_000:62;
    then W.addEdge(e) = W9.addEdge(e) by GLIB_001:174;
    hence thesis;
  end;
  for W being Walk of G holds P[W] from GLIB_009:sch 1(A1,A5);
  hence thesis;
end;

theorem Th59:
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S
  st G is connected ex H being _Graph st S = {H}
proof
  let S be vertex-disjoint GraphUnionSet, G being GraphUnion of S;
  assume A1: G is connected;
  set v = the Vertex of G;
  the_Vertices_of G = union the_Vertices_of S by GLIB_014:def 25;
  then consider X being set such that
    A2: v in X & X in the_Vertices_of S by TARSKI:def 4;
  consider H being _Graph such that
    A3: H in S & X = the_Vertices_of H by A2, GLIB_014:def 14;
  take H;
  now
    let x be object;
    assume x in the_Vertices_of G;
    then reconsider w = x as Vertex of G;
    consider W being Walk of G such that
      A4: W is_Walk_from v,w by A1, GLIB_002:def 1;
    consider H9 being Element of S such that
      A5: W is Walk of H9 by Th58;
    reconsider W9 = W as Walk of H9 by A5;
    W9 is_Walk_from v,w by A4, GLIB_001:19;
    then A6: v is Vertex of H9 & w is Vertex of H9 by GLIB_001:18;
    then the_Vertices_of H meets the_Vertices_of H9 by A2, A3, XBOOLE_0:3;
    then H = H9 by A3, Def18;
    hence x in the_Vertices_of H by A6;
  end;
  then A7: the_Vertices_of G c= the_Vertices_of H by TARSKI:def 3;
  now
    let Y be object;
    assume Y in S;
    then reconsider H9 = Y as Element of S;
    set w = the Vertex of H9;
    H9 is Subgraph of G by GLIB_014:21;
    then the_Vertices_of H9 c= the_Vertices_of G by GLIB_000:def 32;
    then w in the_Vertices_of G by TARSKI:def 3;
    then the_Vertices_of H meets the_Vertices_of H9 by A7, XBOOLE_0:3;
    then Y = H by A3, Def18;
    hence Y in {H} by TARSKI:def 1;
  end;
  hence thesis by TARSKI:def 3, ZFMISC_1:33;
end;

theorem Th60:
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S holds
    (S is non-multi iff G is non-multi) &
    (S is non-Dmulti iff G is non-Dmulti) &
    (S is acyclic iff G is acyclic)
proof
  let S be vertex-disjoint GraphUnionSet, G be GraphUnion of S;
  :: non-multi
  hereby
    assume A1: S is non-multi;
    now
      let e1,e2,v1,v2 be object;
      assume A2: e1 Joins v1,v2,G & e2 Joins v1,v2,G;
      then consider H1 being Element of S such that
        A3: e1 Joins v1,v2,H1 by GLIBPRE1:117;
      consider H2 being Element of S such that
        A4: e2 Joins v1,v2,H2 by A2, GLIBPRE1:117;
      v1 in the_Vertices_of H1 & v1 in the_Vertices_of H2
        by A3, A4, GLIB_000:13;
      then e2 Joins v1,v2,H1 by A4, Def18, XBOOLE_0:3;
      hence e1 = e2 by A1, A3, GLIB_000:def 20;
    end;
    hence G is non-multi by GLIB_000:def 20;
  end;
  hereby
    assume A5: G is non-multi;
    now
      let H be _Graph;
      assume H in S;
      then H is Subgraph of G by GLIB_014:21;
      hence H is non-multi by A5;
    end;
    hence S is non-multi by GLIB_014:def 4;
  end;
  :: non-Dmulti
  hereby
    assume A6: S is non-Dmulti;
    now
      let e1,e2,v1,v2 be object;
      assume A7: e1 DJoins v1,v2,G & e2 DJoins v1,v2,G;
      then consider H1 being Element of S such that
        A8: e1 DJoins v1,v2,H1 by GLIBPRE1:116;
      consider H2 being Element of S such that
        A9: e2 DJoins v1,v2,H2 by A7, GLIBPRE1:116;
      e1 Joins v1,v2,H1 & e2 Joins v1,v2,H2 by A8, A9, GLIB_000:16;
      then v1 in the_Vertices_of H1 & v1 in the_Vertices_of H2
        by GLIB_000:13;
      then e2 DJoins v1,v2,H1 by A9, Def18, XBOOLE_0:3;
      hence e1 = e2 by A6, A8, GLIB_000:def 21;
    end;
    hence G is non-Dmulti by GLIB_000:def 21;
  end;
  hereby
    assume A10: G is non-Dmulti;
    now
      let H be _Graph;
      assume H in S;
      then H is Subgraph of G by GLIB_014:21;
      hence H is non-Dmulti by A10;
    end;
    hence S is non-Dmulti by GLIB_014:def 5;
  end;
  :: acyclic
  hereby
    assume A11: S is acyclic;
    assume G is non acyclic;
    then consider W being Walk of G such that
      A12: W is Cycle-like by GLIB_002:def 2;
    consider H being Element of S such that
      A13: W is Walk of H by Th58;
    reconsider W9 = W as Walk of H by A13;
    W9 is Cycle-like by A12, GLIB_006:24;
    hence contradiction by A11, GLIB_002:def 2;
  end;
  hereby
    assume A14: G is acyclic;
    now
      let H be _Graph;
      assume H in S;
      then H is Subgraph of G by GLIB_014:21;
      hence H is acyclic by A14;
    end;
    hence S is acyclic by GLIB_014:def 8;
  end;
end;

theorem
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S holds
    (S is simple iff G is simple) &
    (S is Dsimple iff G is Dsimple)
proof
  let S be vertex-disjoint GraphUnionSet, G be GraphUnion of S;
  hereby
    assume S is simple;
    then G is loopless non-multi by Th60;
    hence G is simple;
  end;
  hereby
    assume G is simple;
    then G is loopless non-multi;
    then S is loopless non-multi by Th60, GLIB_014:23;
    hence S is simple;
  end;
  hereby
    assume S is Dsimple;
    then G is loopless non-Dmulti by Th60;
    hence G is Dsimple;
  end;
  hereby
    assume G is Dsimple;
    then S is loopless non-Dmulti by Th60, GLIB_014:23;
    hence S is Dsimple;
  end;
end;

registration
  let S be vertex-disjoint non-multi GraphUnionSet;
  cluster -> non-multi for GraphUnion of S;
  coherence by Th60;
end;

registration
  let S be vertex-disjoint non-Dmulti GraphUnionSet;
  cluster -> non-Dmulti for GraphUnion of S;
  coherence by Th60;
end;

registration
  let S be vertex-disjoint simple GraphUnionSet;
  cluster -> simple for GraphUnion of S;
  coherence;
end;

registration
  let S be vertex-disjoint Dsimple GraphUnionSet;
  cluster -> Dsimple for GraphUnion of S;
  coherence;
end;

registration
  let S be vertex-disjoint acyclic GraphUnionSet;
  cluster -> acyclic for GraphUnion of S;
  coherence by Th60;
end;

theorem Th62:
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S
  for H being Element of S holds H is inducedSubgraph of G, the_Vertices_of H
proof
  let S be vertex-disjoint GraphUnionSet, G be GraphUnion of S;
  let H be Element of S;
  A1: H is Subgraph of G by GLIB_014:21;
  then A2: the_Vertices_of H is non empty Subset of the_Vertices_of G
    by GLIB_000:def 32;
  now
    let x be object;
    hereby
      set v = (the_Source_of H).x, w = (the_Target_of H).x;
      assume x in the_Edges_of H;
      then A3: x Joins v,w,H by GLIB_000:def 13;
      then A4: v in the_Vertices_of H & w in the_Vertices_of H by GLIB_000:13;
      x Joins v,w,G by A1, A3, GLIB_000:72;
      hence x in G.edgesBetween(the_Vertices_of H) by A4, GLIB_000:32;
    end;
    set v = (the_Source_of G).x, w = (the_Target_of G).x;
    assume x in G.edgesBetween(the_Vertices_of H);
    then A5: v in the_Vertices_of H & x in the_Edges_of G by GLIB_000:31;
    then x Joins v,w,G by GLIB_000:def 13;
    then consider H9 being Element of S such that
      A6: x Joins v,w,H9 by GLIBPRE1:117;
    v in the_Vertices_of H9 by A6, GLIB_000:13;
    then H = H9 by A5, Def18, XBOOLE_0:3;
    hence x in the_Edges_of H by A6, GLIB_000:def 13;
  end;
  then the_Edges_of H = G.edgesBetween(the_Vertices_of H) by TARSKI:2;
  hence thesis by A1, A2, GLIB_000:def 37;
end;

theorem Th63:
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S holds
    (S is chordal iff G is chordal) &
    (S is loopfull iff G is loopfull)
proof
  let S be vertex-disjoint GraphUnionSet, G be GraphUnion of S;
  :: chordal
  hereby
    assume A1: S is chordal;
    now
      let W be Walk of G;
      assume A2: W.length() > 3 & W is Cycle-like;
      now
        consider H being Element of S such that
          A3: W is Walk of H by Th58;
        reconsider W9 = W as Walk of H by A3;
        W9.length() > 3 & W9 is Cycle-like by A2, GLIB_001:114, GLIB_006:24;
        then W9 is chordal by A1, CHORD:def 11;
        then consider m, n being odd Nat such that
          A4: m+2 < n & n <= len W9 & W9.m <> W9.n and
          A5: ex e being object st e Joins W9.m,W9.n,H and
          A6: for f being object st f in W9.edges()
            holds not f Joins W9.m,W9.n,H by CHORD:def 10;
        take m, n;
        thus m+2 < n & n <= len W & W.m <> W.n by A4;
        hereby
          consider e being object such that
            A7: e Joins W9.m,W9.n,H by A5;
          take e;
          H is Subgraph of G by GLIB_014:21;
          hence e Joins W.m,W.n,G by A7, GLIB_000:72;
        end;
        let f be object;
        assume A8: f in W.edges();
        W.edges() = rng W.edgeSeq() by GLIB_001:def 17
          .= rng W9.edgeSeq() by GLIB_001:86
          .= W9.edges() by GLIB_001:def 17;
        then A9: not f Joins W9.m,W9.n,H by A6, A8;
        assume f Joins W.m,W.n,G;
        then consider H9 being Element of S such that
          A10: f Joins W.m,W.n,H9 by GLIBPRE1:117;
        A11: W.n in the_Vertices_of H9 by A10, GLIB_000:13;
        n is odd Element of NAT by ORDINAL1:def 12;
        then W9.n in the_Vertices_of H by A4, GLIB_001:7;
        then H = H9 by A11, Def18, XBOOLE_0:3;
        hence contradiction by A9, A10;
      end;
      hence W is chordal by CHORD:def 10;
    end;
    hence G is chordal by CHORD:def 11;
  end;
  hereby
    assume A12: G is chordal;
    now
      let H be _Graph;
      assume H in S;
      then H is inducedSubgraph of G, the_Vertices_of H by Th62;
      hence H is chordal by A12;
    end;
    hence S is chordal by GLIB_014:def 11;
  end;
  :: loopfull
  thus S is loopfull implies G is loopfull;
  hereby
    assume A13: G is loopfull;
    now
      let H be _Graph;
      assume A14: H in S;
      now
        let v be Vertex of H;
        H is Subgraph of G by A14, GLIB_014:21;
        then the_Vertices_of H c= the_Vertices_of G by GLIB_000:def 32;
        then reconsider w = v as Vertex of G by TARSKI:def 3;
        consider e being object such that
          A15: e Joins w,w,G by A13, GLIB_012:def 1;
        consider H9 being Element of S such that
          A16: e Joins w,w,H9 by A15, GLIBPRE1:117;
        take e;
        w in the_Vertices_of H9 by A16, GLIB_000:13;
        then H = H9 by A14, Def18, XBOOLE_0:3;
        hence e Joins v,v,H by A16;
      end;
      hence H is loopfull by GLIB_012:def 1;
    end;
    hence S is loopfull by GLIB_014:def 13;
  end;
end;

theorem Th64:
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S
  for H being Element of S, v being Vertex of G, w being Vertex of H
  st v = w holds G.reachableFrom(v) = H.reachableFrom(w)
proof
  let S be vertex-disjoint GraphUnionSet, G being GraphUnion of S;
  let H be Element of S, v be Vertex of G, w being Vertex of H;
  assume A1: v = w;
  H is Subgraph of G by GLIB_014:21;
  then A2: H.reachableFrom(w) c= G.reachableFrom(v) by A1, GLIB_002:14;
  now
    let x be object;
    assume x in G.reachableFrom(v);
    then consider W being Walk of G such that
      A3: W is_Walk_from v,x by GLIB_002:def 5;
    consider H9 being Element of S such that
      A4: W is Walk of H9 by Th58;
    reconsider W9 = W as Walk of H9 by A4;
    A5: W9 is_Walk_from v,x by A3, GLIB_001:19;
    then v is Vertex of H9 & x is Vertex of H9 by GLIB_001:18;
    then the_Vertices_of H meets the_Vertices_of H9 by A1, XBOOLE_0:3;
    then reconsider W0 = W9 as Walk of H by Def18;
    W0 is_Walk_from w,x by A1, A5, GLIB_001:19;
    hence x in H.reachableFrom(w) by GLIB_002:def 5;
  end;
  then G.reachableFrom(v) c= H.reachableFrom(w) by TARSKI:def 3;
  hence thesis by A2, XBOOLE_0:def 10;
end;

theorem Th65:
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S
  holds G.componentSet()
    = union the set of all H.componentSet() where H is Element of S
proof
  let S be vertex-disjoint GraphUnionSet, G be GraphUnion of S;
  now
    let x be object;
    hereby
      assume x in G.componentSet();
      then consider v being Vertex of G such that
        A1: x = G.reachableFrom(v) by GLIB_002:def 8;
      the_Vertices_of G = union the_Vertices_of S by GLIB_014:def 25;
      then consider X being set such that
        A2: v in X & X in the_Vertices_of S by TARSKI:def 4;
      consider H9 being _Graph such that
        A3: H9 in S & X = the_Vertices_of H9 by A2, GLIB_014:def 14;
      reconsider w = v as Vertex of H9 by A2, A3;
      H9.reachableFrom(w) = x by A1, A3, Th64;
      then A4: x in H9.componentSet() by GLIB_002:def 8;
      H9.componentSet() in the set of all H.componentSet()
        where H is Element of S by A3;
      hence x in union the set of all H.componentSet() where H is Element of S
        by A4, TARSKI:def 4;
    end;
    assume x in union the set of all H.componentSet() where H is Element of S;
    then consider X being set such that
      A5: x in X & X in the set of all H.componentSet() where H is Element of S
      by TARSKI:def 4;
    consider H being Element of S such that
      A6: X = H.componentSet() by A5;
    consider w being Vertex of H such that
      A7: x = H.reachableFrom(w) by A5, A6, GLIB_002:def 8;
    H is Subgraph of G by GLIB_014:21;
    then the_Vertices_of H c= the_Vertices_of G by GLIB_000:def 32;
    then reconsider v = w as Vertex of G by TARSKI:def 3;
    x = G.reachableFrom(v) by A7, Th64;
    hence x in G.componentSet() by GLIB_002:def 8;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th66:
  for S being vertex-disjoint non empty Graph-membered set
  holds the set of all H.componentSet() where H is Element of S
    is mutually-disjoint
proof
  let S be vertex-disjoint non empty Graph-membered set;
  set M = the set of all H.componentSet() where H is Element of S;
  now
    let x,y be set;
    assume x in M;
    then consider H1 being Element of S such that
      A1: x = H1.componentSet();
    assume y in M;
    then consider H2 being Element of S such that
      A2: y = H2.componentSet();
    assume A3: x <> y;
    assume x meets y;
    then consider z being object such that
      A4: z in H1.componentSet() & z in H2.componentSet()
      by A1, A2, XBOOLE_0:3;
    reconsider z as set by TARSKI:1;
    A5: the_Vertices_of H1 misses the_Vertices_of H2 by A1, A2, A3, Def18;
    z c= the_Vertices_of H1 /\ the_Vertices_of H2 by A4, XBOOLE_1:19;
    then z c= {} by A5, XBOOLE_0:def 7;
    hence contradiction by A4;
  end;
  hence thesis by TAXONOM2:def 5;
end;

Lm2:
  for S being vertex-disjoint non empty Graph-membered set
  holds card S = card the set of all H.componentSet() where H is Element of S
proof
  let S be vertex-disjoint non empty Graph-membered set;
  deffunc F(Element of S) = $1.componentSet();
  consider f being ManySortedSet of S such that
    A1: for H being Element of S holds f.H = F(H) from PBOOLE:sch 5;
  A2: dom f = S by PARTFUN1:def 2;
  set M = the set of all H.componentSet() where H is Element of S;
  now
    let y be object;
    hereby
      assume y in rng f;
      then consider x being object such that
        A3: x in dom f & f.x = y by FUNCT_1:def 3;
      reconsider x as Element of S by A3;
      y = x.componentSet() by A1, A3;
      hence y in M;
    end;
    assume y in M;
    then consider H being Element of S such that
      A4: y = H.componentSet();
    f.H in rng f by A2, FUNCT_1:3;
    hence y in rng f by A1, A4;
  end;
  then A5: rng f = M by TARSKI:2;
  now
    let x1,x2 be object;
    assume A6: x1 in dom f & x2 in dom f & f.x1 = f.x2;
    then reconsider H1 = x1, H2 = x2 as Element of S;
    set V = the Element of H1.componentSet();
    f.x1 = H1.componentSet() & f.x2 = H2.componentSet() by A1;
    then V in H1.componentSet() & V in H2.componentSet() by A6;
    then A7: V c= the_Vertices_of H1 /\ the_Vertices_of H2 by XBOOLE_1:19;
    the_Vertices_of H1 /\ the_Vertices_of H2 <> {} by A7;
    hence x1 = x2 by Def18, XBOOLE_0:def 7;
  end;
  hence thesis by A2, A5, FUNCT_1:def 4, CARD_1:70;
end;

theorem Th67:
  for S being non empty connected Graph-membered set
  holds the set of all H.componentSet() where H is Element of S
    = SmallestPartition the_Vertices_of S
proof
  let S be non empty connected Graph-membered set;
  set M1 = the set of all H.componentSet() where H is Element of S;
  set M2 = the set of all {X} where X is Element of the_Vertices_of S;
  now
    let x be object;
    hereby
      assume x in M1;
      then consider H being Element of S such that
        A1: x = H.componentSet();
      A2: x = {the_Vertices_of H} by A1, GLIB_002:25;
      the_Vertices_of H in the_Vertices_of S by GLIB_014:def 14;
      hence x in M2 by A2;
    end;
    assume x in M2;
    then consider X being Element of the_Vertices_of S such that
      A3: x = {X};
    consider H being _Graph such that
      A4: H in S & X = the_Vertices_of H by GLIB_014:def 14;
    reconsider H as Element of S by A4;
    x = H.componentSet() by A3, A4, GLIB_002:25;
    hence x in M1;
  end;
  then M1 = M2 by TARSKI:2;
  hence thesis by EQREL_1:37;
end;

:: this is probably somewhere
Lm3:
  for X being non empty set holds 1 c= card X
proof
  let X be non empty set;
  assume not 1 c= card X;
  then card X in {0} by ORDINAL1:16, CARD_1:49;
  hence contradiction by TARSKI:def 1;
end;

theorem Th68:
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S
  holds card S c= G.numComponents()
proof
  let S be vertex-disjoint GraphUnionSet, G be GraphUnion of S;
  set M = the set of all H.componentSet() where H is Element of S;
  now
    thus M is mutually-disjoint by Th66;
    thus card S c= card M by Lm2;
    let Y be set;
    assume Y in M;
    then consider H being Element of S such that
      A1: Y = H.componentSet();
    thus 1 c= card Y by A1, Lm3;
  end;
  then (card S)*`1 c= card union M by GLIBPRE1:15;
  then card S c= card union M by CARD_2:21;
  then card S c= card G.componentSet() by Th65;
  hence thesis by GLIB_002:def 9;
end;

theorem Th69:
  for S being vertex-disjoint GraphUnionSet, G being GraphUnion of S
  st S is connected holds card S = G.numComponents()
proof
  let S be vertex-disjoint GraphUnionSet, G be GraphUnion of S;
  assume A1: S is connected;
  thus card S
     = card the set of all H.componentSet() where H is Element of S by Lm2
    .= card SmallestPartition the_Vertices_of S by A1, Th67
    .= card the_Vertices_of S by TOPGEN_2:12
    .= card union SmallestPartition the_Vertices_of S by EQREL_1:def 4
    .= card union the set of all H.componentSet() where H is Element of S
      by A1, Th67
    .= card G.componentSet() by Th65
    .= G.numComponents() by GLIB_002:def 9;
end;

definition
  let F be Graph-yielding Function;
  attr F is vertex-disjoint means
  :Def20:
  for x1,x2 being object st x1 in dom F & x2 in dom F & x1 <> x2
  ex G1, G2 being _Graph st G1 = F.x1 & G2 = F.x2 &
    the_Vertices_of G1 misses the_Vertices_of G2;
  attr F is edge-disjoint means
  :Def21:
  for x1,x2 being object st x1 in dom F & x2 in dom F & x1 <> x2
  ex G1, G2 being _Graph st G1 = F.x1 & G2 = F.x2 &
    the_Edges_of G1 misses the_Edges_of G2;
end;

:: note that edge-disjoint -> one-to-one doesn't hold because of edgeless graphs
registration
  cluster trivial -> vertex-disjoint edge-disjoint for Graph-yielding Function;
  coherence by ZFMISC_1:def 10;
  cluster vertex-disjoint -> one-to-one for Graph-yielding Function;
  coherence
  proof
    let F be Graph-yielding Function;
    assume A1: F is vertex-disjoint;
    now
      let x1, x2 be object;
      assume A2: x1 in dom F & x2 in dom F & F.x1 = F.x2;
      assume x1 <> x2;
      then consider G1, G2 being _Graph such that
        A3: G1 = F.x1 & G2 = F.x2 &
          the_Vertices_of G1 misses the_Vertices_of G2 by A1, A2;
      thus contradiction by A2, A3;
    end;
    hence thesis by FUNCT_1:def 4;
  end;
end;

definition
  let F be non empty Graph-yielding Function;
  redefine attr F is vertex-disjoint means
  :Def22:
  for x1,x2 being Element of dom F st x1 <> x2
  holds the_Vertices_of (F.x1) misses the_Vertices_of (F.x2);
  compatibility
  proof
    hereby
      assume A1: F is vertex-disjoint;
      let x1,x2 be Element of dom F;
      assume x1 <> x2;
      then consider G1, G2 being _Graph such that
        A2: G1 = F.x1 & G2 = F.x2 &
          the_Vertices_of G1 misses the_Vertices_of G2 by A1;
      thus the_Vertices_of (F.x1) misses the_Vertices_of (F.x2) by A2;
    end;
    assume A3: for x1,x2 being Element of dom F st x1 <> x2
      holds the_Vertices_of (F.x1) misses the_Vertices_of (F.x2);
    let x1,x2 being object;
    assume A4: x1 in dom F & x2 in dom F & x1 <> x2;
    then reconsider y1 = x1, y2 = x2 as Element of dom F;
    take F.y1, F.y2;
    thus thesis by A3, A4;
  end;
  redefine attr F is edge-disjoint means
  :Def23:
  for x1,x2 being Element of dom F st x1 <> x2
  holds the_Edges_of (F.x1) misses the_Edges_of (F.x2);
  compatibility
  proof
    hereby
      assume A5: F is edge-disjoint;
      let x1,x2 be Element of dom F;
      assume x1 <> x2;
      then consider G1, G2 being _Graph such that
        A6: G1 = F.x1 & G2 = F.x2 &
          the_Edges_of G1 misses the_Edges_of G2 by A5;
      thus the_Edges_of (F.x1) misses the_Edges_of (F.x2) by A6;
    end;
    assume A7: for x1,x2 being Element of dom F st x1 <> x2
      holds the_Edges_of (F.x1) misses the_Edges_of (F.x2);
    let x1,x2 being object;
    assume A8: x1 in dom F & x2 in dom F & x1 <> x2;
    then reconsider y1 = x1, y2 = x2 as Element of dom F;
    take F.y1, F.y2;
    thus thesis by A7, A8;
  end;
end;

theorem Th70:
  for F being non empty Graph-yielding Function holds F is vertex-disjoint iff
    for x1,x2 being Element of dom F st x1 <> x2
    holds (the_Vertices_of F).x1 misses (the_Vertices_of F).x2
proof
  let F be non empty Graph-yielding Function;
  hereby
    assume A1: F is vertex-disjoint;
    let x1, x2 be Element of dom F;
    assume A2: x1 <> x2;
    (the_Vertices_of F).x1 = the_Vertices_of(F.x1) &
      (the_Vertices_of F).x2 = the_Vertices_of(F.x2) by Def8;
    hence (the_Vertices_of F).x1 misses (the_Vertices_of F).x2 by A1, A2;
  end;
  assume A3: for x1,x2 being Element of dom F st x1 <> x2
    holds (the_Vertices_of F).x1 misses (the_Vertices_of F).x2;
  let x1,x2 being Element of dom F;
  assume A4: x1 <> x2;
  (the_Vertices_of F).x1 = the_Vertices_of(F.x1) &
    (the_Vertices_of F).x2 = the_Vertices_of(F.x2) by Def8;
  hence the_Vertices_of (F.x1) misses the_Vertices_of (F.x2) by A3, A4;
end;

theorem Th71:
  for F being non empty Graph-yielding Function holds F is edge-disjoint iff
    for x1,x2 being Element of dom F st x1 <> x2
    holds (the_Edges_of F).x1 misses (the_Edges_of F).x2
proof
  let F be non empty Graph-yielding Function;
  hereby
    assume A1: F is edge-disjoint;
    let x1, x2 be Element of dom F;
    assume A2: x1 <> x2;
    (the_Edges_of F).x1 = the_Edges_of(F.x1) &
      (the_Edges_of F).x2 = the_Edges_of(F.x2) by Def9;
    hence (the_Edges_of F).x1 misses (the_Edges_of F).x2 by A1, A2;
  end;
  assume A3: for x1,x2 being Element of dom F st x1 <> x2
    holds (the_Edges_of F).x1 misses (the_Edges_of F).x2;
  let x1,x2 being Element of dom F;
  assume A4: x1 <> x2;
  (the_Edges_of F).x1 = the_Edges_of(F.x1) &
    (the_Edges_of F).x2 = the_Edges_of(F.x2) by Def9;
  hence the_Edges_of (F.x1) misses the_Edges_of (F.x2) by A3, A4;
end;

:: might need Proof outside this article
theorem
  for F being non empty Graph-yielding Function
  holds F is vertex-disjoint edge-disjoint iff
    for x1,x2 being Element of dom F st x1 <> x2
    holds the_Vertices_of(F.x1) misses the_Vertices_of(F.x2) &
      the_Edges_of(F.x1) misses the_Edges_of(F.x2);

theorem Th73:
  for F being non empty Graph-yielding Function
  holds F is vertex-disjoint edge-disjoint iff
    for x1,x2 being Element of dom F st x1 <> x2
    holds (the_Vertices_of F).x1 misses (the_Vertices_of F).x2 &
      (the_Edges_of F).x1 misses (the_Edges_of F).x2
proof
  let F be non empty Graph-yielding Function;
  thus F is vertex-disjoint edge-disjoint implies
    for x1,x2 being Element of dom F st x1 <> x2 holds
      (the_Vertices_of F).x1 misses (the_Vertices_of F).x2 &
      (the_Edges_of F).x1 misses (the_Edges_of F).x2 by Th70, Th71;
  assume A1: for x1,x2 being Element of dom F st x1 <> x2
    holds (the_Vertices_of F).x1 misses (the_Vertices_of F).x2 &
      (the_Edges_of F).x1 misses (the_Edges_of F).x2;
  then for x1,x2 being Element of dom F st x1 <> x2
    holds (the_Vertices_of F).x1 misses (the_Vertices_of F).x2;
  hence F is vertex-disjoint by Th70;
  for x1,x2 being Element of dom F st x1 <> x2
    holds (the_Edges_of F).x1 misses (the_Edges_of F).x2 by A1;
  hence F is edge-disjoint by Th71;
end;

registration
  let x be object, G be _Graph;
  cluster x .--> G -> vertex-disjoint edge-disjoint;
  coherence
  proof
    x .--> G = {[x,G]} by FUNCT_4:82;
    hence thesis;
  end;
end;

registration
  let G be _Graph;
  cluster <* G *> -> vertex-disjoint edge-disjoint;
  coherence;
end;

registration
  cluster non empty vertex-disjoint edge-disjoint for Graph-yielding Function;
  existence
  proof
    take <* the _Graph *>;
    thus thesis;
  end;
end;

registration
  let F be vertex-disjoint Graph-yielding Function;
  cluster rng F -> vertex-disjoint;
  coherence
  proof
    let G1, G2 be _Graph;
    assume A1: G1 in rng F & G2 in rng F & G1 <> G2;
    then consider x1 being object such that
      A2: x1 in dom F & F.x1 = G1 by FUNCT_1:def 3;
    consider x2 being object such that
      A3: x2 in dom F & F.x2 = G2 by A1, FUNCT_1:def 3;
    consider G3, G4 being _Graph such that
      A4: G3 = F.x1 & G4 = F.x2 & the_Vertices_of G3 misses the_Vertices_of G4
      by A1, A2, A3, Def20;
    thus the_Vertices_of G1 misses the_Vertices_of G2 by A2, A3, A4;
  end;
end;

registration
  let F be edge-disjoint Graph-yielding Function;
  cluster rng F -> edge-disjoint;
  coherence
  proof
    let G1, G2 be _Graph;
    assume A1: G1 in rng F & G2 in rng F & G1 <> G2;
    then consider x1 being object such that
      A2: x1 in dom F & F.x1 = G1 by FUNCT_1:def 3;
    consider x2 being object such that
      A3: x2 in dom F & F.x2 = G2 by A1, FUNCT_1:def 3;
    consider G3, G4 being _Graph such that
      A4: G3 = F.x1 & G4 = F.x2 & the_Edges_of G3 misses the_Edges_of G4
      by A1, A2, A3, Def21;
    thus the_Edges_of G1 misses the_Edges_of G2 by A2, A3, A4;
  end;
end;

theorem Th74:
  for F1, F2 being non empty one-to-one Graph-yielding Function
  st F1, F2 are_Disomorphic holds rng F1, rng F2 are_Disomorphic
proof
  let F1, F2 be non empty one-to-one Graph-yielding Function;
  assume F1, F2 are_Disomorphic;
  then consider p being one-to-one Function such that
    A1: dom p = dom F1 & rng p = dom F2 and
    A2: for x being object st x in dom F1 ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic;
  reconsider f = F2*p*(F1") as one-to-one Function;
  take f;
  A3: dom(F2*p) = dom p by A1, RELAT_1:27
    .= rng(F1") by A1, FUNCT_1:33;
  hence dom f = dom(F1") by RELAT_1:27
    .= rng F1 by FUNCT_1:33;
  thus rng f = rng(F2*p) by A3, RELAT_1:28
    .= rng F2  by A1, RELAT_1:28;
  let G be _Graph;
  assume G in rng F1;
  then consider x being object such that
    A4: x in dom F1 & F1.x = G by FUNCT_1:def 3;
  consider G1, G2 being _Graph such that
    A5: G1 = F1.x & G2 = F2.(p.x) & G2 is G1-Disomorphic by A2, A4;
  F1.x in rng F1 by A4, FUNCT_1:3;
  then A6: G in dom(F1") by A4, FUNCT_1:33;
  then G in dom f by A3, RELAT_1:27;
  then A7: G in dom(F2*(p*(F1"))) by RELAT_1:36;
  G2 = F2.(p.(F1".(F1.x))) by A4, A5, FUNCT_1:34
    .= F2.((p*(F1")).G) by A4, A6, FUNCT_1:13
    .= (F2*(p*(F1"))).G by A7, FUNCT_1:12
    .= f.G by RELAT_1:36;
  hence f.G is G-Disomorphic _Graph by A4, A5;
end;

theorem Th75:
  for F1, F2 being non empty one-to-one Graph-yielding Function
  st F1, F2 are_isomorphic holds rng F1, rng F2 are_isomorphic
proof
  let F1, F2 be non empty one-to-one Graph-yielding Function;
  assume F1, F2 are_isomorphic;
  then consider p being one-to-one Function such that
    A1: dom p = dom F1 & rng p = dom F2 and
    A2: for x being object st x in dom F1 ex G1, G2 being _Graph
      st G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic;
  reconsider f = F2*p*(F1") as one-to-one Function;
  take f;
  A3: dom(F2*p) = dom p by A1, RELAT_1:27
    .= rng(F1") by A1, FUNCT_1:33;
  hence dom f = dom(F1") by RELAT_1:27
    .= rng F1 by FUNCT_1:33;
  thus rng f = rng(F2*p) by A3, RELAT_1:28
    .= rng F2  by A1, RELAT_1:28;
  let G be _Graph;
  assume G in rng F1;
  then consider x being object such that
    A4: x in dom F1 & F1.x = G by FUNCT_1:def 3;
  consider G1, G2 being _Graph such that
    A5: G1 = F1.x & G2 = F2.(p.x) & G2 is G1-isomorphic by A2, A4;
  F1.x in rng F1 by A4, FUNCT_1:3;
  then A6: G in dom(F1") by A4, FUNCT_1:33;
  then G in dom f by A3, RELAT_1:27;
  then A7: G in dom(F2*(p*(F1"))) by RELAT_1:36;
  G2 = F2.(p.(F1".(F1.x))) by A4, A5, FUNCT_1:34
    .= F2.((p*(F1")).G) by A4, A6, FUNCT_1:13
    .= (F2*(p*(F1"))).G by A7, FUNCT_1:12
    .= f.G by RELAT_1:36;
  hence f.G is G-isomorphic _Graph by A4, A5;
end;

theorem
  for G1, G2 being _Graph holds <* G1, G2 *> is vertex-disjoint iff
    the_Vertices_of G1 misses the_Vertices_of G2
proof
  let G1, G2 be _Graph;
  set F = <* G1, G2 *>;
  hereby
    assume A1: F is vertex-disjoint;
    1 in {1,2} & 2 in {1,2} by TARSKI:def 2;
    then reconsider x1 = 1, x2 = 2 as Element of dom F by FINSEQ_1:92;
    the_Vertices_of (F.x1) misses the_Vertices_of (F.x2) by A1;
    then the_Vertices_of G1 misses the_Vertices_of (F.x2) by FINSEQ_1:44;
    hence the_Vertices_of G1 misses the_Vertices_of G2 by FINSEQ_1:44;
  end;
  assume A2: the_Vertices_of G1 misses the_Vertices_of G2;
  let x1, x2 be Element of dom F;
  assume A3: x1 <> x2;
  x1 in dom F & x2 in dom F;
  then x1 in {1,2} & x2 in {1,2} by FINSEQ_1:92;
  then (x1 = 1 or x1 = 2) & (x2 = 1 or x2 = 2) by TARSKI:def 2;
  then per cases by A3;
  suppose x1 = 1 & x2 = 2;
    then F.x1 = G1 & F.x2 = G2 by FINSEQ_1:44;
    hence thesis by A2;
  end;
  suppose x1 = 2 & x2 = 1;
    then F.x2 = G1 & F.x1 = G2 by FINSEQ_1:44;
    hence thesis by A2;
  end;
end;

theorem
  for G1, G2 being _Graph holds <* G1, G2 *> is edge-disjoint iff
    the_Edges_of G1 misses the_Edges_of G2
proof
  let G1, G2 be _Graph;
  set F = <* G1, G2 *>;
  hereby
    assume A1: F is edge-disjoint;
    1 in {1,2} & 2 in {1,2} by TARSKI:def 2;
    then reconsider x1 = 1, x2 = 2 as Element of dom F by FINSEQ_1:92;
    the_Edges_of (F.x1) misses the_Edges_of (F.x2) by A1;
    then the_Edges_of G1 misses the_Edges_of (F.x2) by FINSEQ_1:44;
    hence the_Edges_of G1 misses the_Edges_of G2 by FINSEQ_1:44;
  end;
  assume A2: the_Edges_of G1 misses the_Edges_of G2;
  let x1, x2 be Element of dom F;
  assume A3: x1 <> x2;
  x1 in dom F & x2 in dom F;
  then x1 in {1,2} & x2 in {1,2} by FINSEQ_1:92;
  then (x1 = 1 or x1 = 2) & (x2 = 1 or x2 = 2) by TARSKI:def 2;
  then per cases by A3;
  suppose x1 = 1 & x2 = 2;
    then F.x1 = G1 & F.x2 = G2 by FINSEQ_1:44;
    hence thesis by A2;
  end;
  suppose x1 = 2 & x2 = 1;
    then F.x2 = G1 & F.x1 = G2 by FINSEQ_1:44;
    hence thesis by A2;
  end;
end;

begin :: Distinguishing the Range of a Graph-yielding Function

definition
  let f be Function, x be object;
  func renameElementsDistinctlyFunc(f,x) -> ManySortedSet of f.x equals
  <: f.x --> [f,x], id(f.x) :>;
  coherence
  proof
    dom <: f.x --> [f,x], id(f.x) :>
       = dom(f.x --> [f,x]) /\ dom id(f.x) by FUNCT_3:def 7
      .= f.x;
    hence thesis by PARTFUN1:def 2, RELAT_1:def 18;
  end;
end;

theorem Th78:
  for f being Function, x, y being object st x in dom f & y in f.x
  holds renameElementsDistinctlyFunc(f,x).y = [f,x,y]
proof
  let f be Function, x, y be object;
  assume A1: x in dom f & y in f.x;
  then y in dom renameElementsDistinctlyFunc(f,x) by PARTFUN1:def 2;
  hence renameElementsDistinctlyFunc(f,x).y
     = [ (f.x --> [f,x]).y, id(f.x).y ] by FUNCT_3:def 7
    .= [ [f,x], id(f.x).y ] by A1, FUNCOP_1:7
    .= [ [f,x], y ] by A1, FUNCT_1:18
    .= [f,x,y] by XTUPLE_0:def 4;
end;

theorem Th79:
  for f being Function, x, z being object
  st x in dom f & z in rng renameElementsDistinctlyFunc(f,x)
  ex y being object st y in f.x & z = [f,x,y]
proof
  let f be Function, x, z be object;
  assume A1: x in dom f & z in rng renameElementsDistinctlyFunc(f,x);
  then consider y being object such that
    A2: y in dom renameElementsDistinctlyFunc(f,x) and
    A3: renameElementsDistinctlyFunc(f,x).y = z by FUNCT_1:def 3;
  take y;
  thus y in f.x by A2;
  hence thesis by A1, A3, Th78;
end;

theorem Th80:
  for f being Function, x being object
  holds rng renameElementsDistinctlyFunc(f,x) = [: {[f,x]}, f.x :]
proof
  let f be Function, x be object;
  per cases;
  suppose A1: x in dom f;
    now
      let z be object;
      hereby
        assume z in rng renameElementsDistinctlyFunc(f,x);
        then consider y being object such that
          A2: y in f.x & z = [f,x,y] by A1, Th79;
        A3: [f,x] in {[f,x]} by TARSKI:def 1;
        z = [[f,x],y] by A2, XTUPLE_0:def 4;
        hence z in [: {[f,x]}, f.x :] by A2, A3, ZFMISC_1:def 2;
      end;
      assume z in [: {[f,x]}, f.x :];
      then consider z1,y being object such that
        A4: z1 in {[f,x]} & y in f.x & z = [z1,y] by ZFMISC_1:def 2;
      z1 = [f,x] by A4, TARSKI:def 1;
      then A5: z = [f,x,y] by A4, XTUPLE_0:def 4;
      y in dom renameElementsDistinctlyFunc(f,x) by A4, PARTFUN1:def 2;
      then renameElementsDistinctlyFunc(f,x).y in
        rng renameElementsDistinctlyFunc(f,x) by FUNCT_1:3;
      hence z in rng renameElementsDistinctlyFunc(f,x) by A1, A4, A5, Th78;
    end;
    hence thesis by TARSKI:2;
  end;
  suppose not x in dom f;
    then f.x = {} by FUNCT_1:def 2;
    then A6: dom renameElementsDistinctlyFunc(f,x) = {} &
      [: {[f,x]}, f.x :] = {} by ZFMISC_1:90;
    then renameElementsDistinctlyFunc(f,x) = {};
    hence thesis by A6;
  end;
end;

theorem
  for f being Function, x1, x2 being object
  holds rng renameElementsDistinctlyFunc(f,x1) misses f.x2
proof
  let f be Function, x1, x2 be object;
  per cases;
  suppose A1: x1 in dom f & x2 in dom f;
    rng renameElementsDistinctlyFunc(f,x1) /\ f.x2 = {}
    proof
      assume rng renameElementsDistinctlyFunc(f,x1) /\ f.x2 <> {};
      then consider z being object such that
        A2: z in rng renameElementsDistinctlyFunc(f,x1) /\ f.x2
        by XBOOLE_0:def 1;
      A3: z in rng renameElementsDistinctlyFunc(f,x1) by A2, XBOOLE_0:def 4;
      consider y being object such that
        A4: y in f.x1 & z = [f,x1,y] by A1, A3, Th79;
      reconsider X1 = z, X4 = [x2,f.x2], X7 = [f,x1], X9 = [[f,x1],y]
        as set by TARSKI:1;
      A5: z in f.x2 by A2, XBOOLE_0:def 4;
      A6: f.x2 in {x2,f.x2} by TARSKI:def 2;
      {x2,f.x2} in {{x2,f.x2},{x2}} by TARSKI:def 2;
      then A7: {x2,f.x2} in X4 by TARSKI:def 5;
      A8: [x2,f.x2] in f by A1, FUNCT_1:1;
      A9: f in {f} by TARSKI:def 1;
      {f} in {{f,x1},{f}} by TARSKI:def 2;
      then A10: {f} in X7 by TARSKI:def 5;
      A11: [f,x1] in {[f,x1]} by TARSKI:def 1;
      {[f,x1]} in {{[f,x1],y},{[f,x1]}} by TARSKI:def 2;
      then {[f,x1]} in X9 by TARSKI:def 5;
      then {[f,x1]} in X1 by A4, XTUPLE_0:def 4;
      hence contradiction by A5, A6, A7, A8, A9, A10, A11, GLIBPRE1:2;
    end;
    hence thesis by XBOOLE_0:def 7;
  end;
  suppose not x1 in dom f;
    then f.x1 = {} by FUNCT_1:def 2;
    then {} = rng renameElementsDistinctlyFunc(f,x1);
    hence thesis by XBOOLE_1:65;
  end;
  suppose not x2 in dom f;
    then f.x2 = {} by FUNCT_1:def 2;
    hence thesis by XBOOLE_1:65;
  end;
end;

theorem Th82:
  for f being Function, x1, x2 being object st x1 <> x2
  holds rng renameElementsDistinctlyFunc(f,x1) misses
    rng renameElementsDistinctlyFunc(f,x2)
proof
  let f be Function, x1, x2 be object;
  assume A1: x1 <> x2;
  per cases;
  suppose A2: x1 in dom f & x2 in dom f;
    rng renameElementsDistinctlyFunc(f,x1) /\
      rng renameElementsDistinctlyFunc(f,x2) = {}
    proof
      assume rng renameElementsDistinctlyFunc(f,x1) /\
        rng renameElementsDistinctlyFunc(f,x2) <> {};
      then consider z being object such that
        A3: z in rng renameElementsDistinctlyFunc(f,x1) /\
          rng renameElementsDistinctlyFunc(f,x2) by XBOOLE_0:def 1;
      A4: z in rng renameElementsDistinctlyFunc(f,x1) &
        z in rng renameElementsDistinctlyFunc(f,x2) by A3, XBOOLE_0:def 4;
      then consider y1 being object such that
        A5: y1 in f.x1 & z = [f,x1,y1] by A2, Th79;
      consider y2 being object such that
        A6: y2 in f.x2 & z = [f,x2,y2] by A2, A4, Th79;
      thus contradiction by A1, A5, A6, XTUPLE_0:3;
    end;
    hence thesis by XBOOLE_0:def 7;
  end;
  suppose not x1 in dom f or not x2 in dom f;
    then f.x1 = {} or f.x2 = {} by FUNCT_1:def 2;
    then renameElementsDistinctlyFunc(f,x1) = {} or
      renameElementsDistinctlyFunc(f,x2) = {};
    then rng renameElementsDistinctlyFunc(f,x1) = {} or
      rng renameElementsDistinctlyFunc(f,x2) = {};
    hence thesis by XBOOLE_1:65;
  end;
end;

registration
  let f be Function, x be object;
  cluster renameElementsDistinctlyFunc(f,x) -> one-to-one;
  coherence;
end;

registration
  let f be empty Function, x be object;
  cluster renameElementsDistinctlyFunc(f,x) -> empty;
  coherence;
end;

registration
  let f be non empty non-empty Function, x be Element of dom f;
  cluster renameElementsDistinctlyFunc(f,x) -> non empty;
  coherence
  proof
    [: {[f,x]}, f.x :] is non empty;
    then rng renameElementsDistinctlyFunc(f,x) is non empty by Th80;
    hence thesis;
  end;
end;

registration
  let F be non empty Graph-yielding Function, x be Element of dom F;
  cluster renameElementsDistinctlyFunc(the_Vertices_of F,x)
    -> non empty (the_Vertices_of (F.x))-defined;
  coherence
  proof
    reconsider x0 = x as Element of dom the_Vertices_of F by Def4;
    renameElementsDistinctlyFunc(the_Vertices_of F,x0) is non empty;
    hence renameElementsDistinctlyFunc(the_Vertices_of F,x) is non empty;
    (the_Vertices_of F).x = (the_Vertices_of (F.x)) by Def8;
    hence thesis;
  end;
  cluster renameElementsDistinctlyFunc(the_Edges_of F,x)
    -> (the_Edges_of (F.x))-defined;
  coherence
  proof
    (the_Edges_of F).x = (the_Edges_of (F.x)) by Def9;
    hence thesis;
  end;
end;

registration
  let F be non empty Graph-yielding Function, x be Element of dom F;
  cluster renameElementsDistinctlyFunc(the_Vertices_of F,x)
    -> total for (the_Vertices_of (F.x))-defined Function;
  coherence
  proof
    (the_Vertices_of F).x = (the_Vertices_of (F.x)) by Def8;
    hence thesis;
  end;
  cluster renameElementsDistinctlyFunc(the_Edges_of F,x)
    -> total for (the_Edges_of (F.x))-defined Function;
  coherence
  proof
    (the_Edges_of F).x = (the_Edges_of (F.x)) by Def9;
    hence thesis;
  end;
end;

definition
  let F be non empty Graph-yielding Function;
  :: canonical distinction of the graph yielding function
  func canGFDistinction(F) -> Graph-yielding Function means
  :Def25:
  dom it = dom F & for x being Element of dom F holds
    it.x = replaceVerticesEdges(
      renameElementsDistinctlyFunc(the_Vertices_of F,x),
      renameElementsDistinctlyFunc(the_Edges_of F,x));
  existence
  proof
    deffunc G(object) = replaceVerticesEdges(
      renameElementsDistinctlyFunc(the_Vertices_of F,In($1,dom F)),
      renameElementsDistinctlyFunc(the_Edges_of F,In($1,dom F)));
    consider g being Function such that
      A1: dom g = dom F and
      A2: for x being Element of dom F holds g.x = G(x) from FUNCT_1:sch 4;
    now
      let x be object;
      assume x in dom g;
      then g.x = G(x) by A1, A2;
      hence g.x is _Graph;
    end;
    then reconsider g as Graph-yielding Function by GLIB_000:def 53;
    take g;
    thus dom g = dom F by A1;
    let x be Element of dom F;
    In(x,dom F) = x;
    hence g.x = replaceVerticesEdges(
        renameElementsDistinctlyFunc(the_Vertices_of F,x),
        renameElementsDistinctlyFunc(the_Edges_of F,x)) by A2;
  end;
  uniqueness
  proof
    let G1, G2 be Graph-yielding Function;
    assume that
      A3: dom G1 = dom F & for x being Element of dom F holds
        G1.x = replaceVerticesEdges(
          renameElementsDistinctlyFunc(the_Vertices_of F,x),
          renameElementsDistinctlyFunc(the_Edges_of F,x)) and
      A4: dom G2 = dom F & for x being Element of dom F holds
        G2.x = replaceVerticesEdges(
          renameElementsDistinctlyFunc(the_Vertices_of F,x),
          renameElementsDistinctlyFunc(the_Edges_of F,x));
    now
      let z be object;
      assume z in dom G1;
      then reconsider x = z as Element of dom F by A3;
      thus G1.z = replaceVerticesEdges(
          renameElementsDistinctlyFunc(the_Vertices_of F,x),
          renameElementsDistinctlyFunc(the_Edges_of F,x)) by A3
        .= G2.z by A4;
    end;
    hence thesis by A3, A4, FUNCT_1:2;
  end;
end;

registration
  let F be non empty Graph-yielding Function;
  cluster canGFDistinction(F) -> non empty;
  coherence
  proof
    dom F = dom canGFDistinction(F) by Def25;
    hence canGFDistinction(F) is non empty;
  end;
end;

registration
  let F be non empty Graph-yielding Function;
  cluster canGFDistinction(F) -> plain;
  coherence
  proof
    now
      let x9 be Element of dom canGFDistinction F;
      reconsider x = x9 as Element of dom F by Def25;
      (canGFDistinction F).x = replaceVerticesEdges(
        renameElementsDistinctlyFunc(the_Vertices_of F,x),
        renameElementsDistinctlyFunc(the_Edges_of F,x)) by Def25;
      hence (canGFDistinction F).x9 is plain;
    end;
    hence thesis by GLIBPRE0:def 2;
  end;
end;

theorem Th83:
  for F being non empty Graph-yielding Function, x being Element of dom F
  holds (the_Vertices_of canGFDistinction F).x
    = [: {[the_Vertices_of F,x]}, (the_Vertices_of F).x :]
proof
  let F be non empty Graph-yielding Function, x be Element of dom F;
  reconsider x9 = x as Element of dom canGFDistinction F by Def25;
  thus (the_Vertices_of canGFDistinction F).x
     = the_Vertices_of ((canGFDistinction F).x9) by Def8
    .= the_Vertices_of replaceVerticesEdges(
        renameElementsDistinctlyFunc(the_Vertices_of F,x),
        renameElementsDistinctlyFunc(the_Edges_of F,x)) by Def25
    .= rng renameElementsDistinctlyFunc(the_Vertices_of F,x) by Th1
    .= [: {[the_Vertices_of F,x]}, (the_Vertices_of F).x :] by Th80;
end;

theorem Th84:
  for F being non empty Graph-yielding Function, x being Element of dom F
  holds (the_Edges_of canGFDistinction F).x
    = [: {[the_Edges_of F,x]}, (the_Edges_of F).x :]
proof
  let F be non empty Graph-yielding Function, x be Element of dom F;
  reconsider x9 = x as Element of dom canGFDistinction F by Def25;
  thus (the_Edges_of canGFDistinction F).x
     = the_Edges_of ((canGFDistinction F).x9) by Def9
    .= the_Edges_of replaceVerticesEdges(
        renameElementsDistinctlyFunc(the_Vertices_of F,x),
        renameElementsDistinctlyFunc(the_Edges_of F,x)) by Def25
    .= rng renameElementsDistinctlyFunc(the_Edges_of F,x) by Th1
    .= [: {[the_Edges_of F,x]}, (the_Edges_of F).x :] by Th80;
end;

registration
  let F be non empty Graph-yielding Function;
  cluster canGFDistinction(F) -> vertex-disjoint edge-disjoint;
  coherence
  proof
    now
      let x1, x2 be Element of dom canGFDistinction F;
      x1 in dom canGFDistinction F & x2 in dom canGFDistinction F;
      then A1: x1 in dom F & x2 in dom F by Def25;
      assume A2: x1 <> x2;
      A3: (the_Vertices_of canGFDistinction F).x1
         = [: {[the_Vertices_of F,x1]}, (the_Vertices_of F).x1 :] by A1, Th83
        .= rng renameElementsDistinctlyFunc(the_Vertices_of F,x1) by Th80;
      (the_Vertices_of canGFDistinction F).x2
         = [: {[the_Vertices_of F,x2]}, (the_Vertices_of F).x2 :] by A1, Th83
        .= rng renameElementsDistinctlyFunc(the_Vertices_of F,x2) by Th80;
      hence (the_Vertices_of canGFDistinction F).x1 misses
        (the_Vertices_of canGFDistinction F).x2 by A2, A3, Th82;
    end;
    hence canGFDistinction(F) is vertex-disjoint by Th70;
    now
      let x1, x2 be Element of dom canGFDistinction F;
      x1 in dom canGFDistinction F & x2 in dom canGFDistinction F;
      then A4: x1 in dom F & x2 in dom F by Def25;
      assume A5: x1 <> x2;
      A6: (the_Edges_of canGFDistinction F).x1
         = [: {[the_Edges_of F,x1]}, (the_Edges_of F).x1 :] by A4, Th84
        .= rng renameElementsDistinctlyFunc(the_Edges_of F,x1) by Th80;
      (the_Edges_of canGFDistinction F).x2
         = [: {[the_Edges_of F,x2]}, (the_Edges_of F).x2 :] by A4, Th84
        .= rng renameElementsDistinctlyFunc(the_Edges_of F,x2) by Th80;
      hence (the_Edges_of canGFDistinction F).x1 misses
        (the_Edges_of canGFDistinction F).x2 by A5, A6, Th82;
    end;
    hence canGFDistinction(F) is edge-disjoint by Th71;
  end;
end;

theorem Th85:
  for F being non empty Graph-yielding Function, x being Element of dom F
  for x9 being Element of dom canGFDistinction F st x = x9
  ex G being PGraphMapping of F.x,(canGFDistinction F).x9
  st G_V = renameElementsDistinctlyFunc(the_Vertices_of F,x) &
    G_E = renameElementsDistinctlyFunc(the_Edges_of F,x) &
    G is Disomorphism
proof
  let F be non empty Graph-yielding Function, x be Element of dom F;
  let x9 be Element of dom canGFDistinction F;
  assume x = x9;
  then (canGFDistinction F).x9
     = replaceVerticesEdges(
        renameElementsDistinctlyFunc(the_Vertices_of F,x),
        renameElementsDistinctlyFunc(the_Edges_of F,x)) by Def25;
  hence thesis by Th16;
end;

theorem Th86:
  for F being non empty Graph-yielding Function, x being Element of dom F
  for x9 being Element of dom canGFDistinction F st x = x9
  holds (canGFDistinction F).x9 is F.x-Disomorphic
proof
  let F be non empty Graph-yielding Function, x be Element of dom F;
  let x9 be Element of dom canGFDistinction F;
  assume x = x9;
  then consider G being PGraphMapping of F.x,(canGFDistinction F).x9 such that
    G_V = renameElementsDistinctlyFunc(the_Vertices_of F,x) &
    G_E = renameElementsDistinctlyFunc(the_Edges_of F,x) and
    A1: G is Disomorphism by Th85;
  thus thesis by A1, GLIB_010:def 24;
end;

theorem Th87:
  for F being non empty Graph-yielding Function
  holds F,canGFDistinction(F) are_Disomorphic
proof
  let F be non empty Graph-yielding Function;
  A1: dom F = dom canGFDistinction F by Def25;
  for x being Element of dom F, x9 being Element of dom canGFDistinction F
    st x = x9 holds (canGFDistinction F).x9 is F.x-Disomorphic by Th86;
  hence thesis by A1, Th38;
end;

theorem Th88:
  for F1, F2 being non empty Graph-yielding Function st F1, F2 are_Disomorphic
  holds canGFDistinction(F1),canGFDistinction(F2) are_Disomorphic
proof
  let F1, F2 be non empty Graph-yielding Function;
  assume A1: F1,F2 are_Disomorphic;
  canGFDistinction(F1),F1 are_Disomorphic by Th87;
  then A2: canGFDistinction(F1),F2 are_Disomorphic by A1, Th40;
  F2,canGFDistinction(F2) are_Disomorphic by Th87;
  hence thesis by A2, Th40;
end;

theorem Th89:
  for F1, F2 being non empty Graph-yielding Function st F1, F2 are_isomorphic
  holds canGFDistinction(F1),canGFDistinction(F2) are_isomorphic
proof
  let F1, F2 be non empty Graph-yielding Function;
  assume A1: F1,F2 are_isomorphic;
  canGFDistinction(F1),F1 are_isomorphic by Th42, Th87;
  then A2: canGFDistinction(F1),F2 are_isomorphic by A1, Th41;
  F2,canGFDistinction(F2) are_isomorphic by Th42, Th87;
  hence thesis by A2, Th41;
end;

theorem Th90:
  for F being non empty Graph-yielding Function, x being Element of dom F
  for x9 being Element of dom canGFDistinction(F)
  for v,e,w being object st x = x9
  holds e DJoins v,w,F.x implies [the_Edges_of F,x,e] DJoins
    [the_Vertices_of F,x,v],[the_Vertices_of F,x,w],(canGFDistinction F).x9
proof
  let F be non empty Graph-yielding Function, x be Element of dom F;
  let x9 be Element of dom canGFDistinction(F), v,e,w be object;
  assume x = x9;
  then consider G being PGraphMapping of F.x,(canGFDistinction F).x9 such that
    A1: G_V = renameElementsDistinctlyFunc(the_Vertices_of F,x) and
    A2: G_E = renameElementsDistinctlyFunc(the_Edges_of F,x) and
    A3: G is Disomorphism by Th85;
  assume A4: e DJoins v,w,F.x;
  then e Joins v,w,F.x by GLIB_000:16;
  then A5: e in the_Edges_of F.x & v is Vertex of F.x & w is Vertex of F.x
    by GLIB_000:13, GLIB_000:def 13;
  dom G_V = the_Vertices_of(F.x) & dom G_E = the_Edges_of(F.x)
    by A3, GLIB_010:def 11;
  then A6: G_E.e DJoins G_V.v,G_V.w,(canGFDistinction F).x9
    by A3, A4, A5, GLIB_010:def 14;
  dom F = dom the_Vertices_of F & dom F = dom the_Edges_of F by Def4, Def5;
  then A7: x in dom the_Vertices_of F & x in dom the_Edges_of F;
  (the_Vertices_of F).x = the_Vertices_of F.x by Def8;
  then A8: v in (the_Vertices_of F).x & w in (the_Vertices_of F).x by A5;
  e in (the_Edges_of F).x by A5, Def9;
  then [the_Edges_of F,x,e] DJoins G_V.v,G_V.w,(canGFDistinction F).x9
    by A2, A6, A7, Th78;
  then [the_Edges_of F,x,e] DJoins
    [the_Vertices_of F,x,v],G_V.w,(canGFDistinction F).x9
    by A1, A7, A8, Th78;
  hence thesis by A1, A7, A8, Th78;
end;

theorem Th91:
  for F being non empty Graph-yielding Function, x being Element of dom F
  for x9 being Element of dom canGFDistinction(F)
  for v,e,w being object st x = x9
  holds e Joins v,w,F.x implies [the_Edges_of F,x,e] Joins
    [the_Vertices_of F,x,v],[the_Vertices_of F,x,w],(canGFDistinction F).x9
proof
  let F be non empty Graph-yielding Function, x be Element of dom F;
  let x9 be Element of dom canGFDistinction(F), v,e,w be object;
  assume A1: x = x9;
  assume e Joins v,w,F.x;
  then per cases by GLIB_000:16;
  suppose e DJoins v,w,F.x;
    then [the_Edges_of F,x,e] DJoins [the_Vertices_of F,x,v],
      [the_Vertices_of F,x,w],(canGFDistinction F).x9 by A1, Th90;
    hence thesis by GLIB_000:16;
  end;
  suppose e DJoins w,v,F.x;
    then [the_Edges_of F,x,e] DJoins [the_Vertices_of F,x,w],
      [the_Vertices_of F,x,v],(canGFDistinction F).x9 by A1, Th90;
    hence thesis by GLIB_000:16;
  end;
end;

theorem Th92:
  for F being non empty Graph-yielding Function, x being Element of dom F
  for x9 being Element of dom canGFDistinction(F)
  for v9,e9,w9 being object st x = x9 & e9 DJoins v9,w9,(canGFDistinction F).x9
  ex v,e,w being object st e DJoins v,w,F.x &
    e9 = [the_Edges_of F,x,e] & v9 = [the_Vertices_of F,x,v] &
    w9 = [the_Vertices_of F,x,w]
proof
  let F be non empty Graph-yielding Function, x be Element of dom F;
  let x9 be Element of dom canGFDistinction(F), v9,e9,w9 be object;
  assume A1: x = x9;
  then consider G being PGraphMapping of F.x,(canGFDistinction F).x9 such that
    A2: G_V = renameElementsDistinctlyFunc(the_Vertices_of F,x) and
    A3: G_E = renameElementsDistinctlyFunc(the_Edges_of F,x) and
    A4: G is Disomorphism by Th85;
  assume A5: e9 DJoins v9,w9,(canGFDistinction F).x9;
  then A6: e9 Joins v9,w9,(canGFDistinction F).x9 by GLIB_000:16;
  A7: the_Vertices_of (canGFDistinction F).x9
     = (the_Vertices_of canGFDistinction F).x by A1, Def8
    .= [: {[the_Vertices_of F,x]}, (the_Vertices_of F).x :] by Th83
    .= rng renameElementsDistinctlyFunc(the_Vertices_of F,x) by Th80;
  x in dom F;
  then A8: x in dom the_Vertices_of F & x in dom the_Edges_of F by Def4, Def5;
  v9 in the_Vertices_of (canGFDistinction F).x9 by A6, GLIB_000:13;
  then consider v being object such that
    A9: v in (the_Vertices_of F).x & v9 = [the_Vertices_of F,x,v]
    by A7, A8, Th79;
  w9 in the_Vertices_of (canGFDistinction F).x9 by A6, GLIB_000:13;
  then consider w being object such that
    A10: w in (the_Vertices_of F).x & w9 = [the_Vertices_of F,x,w]
    by A7, A8, Th79;
  A11: the_Edges_of (canGFDistinction F).x9
     = (the_Edges_of canGFDistinction F).x by A1, Def9
    .= [: {[the_Edges_of F,x]}, (the_Edges_of F).x :] by Th84
    .= rng renameElementsDistinctlyFunc(the_Edges_of F,x) by Th80;
  e9 in the_Edges_of (canGFDistinction F).x9 by A6, GLIB_000:def 13;
  then consider e being object such that
    A12: e in (the_Edges_of F).x & e9 = [the_Edges_of F,x,e]
    by A8, A11, Th79;
  take v,e,w;
  the_Edges_of(F.x) = (the_Edges_of F).x &
    the_Vertices_of(F.x) = (the_Vertices_of F).x by Def8, Def9;
  then dom G_E = (the_Edges_of F).x & dom G_V = (the_Vertices_of F).x
    by A4, GLIB_010:def 11;
  then A13: e in dom G_E & v in dom G_V & w in dom G_V by A9, A10, A12;
  G_E.e DJoins v9,w9,(canGFDistinction F).x9 by A3, A5, A8, A12, Th78;
  then G_E.e DJoins G_V.v,w9,(canGFDistinction F).x9 by A2, A8, A9, Th78;
  then G_E.e DJoins G_V.v,G_V.w,(canGFDistinction F).x9 by A2, A8, A10, Th78;
  hence e DJoins v,w,F.x by A4, A13, GLIB_010:def 17;
  thus thesis by A9, A10, A12;
end;

theorem Th93:
  for F being non empty Graph-yielding Function, x being Element of dom F
  for x9 being Element of dom canGFDistinction(F)
  for v9,e9,w9 being object st x = x9 & e9 Joins v9,w9,(canGFDistinction F).x9
  ex v,e,w being object st e Joins v,w,F.x &
    e9 = [the_Edges_of F,x,e] & v9 = [the_Vertices_of F,x,v] &
    w9 = [the_Vertices_of F,x,w]
proof
  let F be non empty Graph-yielding Function, x be Element of dom F;
  let x9 be Element of dom canGFDistinction(F), v9,e9,w9 be object;
  assume A1: x = x9 & e9 Joins v9,w9,(canGFDistinction F).x9;
  then per cases by GLIB_000:16;
  suppose e9 DJoins v9,w9,(canGFDistinction F).x9;
    then consider v,e,w being object such that
      A2: e DJoins v,w,F.x & e9 = [the_Edges_of F,x,e] &
        v9 =[the_Vertices_of F,x,v] & w9 =[the_Vertices_of F,x,w] by A1, Th92;
    take v,e,w;
    thus thesis by A2, GLIB_000:16;
  end;
  suppose e9 DJoins w9,v9,(canGFDistinction F).x9;
    then consider w,e,v being object such that
      A3: e DJoins w,v,F.x & e9 = [the_Edges_of F,x,e] &
        w9 =[the_Vertices_of F,x,w] & v9 =[the_Vertices_of F,x,v] by A1, Th92;
    take v,e,w;
    thus thesis by A3, GLIB_000:16;
  end;
end;

registration
  let F be non empty loopless Graph-yielding Function;
  cluster canGFDistinction(F) -> loopless;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non loopless Graph-yielding Function;
  cluster canGFDistinction(F) -> non loopless;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non-multi Graph-yielding Function;
  cluster canGFDistinction(F) -> non-multi;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non non-multi Graph-yielding Function;
  cluster canGFDistinction(F) -> non non-multi;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non-Dmulti Graph-yielding Function;
  cluster canGFDistinction(F) -> non-Dmulti;
  coherence
  proof
    F,canGFDistinction(F) are_Disomorphic by Th87;
    hence thesis by Th49;
  end;
end;

registration
  let F be non empty non non-Dmulti Graph-yielding Function;
  cluster canGFDistinction(F) -> non non-Dmulti;
  coherence
  proof
    F,canGFDistinction(F) are_Disomorphic by Th87;
    hence thesis by Th49;
  end;
end;

registration
  let F be non empty simple Graph-yielding Function;
  cluster canGFDistinction(F) -> simple;
  coherence by Th42, Th87;
end;

registration
  let F be non empty Dsimple Graph-yielding Function;
  cluster canGFDistinction(F) -> Dsimple;
  coherence by Th87;
end;

registration
  let F be non empty acyclic Graph-yielding Function;
  cluster canGFDistinction(F) -> acyclic;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non acyclic Graph-yielding Function;
  cluster canGFDistinction(F) -> non acyclic;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty connected Graph-yielding Function;
  cluster canGFDistinction(F) -> connected;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non connected Graph-yielding Function;
  cluster canGFDistinction(F) -> non connected;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty Tree-like Graph-yielding Function;
  cluster canGFDistinction(F) -> Tree-like;
  coherence by Th42, Th87;
end;

registration
  let F be non empty edgeless Graph-yielding Function;
  cluster canGFDistinction(F) -> edgeless;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non edgeless Graph-yielding Function;
  cluster canGFDistinction(F) -> non edgeless;
  coherence
  proof
    F,canGFDistinction(F) are_isomorphic by Th42, Th87;
    hence thesis by Th48;
  end;
end;

definition
  let F be non empty Graph-yielding Function, z be Element of dom F;
  func canGFDistinction(F,z) -> Graph-yielding Function equals
  canGFDistinction(F) +* (z,F.z | _GraphSelectors);
  coherence
  proof
    now
      let x be object;
      assume x in dom(canGFDistinction(F) +* (z,F.z | _GraphSelectors));
      then A1: x in dom canGFDistinction(F) by FUNCT_7:30;
      z in dom F;
      then A2: z in dom canGFDistinction(F) by Def25;
      per cases;
      suppose x = z;
        hence (canGFDistinction(F) +* (z,F.z | _GraphSelectors)).x is _Graph
          by A2, FUNCT_7:31;
      end;
      suppose x <> z;
        then (canGFDistinction(F) +* (z,F.z | _GraphSelectors)).x
          = (canGFDistinction F).x by FUNCT_7:32;
        hence (canGFDistinction(F) +* (z,F.z | _GraphSelectors)).x is _Graph
          by A1;
      end;
    end;
    hence thesis by GLIB_000:def 53;
  end;
end;

registration
  let F be non empty Graph-yielding Function, z be Element of dom F;
  cluster canGFDistinction(F,z) -> non empty;
  coherence;
end;

theorem Th94:
  for F being non empty Graph-yielding Function, z being Element of dom F
  holds dom F = dom canGFDistinction(F,z)
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  thus dom F = dom canGFDistinction F by Def25
    .= dom canGFDistinction(F,z) by FUNCT_7:30;
end;

theorem Th95:
  for F being non empty Graph-yielding Function, z being Element of dom F
  for G being Graph-yielding Function
  holds G = canGFDistinction(F,z) iff dom G = dom F &
      G.z = F.z | _GraphSelectors &
    for x being Element of dom F st x <> z
    holds G.x = replaceVerticesEdges(
      renameElementsDistinctlyFunc(the_Vertices_of F,x),
      renameElementsDistinctlyFunc(the_Edges_of F,x))
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  let G be Graph-yielding Function;
  z in dom F;
  then A1: z in dom canGFDistinction(F) by Def25;
  hereby
    assume A2: G = canGFDistinction(F,z);
    hence dom G = dom canGFDistinction(F) by FUNCT_7:30
      .= dom F by Def25;
    thus G.z = F.z | _GraphSelectors by A1, A2, FUNCT_7:31;
    let x be Element of dom F;
    assume A3: x <> z;
    thus G.x = (canGFDistinction F).x by A2, A3, FUNCT_7:32
      .= replaceVerticesEdges(
        renameElementsDistinctlyFunc(the_Vertices_of F,x),
        renameElementsDistinctlyFunc(the_Edges_of F,x)) by Def25;
  end;
  assume that
    A4: dom G = dom F & G.z = F.z | _GraphSelectors and
    A5: for x being Element of dom F st x <> z
      holds G.x = replaceVerticesEdges(
        renameElementsDistinctlyFunc(the_Vertices_of F,x),
        renameElementsDistinctlyFunc(the_Edges_of F,x));
  A6: dom G = dom canGFDistinction F by A4, Def25
    .= dom canGFDistinction(F,z) by FUNCT_7:30;
  for x being object st x in dom G holds G.x = canGFDistinction(F,z).x
  proof
    let x be object;
    assume A7: x in dom G;
    per cases;
    suppose x = z;
      hence G.x = canGFDistinction(F,z).x by A1, A4, FUNCT_7:31;
    end;
    suppose A8: x <> z;
      reconsider x0 = x as Element of dom F by A4, A7;
      thus G.x = replaceVerticesEdges(
          renameElementsDistinctlyFunc(the_Vertices_of F,x0),
          renameElementsDistinctlyFunc(the_Edges_of F,x0)) by A5, A8
        .= (canGFDistinction F).x by Def25
        .= canGFDistinction(F,z).x by A8, FUNCT_7:32;
    end;
  end;
  hence thesis by A6, FUNCT_1:2;
end;

theorem Th96:
  for F being non empty Graph-yielding Function, z being Element of dom F
  holds canGFDistinction(F,z).z = F.z | _GraphSelectors
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  dom F = dom canGFDistinction F by Def25;
  hence canGFDistinction(F,z).z = F.z | _GraphSelectors by FUNCT_7:31;
end;

registration
  let F being non empty Graph-yielding Function, z being Element of dom F;
  cluster canGFDistinction(F,z) -> plain;
  coherence
  proof
    now
      let x9 be Element of dom canGFDistinction(F,z);
      per cases;
      suppose A1: x9 <> z;
        x9 in dom canGFDistinction(F,z);
        then x9 in dom F by Th94;
        then reconsider x = x9 as Element of dom canGFDistinction F by Def25;
        canGFDistinction(F,z).x9 = (canGFDistinction F).x by A1, FUNCT_7:32;
        hence canGFDistinction(F,z).x9 is plain;
      end;
      suppose x9 = z;
        hence canGFDistinction(F,z).x9 is plain by Th96;
      end;
    end;
    hence thesis by GLIBPRE0:def 2;
  end;
end;

theorem Th97:
  for F being non empty Graph-yielding Function, z being Element of dom F
  holds (the_Vertices_of canGFDistinction(F,z)).z = (the_Vertices_of F).z
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  A1: F.z == F.z | _GraphSelectors by GLIB_009:9;
  reconsider z9 = z as Element of dom canGFDistinction(F,z) by Th94;
  thus (the_Vertices_of canGFDistinction(F,z)).z
     = the_Vertices_of (canGFDistinction(F,z).z9) by Def8
    .= the_Vertices_of (F.z | _GraphSelectors) by Th96
    .= the_Vertices_of (F.z) by A1, GLIB_000:def 34
    .= (the_Vertices_of F).z by Def8;
end;

theorem Th98:
  for F being non empty Graph-yielding Function, x,z being Element of dom F
  st x <> z holds (the_Vertices_of canGFDistinction(F,z)).x
    = (the_Vertices_of canGFDistinction F).x
proof
  let F be non empty Graph-yielding Function, x,z be Element of dom F;
  assume A1: x <> z;
  reconsider x1 = x as Element of dom canGFDistinction(F) by Def25;
  reconsider x2 = x as Element of dom canGFDistinction(F,z) by Th95;
  thus (the_Vertices_of canGFDistinction(F,z)).x
     = the_Vertices_of(canGFDistinction(F,z).x2) by Def8
    .= the_Vertices_of((canGFDistinction F).x1) by A1, FUNCT_7:32
    .= (the_Vertices_of canGFDistinction F).x by Def8;
end;

theorem
  for F being non empty Graph-yielding Function, z being Element of dom F
  holds the_Vertices_of canGFDistinction(F,z)
    = (the_Vertices_of canGFDistinction F) +* (z, the_Vertices_of (F.z))
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  A1: dom the_Vertices_of canGFDistinction(F,z)
     = dom canGFDistinction(F,z) by Def4
    .= dom canGFDistinction(F) by FUNCT_7:30;
  then A2: dom the_Vertices_of canGFDistinction(F,z)
     = dom the_Vertices_of canGFDistinction(F) by Def4
    .= dom((the_Vertices_of canGFDistinction F) +* (z, the_Vertices_of (F.z)))
      by FUNCT_7:30;
  now
    let x be object;
    assume x in dom the_Vertices_of canGFDistinction(F,z);
    then reconsider x0 = x as Element of dom F by A1, Def25;
    per cases;
    suppose A3: x = z;
      z in dom F;
      then z in dom canGFDistinction(F) by Def25;
      then A4: z in dom the_Vertices_of canGFDistinction F by Def4;
      thus (the_Vertices_of canGFDistinction(F,z)).x
         = (the_Vertices_of F).z by A3, Th97
        .= the_Vertices_of (F.z) by Def8
        .= ((the_Vertices_of canGFDistinction F)+*(z,the_Vertices_of (F.z))).x
          by A3, A4, FUNCT_7:31;
    end;
    suppose A5: x <> z;
      hence (the_Vertices_of canGFDistinction(F,z)).x
         = (the_Vertices_of canGFDistinction F).x0 by Th98
        .= ((the_Vertices_of canGFDistinction F)+*(z,the_Vertices_of (F.z))).x
          by A5, FUNCT_7:32;
    end;
  end;
  hence thesis by A2, FUNCT_1:2;
end;

theorem Th100:
  for F being non empty Graph-yielding Function, z being Element of dom F
  holds (the_Edges_of canGFDistinction(F,z)).z = (the_Edges_of F).z
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  A1: F.z == F.z | _GraphSelectors by GLIB_009:9;
  reconsider z9 = z as Element of dom canGFDistinction(F,z) by Th94;
  thus (the_Edges_of canGFDistinction(F,z)).z
     = the_Edges_of (canGFDistinction(F,z).z9) by Def9
    .= the_Edges_of (F.z | _GraphSelectors) by Th96
    .= the_Edges_of (F.z) by A1, GLIB_000:def 34
    .= (the_Edges_of F).z by Def9;
end;

theorem Th101:
  for F being non empty Graph-yielding Function, x,z being Element of dom F
  st x <> z holds (the_Edges_of canGFDistinction(F,z)).x
    = (the_Edges_of canGFDistinction F).x
proof
  let F be non empty Graph-yielding Function, x,z be Element of dom F;
  assume A1: x <> z;
  reconsider x1 = x as Element of dom canGFDistinction(F) by Def25;
  reconsider x2 = x as Element of dom canGFDistinction(F,z) by Th95;
  thus (the_Edges_of canGFDistinction(F,z)).x
     = the_Edges_of(canGFDistinction(F,z).x2) by Def9
    .= the_Edges_of((canGFDistinction F).x1) by A1, FUNCT_7:32
    .= (the_Edges_of canGFDistinction F).x by Def9;
end;

theorem
  for F being non empty Graph-yielding Function, z being Element of dom F
  holds (the_Edges_of canGFDistinction(F,z))
    = (the_Edges_of canGFDistinction F) +* (z, the_Edges_of (F.z))
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  A1: dom the_Edges_of canGFDistinction(F,z)
     = dom canGFDistinction(F,z) by Def5
    .= dom canGFDistinction(F) by FUNCT_7:30;
  then A2: dom the_Edges_of canGFDistinction(F,z)
     = dom the_Edges_of canGFDistinction(F) by Def5
    .= dom((the_Edges_of canGFDistinction F) +* (z, the_Edges_of (F.z)))
      by FUNCT_7:30;
  now
    let x be object;
    assume x in dom the_Edges_of canGFDistinction(F,z);
    then reconsider x0 = x as Element of dom F by A1, Def25;
    per cases;
    suppose A3: x = z;
      z in dom F;
      then z in dom canGFDistinction(F) by Def25;
      then A4: z in dom the_Edges_of canGFDistinction F by Def5;
      thus (the_Edges_of canGFDistinction(F,z)).x
         = (the_Edges_of F).z by A3, Th100
        .= the_Edges_of (F.z) by Def9
        .= ((the_Edges_of canGFDistinction F)+*(z,the_Edges_of (F.z))).x
          by A3, A4, FUNCT_7:31;
    end;
    suppose A5: x <> z;
      hence (the_Edges_of canGFDistinction(F,z)).x
         = (the_Edges_of canGFDistinction F).x0 by Th101
        .= ((the_Edges_of canGFDistinction F)+*(z,the_Edges_of (F.z))).x
          by A5, FUNCT_7:32;
    end;
  end;
  hence thesis by A2, FUNCT_1:2;
end;

Lm4:
  for F being non empty Graph-yielding Function, x,y being Element of dom F
  holds [: {[the_Vertices_of F,x]}, (the_Vertices_of F).x :]
    misses the_Vertices_of (F.y)
proof
  let F be non empty Graph-yielding Function, x,y being Element of dom F;
  [:{[the_Vertices_of F,x]},(the_Vertices_of F).x :]/\the_Vertices_of(F.y) = {}
  proof
    assume A1: [: {[the_Vertices_of F,x]}, (the_Vertices_of F).x :]
      /\ the_Vertices_of (F.y) <> {};
    set z = the Element of [: {[the_Vertices_of F,x]}, (the_Vertices_of F).x :]
      /\ the_Vertices_of (F.y);
    A2: z in [: {[the_Vertices_of F,x]}, (the_Vertices_of F).x :] &
      z in the_Vertices_of (F.y) by A1, XBOOLE_0:def 4;
    then consider a,b being object such that
      A3: a in {[the_Vertices_of F,x]} & b in (the_Vertices_of F).x & z=[a,b]
        by ZFMISC_1:def 2;
    A4: a = [the_Vertices_of F, x] by A3, TARSKI:def 1;
    reconsider Z = z, A = a, M = [y,the_Vertices_of (F.y)] as set by TARSKI:1;
    A5: the_Vertices_of (F.y) in {y,the_Vertices_of (F.y)} by TARSKI:def 2;
    {y,the_Vertices_of (F.y)} in {{y,the_Vertices_of (F.y)},{y}}
      by TARSKI:def 2;
    then A6: {y,the_Vertices_of (F.y)} in M by TARSKI:def 5;
    A7: the_Vertices_of (F.y) = (the_Vertices_of F).y by Def8;
    dom F = dom the_Vertices_of F by Def4;
    then A8: [y,the_Vertices_of (F.y)] in the_Vertices_of F by A7, FUNCT_1:1;
    A9: the_Vertices_of F in {the_Vertices_of F} by TARSKI:def 1;
    {the_Vertices_of F} in {{the_Vertices_of F,x},{the_Vertices_of F}}
      by TARSKI:def 2;
    then A10: {the_Vertices_of F} in A by A4, TARSKI:def 5;
    A11: a in {a} by A3, A4;
    {a} in {{a,b},{a}} by TARSKI:def 2;
    then A12: {a} in Z by A3, TARSKI:def 5;
    thus contradiction by A2, A5, A6, A8, A9, A10, A11, A12, GLIBPRE1:2;
  end;
  hence thesis by XBOOLE_0:def 7;
end;

Lm5:
  for F being non empty Graph-yielding Function, x,y being Element of dom F
  holds [: {[the_Edges_of F,x]}, (the_Edges_of F).x :]
    misses the_Edges_of (F.y)
proof
  let F be non empty Graph-yielding Function, x,y being Element of dom F;
  [: {[the_Edges_of F,x]}, (the_Edges_of F).x :] /\ the_Edges_of(F.y) = {}
  proof
    assume A1: [: {[the_Edges_of F,x]}, (the_Edges_of F).x :]
      /\ the_Edges_of (F.y) <> {};
    set z = the Element of [: {[the_Edges_of F,x]}, (the_Edges_of F).x :]
      /\ the_Edges_of (F.y);
    A2: z in [: {[the_Edges_of F,x]}, (the_Edges_of F).x :] &
      z in the_Edges_of (F.y) by A1, XBOOLE_0:def 4;
    then consider a,b being object such that
      A3: a in {[the_Edges_of F,x]} & b in (the_Edges_of F).x & z=[a,b]
        by ZFMISC_1:def 2;
    A4: a = [the_Edges_of F, x] by A3, TARSKI:def 1;
    reconsider Z = z, A = a, M = [y,the_Edges_of (F.y)] as set by TARSKI:1;
    A5: the_Edges_of (F.y) in {y,the_Edges_of (F.y)} by TARSKI:def 2;
    {y,the_Edges_of (F.y)} in {{y,the_Edges_of (F.y)},{y}}
      by TARSKI:def 2;
    then A6: {y,the_Edges_of (F.y)} in M by TARSKI:def 5;
    A7: the_Edges_of (F.y) = (the_Edges_of F).y by Def9;
    dom F = dom the_Edges_of F by Def5;
    then A8: [y,the_Edges_of (F.y)] in the_Edges_of F by A7, FUNCT_1:1;
    A9: the_Edges_of F in {the_Edges_of F} by TARSKI:def 1;
    {the_Edges_of F} in {{the_Edges_of F,x},{the_Edges_of F}}
      by TARSKI:def 2;
    then A10: {the_Edges_of F} in A by A4, TARSKI:def 5;
    A11: a in {a} by A3, A4;
    {a} in {{a,b},{a}} by TARSKI:def 2;
    then A12: {a} in Z by A3, TARSKI:def 5;
    thus contradiction by A2, A5, A6, A8, A9, A10, A11, A12, GLIBPRE1:2;
  end;
  hence thesis by XBOOLE_0:def 7;
end;

registration
  let F be non empty Graph-yielding Function, z being Element of dom F;
  cluster canGFDistinction(F,z) -> vertex-disjoint edge-disjoint;
  coherence
  proof
    now
      set G = canGFDistinction F, H = canGFDistinction(F,z);
      let y1,y2 be Element of dom H;
      y1 in dom H & y2 in dom H;
      then A1: y1 in dom G & y2 in dom G by FUNCT_7:30;
      then reconsider x1=y1, x2=y2 as Element of dom F by Def25;
      assume A2: y1 <> y2;
      per cases;
      suppose A3: x1 <> z & x2 <> z;
        A4: (the_Vertices_of G).x1 misses (the_Vertices_of G).x2 &
          (the_Edges_of G).x1 misses (the_Edges_of G).x2 by A1, A2, Th73;
        then (the_Vertices_of H).x1 misses (the_Vertices_of G).x2 by A3, Th98;
        hence (the_Vertices_of H).y1 misses (the_Vertices_of H).y2 by A3, Th98
;
        (the_Edges_of H).x1 misses (the_Edges_of G).x2 by A3, A4, Th101;
        hence (the_Edges_of H).y1 misses (the_Edges_of H).y2 by A3, Th101;
      end;
      suppose A5: x1 = z;
        then A6: (the_Vertices_of H).x1 = (the_Vertices_of F).x1 by Th97
          .= the_Vertices_of (F.x1) by Def8;
        (the_Vertices_of H).x2 = (the_Vertices_of G).x2 by A2, A5, Th98
          .= [: {[the_Vertices_of F,x2]}, (the_Vertices_of F).x2 :] by Th83;
        hence (the_Vertices_of H).y1 misses (the_Vertices_of H).y2 by A6, Lm4;
        A7: (the_Edges_of H).x1 = (the_Edges_of F).x1 by A5, Th100
          .= the_Edges_of (F.x1) by Def9;
        (the_Edges_of H).x2 = (the_Edges_of G).x2 by A2, A5, Th101
          .= [: {[the_Edges_of F,x2]}, (the_Edges_of F).x2 :] by Th84;
        hence (the_Edges_of H).y1 misses (the_Edges_of H).y2 by A7, Lm5;
      end;
      suppose A8: x2 = z;
        then A9: (the_Vertices_of H).x2 = (the_Vertices_of F).x2 by Th97
          .= the_Vertices_of (F.x2) by Def8;
        (the_Vertices_of H).x1 = (the_Vertices_of G).x1 by A2, A8, Th98
          .= [: {[the_Vertices_of F,x1]}, (the_Vertices_of F).x1 :] by Th83;
        hence (the_Vertices_of H).y1 misses (the_Vertices_of H).y2 by A9, Lm4;
        A10: (the_Edges_of H).x2 = (the_Edges_of F).x2 by A8, Th100
          .= the_Edges_of (F.x2) by Def9;
        (the_Edges_of H).x1 = (the_Edges_of G).x1 by A2, A8, Th101
          .= [: {[the_Edges_of F,x1]}, (the_Edges_of F).x1 :] by Th84;
        hence (the_Edges_of H).y1 misses (the_Edges_of H).y2 by A10, Lm5;
      end;
    end;
    hence thesis by Th73;
  end;
end;

theorem Th103:
  for F being non empty Graph-yielding Function, x,z being Element of dom F
  for x9 being Element of dom canGFDistinction(F,z) st x <> z & x = x9
  ex G being PGraphMapping of F.x,(canGFDistinction(F,z)).x9
  st G_V = renameElementsDistinctlyFunc(the_Vertices_of F,x) &
    G_E = renameElementsDistinctlyFunc(the_Edges_of F,x) &
    G is Disomorphism
proof
  let F be non empty Graph-yielding Function, x,z be Element of dom F;
  let x9 be Element of dom canGFDistinction(F,z);
  assume A1: x <> z & x = x9;
  reconsider x8 = x9 as Element of dom canGFDistinction F by FUNCT_7:30;
  consider G0 being PGraphMapping of F.x, (canGFDistinction F).x8 such that
    A2: G0_V = renameElementsDistinctlyFunc(the_Vertices_of F,x) &
      G0_E = renameElementsDistinctlyFunc(the_Edges_of F,x) and
    A3: G0 is Disomorphism by A1, Th85;
  A4: (canGFDistinction F).x8 = canGFDistinction(F,z).x9 by A1, FUNCT_7:32;
  then reconsider G = G0 as PGraphMapping of F.x,(canGFDistinction(F,z)).x9;
  take G;
  thus thesis by A2, A3, A4;
end;

theorem Th104:
  for F being non empty Graph-yielding Function, x,z being Element of dom F
  for x9 being Element of dom canGFDistinction(F,z) st x = x9
  holds (canGFDistinction(F,z)).x9 is F.x-Disomorphic
proof
  let F be non empty Graph-yielding Function, x,z be Element of dom F;
  let x9 be Element of dom canGFDistinction(F,z);
  assume A1: x = x9;
  per cases;
  suppose x = z;
    then canGFDistinction(F,z).x = F.x | _GraphSelectors by Th96;
    hence thesis by A1, GLIB_009:9, GLIBPRE0:78;
  end;
  suppose x <> z;
    then consider G being PGraphMapping of F.x,(canGFDistinction(F,z)).x9
      such that G_V = renameElementsDistinctlyFunc(the_Vertices_of F,x) &
      G_E = renameElementsDistinctlyFunc(the_Edges_of F,x) and
      A2: G is Disomorphism by A1, Th103;
    thus thesis by A2, GLIB_010:def 24;
  end;
end;

theorem Th105:
  for F being non empty Graph-yielding Function, z being Element of dom F
  holds F,canGFDistinction(F,z) are_Disomorphic
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  A1: dom F = dom canGFDistinction F by Def25
    .= dom canGFDistinction(F,z) by FUNCT_7:30;
  for x being Element of dom F, x9 being Element of dom canGFDistinction(F,z)
    st x = x9 holds (canGFDistinction(F,z)).x9 is F.x-Disomorphic by Th104;
  hence thesis by A1, Th38;
end;

theorem Th106:
  for F being non empty Graph-yielding Function, z being Element of dom F
  holds canGFDistinction(F),canGFDistinction(F,z) are_Disomorphic
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  A1: canGFDistinction F, F are_Disomorphic by Th87;
  F, canGFDistinction(F,z) are_Disomorphic by Th105;
  hence thesis by A1, Th40;
end;

theorem
  for F1, F2 being non empty Graph-yielding Function
  for z1 being Element of dom F1, z2 being Element of dom F2
  st F1, F2 are_Disomorphic
  holds canGFDistinction(F1,z1),canGFDistinction(F2,z2) are_Disomorphic
proof
  let F1, F2 be non empty Graph-yielding Function;
  let z1 be Element of dom F1, z2 be Element of dom F2;
  assume A1: F1,F2 are_Disomorphic;
  canGFDistinction(F1,z1), F1 are_Disomorphic by Th105;
  then A2: canGFDistinction(F1,z1), F2 are_Disomorphic by A1, Th40;
  F2, canGFDistinction(F2,z2) are_Disomorphic by Th105;
  hence thesis by A2, Th40;
end;

theorem
  for F being non empty Graph-yielding Function, z being Element of dom F
  for z9 being Element of dom canGFDistinction(F,z)
  for v,e,w being object st z = z9
  holds e DJoins v,w,F.z iff e DJoins v,w,canGFDistinction(F,z).z9
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  let z9 be Element of dom canGFDistinction(F,z), v,e,w be object;
  assume A1: z = z9;
  F.z == F.z | _GraphSelectors by GLIB_009:9;
  then F.z == canGFDistinction(F,z).z9 by A1, Th96;
  hence thesis by GLIB_000:88;
end;

theorem
  for F being non empty Graph-yielding Function, z being Element of dom F
  for z9 being Element of dom canGFDistinction(F,z)
  for v,e,w being object st z = z9
  holds e Joins v,w,F.z iff e Joins v,w,canGFDistinction(F,z).z9
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  let z9 be Element of dom canGFDistinction(F,z), v,e,w be object;
  assume A1: z = z9;
  F.z == F.z | _GraphSelectors by GLIB_009:9;
  then F.z == canGFDistinction(F,z).z9 by A1, Th96;
  hence thesis by GLIB_000:88;
end;

theorem
  for F being non empty Graph-yielding Function, x,z being Element of dom F
  for x9 being Element of dom canGFDistinction(F,z)
  for v,e,w being object st x <> z & x = x9
  holds e DJoins v,w,F.x implies [the_Edges_of F,x,e] DJoins
    [the_Vertices_of F,x,v],[the_Vertices_of F,x,w],(canGFDistinction(F,z)).x9
proof
  let F be non empty Graph-yielding Function, x,z be Element of dom F;
  let x9 be Element of dom canGFDistinction(F,z), v,e,w be object;
  assume A1: x <> z & x = x9;
  reconsider x8 = x9 as Element of dom canGFDistinction F by FUNCT_7:30;
  (canGFDistinction(F,z)).x9 = (canGFDistinction F).x8 by A1, FUNCT_7:32;
  hence thesis by A1, Th90;
end;

theorem
  for F being non empty Graph-yielding Function, x,z being Element of dom F
  for x9 being Element of dom canGFDistinction(F,z)
  for v,e,w being object st x <> z & x = x9
  holds e Joins v,w,F.x implies [the_Edges_of F,x,e] Joins
    [the_Vertices_of F,x,v],[the_Vertices_of F,x,w],(canGFDistinction(F,z)).x9
proof
  let F be non empty Graph-yielding Function, x,z be Element of dom F;
  let x9 be Element of dom canGFDistinction(F,z), v,e,w be object;
  assume A1: x <> z & x = x9;
  reconsider x8 = x9 as Element of dom canGFDistinction F by FUNCT_7:30;
  (canGFDistinction(F,z)).x9 = (canGFDistinction F).x8 by A1, FUNCT_7:32;
  hence thesis by A1, Th91;
end;

theorem
  for F being non empty Graph-yielding Function, x,z being Element of dom F
  for x9 being Element of dom canGFDistinction(F,z)
  for v9,e9,w9 being object
  st x <> z & x = x9 & e9 DJoins v9,w9,(canGFDistinction(F,z)).x9
  ex v,e,w being object st e DJoins v,w,F.x &
    e9 = [the_Edges_of F,x,e] & v9 = [the_Vertices_of F,x,v] &
    w9 = [the_Vertices_of F,x,w]
proof
  let F be non empty Graph-yielding Function, x,z be Element of dom F;
  let x9 be Element of dom canGFDistinction(F,z), v9,e9,w9 be object;
  assume A1: x <> z & x = x9 & e9 DJoins v9,w9,(canGFDistinction(F,z)).x9;
  reconsider x8 = x9 as Element of dom canGFDistinction F by FUNCT_7:30;
  (canGFDistinction(F,z)).x9 = (canGFDistinction F).x8 by A1, FUNCT_7:32;
  hence thesis by A1, Th92;
end;

theorem
  for F being non empty Graph-yielding Function, x,z being Element of dom F
  for x9 being Element of dom canGFDistinction(F,z)
  for v9,e9,w9 being object
  st x <> z & x = x9 & e9 Joins v9,w9,(canGFDistinction(F,z)).x9
  ex v,e,w being object st e Joins v,w,F.x &
    e9 = [the_Edges_of F,x,e] & v9 = [the_Vertices_of F,x,v] &
    w9 = [the_Vertices_of F,x,w]
proof
  let F be non empty Graph-yielding Function, x,z be Element of dom F;
  let x9 be Element of dom canGFDistinction(F,z), v9,e9,w9 be object;
  assume A1: x <> z & x = x9 & e9 Joins v9,w9,(canGFDistinction(F,z)).x9;
  reconsider x8 = x9 as Element of dom canGFDistinction F by FUNCT_7:30;
  (canGFDistinction(F,z)).x9 = (canGFDistinction F).x8 by A1, FUNCT_7:32;
  hence thesis by A1, Th93;
end;

registration
  let F be non empty loopless Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> loopless;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non loopless Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> non loopless;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non-multi Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> non-multi;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non non-multi Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> non non-multi;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non-Dmulti Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> non-Dmulti;
  coherence
  proof
    F,canGFDistinction(F,z) are_Disomorphic by Th105;
    hence thesis by Th49;
  end;
end;

registration
  let F be non empty non non-Dmulti Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> non non-Dmulti;
  coherence
  proof
    F,canGFDistinction(F,z) are_Disomorphic by Th105;
    hence thesis by Th49;
  end;
end;

registration
  let F be non empty simple Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> simple;
  coherence;
end;

registration
  let F be non empty Dsimple Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> Dsimple;
  coherence;
end;

registration
  let F be non empty acyclic Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> acyclic;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non acyclic Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> non acyclic;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty connected Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> connected;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non connected Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> non connected;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty Tree-like Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> Tree-like;
  coherence;
end;

registration
  let F be non empty edgeless Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> edgeless;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

registration
  let F be non empty non edgeless Graph-yielding Function;
  let z be Element of dom F;
  cluster canGFDistinction(F,z) -> non edgeless;
  coherence
  proof
    F,canGFDistinction(F,z) are_isomorphic by Th42, Th105;
    hence thesis by Th48;
  end;
end;

theorem Th114:
  for G2, H being _Graph, F being PGraphMapping of G2, H
  st F is directed weak_SG-embedding
  ex G1 being Supergraph of G2 st G1 is H-Disomorphic
proof
  :: The basic idea is to replace the vertices of edges
  :: in H that correspond to G2 by the actual vertices and edges of G2.
  :: However, H could contain actual vertices and edges of G2 in other places,
  :: so we have to relabel the vertices and edges of H, too.
  let G2, H be _Graph, F be PGraphMapping of G2, H;
  assume A1: F is directed weak_SG-embedding;
  then reconsider F as one-to-one PGraphMapping of G2, H;
  :: construct the vertex map
  set c = the_Vertices_of H --> the_Vertices_of G2;
  set V = <: c, id the_Vertices_of H :> +* F_V";
  A2: dom <: c, id the_Vertices_of H :>
     = dom c /\ dom id the_Vertices_of H by FUNCT_3:def 7
    .= (the_Vertices_of H) /\ the_Vertices_of H;
  dom(F_V") = rng F_V by FUNCT_1:33;
  then A3: dom(F_V") c= the_Vertices_of H;
  A4: dom V = (the_Vertices_of H) \/ dom(F_V") by A2, FUNCT_4:def 1
    .= the_Vertices_of H by A3, XBOOLE_1:12;
  then reconsider V as ManySortedSet of the_Vertices_of H
    by RELAT_1:def 18, PARTFUN1:def 2;
  A5: V is non empty by A4;
  A6: rng(<: c, id the_Vertices_of H :>) /\ rng(F_V") = {}
  proof
    assume A7: rng(<: c, id the_Vertices_of H :>) /\ rng(F_V") <> {};
    set y = the Element of rng(<: c, id the_Vertices_of H :>) /\ rng(F_V");
    reconsider Y = y as set;
    A8: y in rng(<: c, id the_Vertices_of H :>) & y in rng(F_V")
      by A7, XBOOLE_0:def 4;
    then consider x being object such that
      A9: x in dom <: c, id the_Vertices_of H :> and
      A10: <: c, id the_Vertices_of H :>.x = y by FUNCT_1:def 3;
    A11: y = [c.x,(id the_Vertices_of H).x] by A9, A10, FUNCT_3:def 7
      .= [c.x,x] by A9, FUNCT_1:18
      .= [the_Vertices_of G2,x] by A9, FUNCOP_1:7;
    y in dom F_V by A8, FUNCT_1:33;
    then A12: y in the_Vertices_of G2;
    A13: the_Vertices_of G2 in {the_Vertices_of G2} by TARSKI:def 1;
    {the_Vertices_of G2} in {{the_Vertices_of G2,x},{the_Vertices_of G2}}
      by TARSKI:def 2;
    then {the_Vertices_of G2} in Y by A11, TARSKI:def 5;
    hence contradiction by A12, A13, XREGULAR:7;
  end;
  reconsider V as non empty one-to-one ManySortedSet of the_Vertices_of H
    by A5, A6, FUNCT_4:92, XBOOLE_0:def 7;
  :: construct the edge map
  set d = the_Edges_of H --> the_Edges_of G2;
  set E = <: d, id the_Edges_of H :> +* F_E";
  A14: dom <: d, id the_Edges_of H :>
     = dom d /\ dom id the_Edges_of H by FUNCT_3:def 7
    .= (the_Edges_of H) /\ the_Edges_of H;
  dom(F_E") = rng F_E by FUNCT_1:33;
  then A15: dom(F_E") c= the_Edges_of H;
  dom E = (the_Edges_of H) \/ dom(F_E") by A14, FUNCT_4:def 1
    .= the_Edges_of H by A15, XBOOLE_1:12;
  then reconsider E as ManySortedSet of the_Edges_of H
    by RELAT_1:def 18, PARTFUN1:def 2;
  A16: rng(<: d, id the_Edges_of H :>) /\ rng(F_E") = {}
  proof
    assume A17: rng(<: d, id the_Edges_of H :>) /\ rng(F_E") <> {};
    set y = the Element of rng(<: d, id the_Edges_of H :>) /\ rng(F_E");
    reconsider Y = y as set;
    A18: y in rng(<: d, id the_Edges_of H :>) & y in rng(F_E")
      by A17, XBOOLE_0:def 4;
    then consider x being object such that
      A19: x in dom <: d, id the_Edges_of H :> and
      A20: <: d, id the_Edges_of H :>.x = y by FUNCT_1:def 3;
    A21: x in the_Edges_of H by A14, A19;
    A22: y = [d.x,(id the_Edges_of H).x] by A19, A20, FUNCT_3:def 7
      .= [d.x,x] by A21, FUNCT_1:18
      .= [the_Edges_of G2,x] by A21, FUNCOP_1:7;
    A23: y in dom F_E by A18, FUNCT_1:33;
    A24: the_Edges_of G2 in {the_Edges_of G2} by TARSKI:def 1;
    {the_Edges_of G2} in {{the_Edges_of G2,x},{the_Edges_of G2}}
      by TARSKI:def 2;
    then {the_Edges_of G2} in Y by A22, TARSKI:def 5;
    hence contradiction by A23, A24, XREGULAR:7;
  end;
  reconsider E as one-to-one ManySortedSet of the_Edges_of H
    by A16, FUNCT_4:92, XBOOLE_0:def 7;
  :: show that the graph with vertices and edges replaced is a supergraph of G2
  set G1 = replaceVerticesEdges(V,E);
  now
    the_Vertices_of G2 = dom(F_V) by A1, GLIB_010:def 11
      .= rng(F_V") by FUNCT_1:33;
    then the_Vertices_of G2 c= rng V by FUNCT_4:18;
    hence the_Vertices_of G2 c= the_Vertices_of G1 by Th1;
    the_Edges_of G2 = dom(F_E) by A1, GLIB_010:def 11
      .= rng(F_E") by FUNCT_1:33;
    then the_Edges_of G2 c= rng E by FUNCT_4:18;
    hence the_Edges_of G2 c= the_Edges_of G1 by Th1;
    let e be set;
    assume A25: e in the_Edges_of G2;
    then A26: e in dom the_Source_of G2 by FUNCT_2:def 1;
    A27: e in dom the_Target_of G2 by A25, FUNCT_2:def 1;
    A28: e in dom(F_E) by A1, A25, GLIB_010:def 11;
    then A29: e in rng(F_E") by FUNCT_1:33;
    then e in rng E by TARSKI:def 3, FUNCT_4:18;
    then A30: e in dom(E") by FUNCT_1:33;
    A31: dom F_V = dom id rng(F_V") by FUNCT_1:33;
    A32: (the_Source_of G2).e in dom id rng(F_V") by A28, A31, GLIB_010:5;
    A33: (the_Target_of G2).e in dom id rng(F_V") by A28, A31, GLIB_010:5;
    thus (the_Source_of G2).e
       = (id rng(F_V")).((the_Source_of G2).e) by A32, FUNCT_1:18
      .= (V*F_V"").((the_Source_of G2).e) by GLIBPRE1:9
      .= (V*F_V""*(the_Source_of G2)).e by A26, FUNCT_1:13
      .= (V*F_V*(the_Source_of G2)).e by FUNCT_1:43
      .= (V*(F_V*((the_Source_of G2)|the_Edges_of G2))).e by RELAT_1:36
      .= (V*(F_V*((the_Source_of G2)|dom F_E))).e by A1, GLIB_010:def 11
      .= (V*((the_Source_of H)*F_E)).e by A1, GLIB_010:14
      .= ((V*the_Source_of H)*F_E).e by RELAT_1:36
      .= (V*the_Source_of H).(F_E.e) by A28, FUNCT_1:13
      .= (V*the_Source_of H).((F_E")".e) by FUNCT_1:43
      .= (V*the_Source_of H).((E"|rng(F_E")).e) by GLIBPRE1:7
      .= (V*the_Source_of H).(E".e) by A29, FUNCT_1:49
      .= (V*(the_Source_of H)*(E")).e by A30, FUNCT_1:13
      .= (the_Source_of G1).e by Th1;
    thus (the_Target_of G2).e
       = (id rng(F_V")).((the_Target_of G2).e) by A33, FUNCT_1:18
      .= (V*F_V"").((the_Target_of G2).e) by GLIBPRE1:9
      .= (V*F_V""*(the_Target_of G2)).e by A27, FUNCT_1:13
      .= (V*F_V*(the_Target_of G2)).e by FUNCT_1:43
      .= (V*(F_V*((the_Target_of G2)|the_Edges_of G2))).e by RELAT_1:36
      .= (V*(F_V*((the_Target_of G2)|dom F_E))).e by A1, GLIB_010:def 11
      .= (V*((the_Target_of H)*F_E)).e by A1, GLIB_010:14
      .= ((V*the_Target_of H)*F_E).e by RELAT_1:36
      .= (V*the_Target_of H).(F_E.e) by A28, FUNCT_1:13
      .= (V*the_Target_of H).((F_E")".e) by FUNCT_1:43
      .= (V*the_Target_of H).((E"|rng(F_E")).e) by GLIBPRE1:7
      .= (V*the_Target_of H).(E".e) by A29, FUNCT_1:49
      .= (V*(the_Target_of H)*(E")).e by A30, FUNCT_1:13
      .= (the_Target_of G1).e by Th1;
  end;
  then reconsider G1 as Supergraph of G2 by GLIB_006:def 9;
  take G1;
  thus thesis by Th17;
end;

theorem
  for G2, H being _Graph, F being PGraphMapping of G2, H
  st F is weak_SG-embedding ex G1 being Supergraph of G2 st G1 is H-isomorphic
proof
  let G2, H be _Graph, F be PGraphMapping of G2, H;
  assume A1: F is weak_SG-embedding;
  then reconsider F as one-to-one PGraphMapping of G2, H;
  F"_E is one-to-one;
  then consider E being Subset of the_Edges_of G2 such that
    A2: for G4 being reverseEdgeDirections of G2, E
      ex F9 being PGraphMapping of H, G4 st F9 = F" & F9 is directed &
        (F" is non empty  implies F9 is non empty) &
        (F" is total implies F9 is total) &
        (F" is one-to-one implies F9 is one-to-one) &
        (F" is onto implies F9 is onto) &
        (F" is semi-continuous implies F9 is semi-continuous) &
        (F" is continuous implies F9 is continuous) by GLIBPRE0:88;
  set G4 = the reverseEdgeDirections of G2, E;
  consider F9 being PGraphMapping of H, G4 such that
    A3: F9 = F" & F9 is directed and
    (F" is non empty  implies F9 is non empty) &
    (F" is total implies F9 is total) and
     A4: (F" is one-to-one implies F9 is one-to-one) and
     A5: (F" is onto implies F9 is onto) and
    (F" is semi-continuous implies F9 is semi-continuous) &
    (F" is continuous implies F9 is continuous) by A2;
  reconsider F9 as one-to-one PGraphMapping of H, G4 by A4;
  A6: F9 is onto by A1, A5, GLIB_010:71;
  then F9" is total by GLIB_010:72;
  then A7: F9" is weak_SG-embedding;
  F9 is Dcontinuous by A3, A6;
  then F9" is semi-Dcontinuous;
  then consider G3 being Supergraph of G4 such that
    A8: G3 is H-Disomorphic by A7, Th114;
  set G1 = the reverseEdgeDirections of G3, E;
  A9: G2 is reverseEdgeDirections of G4, E by GLIB_007:3;
  the_Edges_of G4 = the_Edges_of G2 by GLIB_007:4;
  then reconsider G1 as Supergraph of G2 by A9, GLIBPRE0:52;
  take G1;
  G1 is G3-isomorphic & G3 is H-isomorphic by A8, GLIBPRE0:80;
  hence thesis;
end;

begin :: The Sum of Graphs

definition
  let F be non empty Graph-yielding Function;
  mode GraphSum of F -> _Graph means
  :Def27:
  ex G9 being GraphUnion of rng canGFDistinction(F) st it is G9-Disomorphic;
  existence
  proof
    take G9 = the GraphUnion of rng canGFDistinction(F);
    G9 is G9-Disomorphic by GLIB_010:53;
    hence thesis;
  end;
end;

theorem Th116:
  for F being non empty Graph-yielding Function, S being GraphSum of F
  for G9 being GraphUnion of rng canGFDistinction(F)
  holds S is G9-Disomorphic
proof
  let F be non empty Graph-yielding Function, S be GraphSum of F;
  let G9 be GraphUnion of rng canGFDistinction(F);
  consider G8 being GraphUnion of rng canGFDistinction(F) such that
    A1: S is G8-Disomorphic by Def27;
  G8 is G9-Disomorphic by GLIB_014:22, GLIBPRE0:78;
  hence thesis by A1;
end;

theorem Th117:
  for F1, F2 being non empty Graph-yielding Function
  for S1 being GraphSum of F1, S2 being GraphSum of F2
  st F1, F2 are_Disomorphic holds S2 is S1-Disomorphic
proof
  let F1, F2 be non empty Graph-yielding Function;
  let S1 be GraphSum of F1, S2 be GraphSum of F2;
  set C1 = canGFDistinction(F1), C2 = canGFDistinction(F2);
  set T1 = (the GraphUnion of rng C1), T2 = the GraphUnion of rng C2;
  assume F1,F2 are_Disomorphic;
  then rng C1, rng C2 are_Disomorphic by Th74, Th88;
  then A1: T2 is T1-Disomorphic by Th55;
  A2: S1 is T1-Disomorphic & S2 is T2-Disomorphic by Th116;
  then T1 is S1-Disomorphic by GLIB_010:96;
  hence thesis by A1, A2;
end;

theorem
  for F1, F2 being non empty Graph-yielding Function
  for S1 being GraphSum of F1, S2 being GraphSum of F2
  st F1, F2 are_isomorphic holds S2 is S1-isomorphic
proof
  let F1, F2 be non empty Graph-yielding Function;
  let S1 be GraphSum of F1, S2 be GraphSum of F2;
  set C1 = canGFDistinction(F1), C2 = canGFDistinction(F2);
  set T1 = (the GraphUnion of rng C1), T2 = the GraphUnion of rng C2;
  assume F1,F2 are_isomorphic;
  then C1, C2 are_isomorphic by Th89;
  then A1: T2 is T1-isomorphic by Th57, Th75;
  A2: S1 is T1-Disomorphic & S2 is T2-Disomorphic by Th116;
  then S1 is T1-isomorphic;
  then T1 is S1-isomorphic by GLIB_010:95;
  hence thesis by A1, A2;
end;

theorem
  for F being non empty Graph-yielding Function, S1, S2 being GraphSum of F
  holds S2 is S1-Disomorphic by Th117;

:: theorem
::   for F, G being non empty Graph-yielding Function, R being GraphUnionSet
::   for S being GraphUnion of R
::   st R = rng G & G,canGFDistinction(F) are_Disomorphic
::   holds S is GraphSum of F;

theorem Th120:
  for x being object, G being _Graph, S being GraphSum of x .--> G
  holds S is G-Disomorphic
proof
  let x be object, G be _Graph, S be GraphSum of x .--> G;
  x in {x} by TARSKI:def 1;
  then x in dom{[x,G]} by RELAT_1:9;
  then reconsider x0 = x as Element of dom(x .--> G) by FUNCT_4:82;
  set H = replaceVerticesEdges(
    renameElementsDistinctlyFunc(the_Vertices_of (x .--> G),x0),
    renameElementsDistinctlyFunc(the_Edges_of (x .--> G),x0));
  A1: (canGFDistinction(x .--> G)).x = H by Def25;
  dom canGFDistinction(x .--> G) = dom (x .--> G) by Def25
    .= dom{[x,G]} by FUNCT_4:82
    .= {x} by RELAT_1:9;
  then canGFDistinction(x .--> G) = x .--> H by A1, DICKSON:1;
  then A2: rng canGFDistinction(x .--> G) = {H} by FUNCOP_1:88;
  consider G9 being GraphUnion of rng canGFDistinction(x .--> G) such that
    A3: S is G9-Disomorphic by Def27;
  H is ((x .--> G).x0)-Disomorphic & (x .--> G).x = G by Th17, FUNCOP_1:72;
  then A4: H is G-Disomorphic;
  G9 == H by A2, GLIB_014:24;
  then G9 is H-Disomorphic by GLIBPRE0:78;
  then G9 is G-Disomorphic by A4;
  hence S is G-Disomorphic by A3;
end;

theorem
  for F being non empty Graph-yielding Function, S being GraphSum of F
  st S is connected
  ex x being object, G being connected _Graph st F = x .--> G
proof
  let F be non empty Graph-yielding Function, S be GraphSum of F;
  assume A1: S is connected;
  consider G9 being GraphUnion of rng canGFDistinction F such that
    A2: S is G9-Disomorphic by Def27;
  consider M being PGraphMapping of G9, S such that
    A3: M is Disomorphism by A2, GLIB_010:def 24;
  G9 is connected by A1, A3, GLIB_010:140;
  then consider H being _Graph such that
    A4: rng canGFDistinction F = {H} by Th59;
  consider x being object such that
    A5: canGFDistinction F = x .--> H by A4, GLIBPRE1:4;
  A6: {x} = dom{[x,H]} by RELAT_1:9
    .= dom canGFDistinction F by A5, FUNCT_4:82
    .= dom F by Def25;
  then reconsider x0 = x as Element of dom F by TARSKI:def 1;
  A7: F = x .--> F.x0 by A6, DICKSON:1;
  then S is F.x0-Disomorphic by Th120;
  then consider M being PGraphMapping of F.x0,S such that
    A8: M is Disomorphism by GLIB_010:def 24;
  reconsider G = F.x0 as connected _Graph by A1, A8, GLIB_010:140;
  take x, G;
  thus thesis by A7;
end;

registration
  let X be non empty set;
  cluster non empty vertex-disjoint edge-disjoint
    for Graph-yielding ManySortedSet of X;
  existence
  proof
    set G = the _Graph, f = canGFDistinction(X --> G);
    A1: dom f = dom(X --> G) by Def25
      .= X;
    then reconsider f as X-defined Function by RELAT_1:def 18;
    reconsider f as Graph-yielding ManySortedSet of X by A1, PARTFUN1:def 2;
    take f;
    thus thesis;
  end;
end;

theorem
  for F being non empty Graph-yielding Function, x being Element of dom F
  for S being GraphSum of F
  ex M being PGraphMapping of F.x,S st M is strong_SG-embedding
proof
  let F be non empty Graph-yielding Function, x be Element of dom F;
  let S be GraphSum of F;
  set C = canGFDistinction F;
  consider G9 being GraphUnion of rng C such that
    A1: S is G9-Disomorphic by Def27;
  consider M1 being PGraphMapping of G9, S such that
    A2: M1 is Disomorphism by A1, GLIB_010:def 24;
  set H = replaceVerticesEdges(
    renameElementsDistinctlyFunc(the_Vertices_of F,x),
    renameElementsDistinctlyFunc(the_Edges_of F,x));
  set V = the_Vertices_of H;
  x in dom F;
  then H = C.x & x in dom C by Def25;
  then H in rng C by FUNCT_1:3;
  then reconsider H as inducedSubgraph of G9, V by Th62;
  A3: M1 | H is strong_SG-embedding by A2, GLIB_010:58;
  H is F.x-Disomorphic by Th17;
  then consider M2 being PGraphMapping of F.x,H such that
    A4: M2 is Disomorphism by GLIB_010:def 24;
  take (M1 | H) * M2;
  thus thesis by A3, A4, GLIB_010:108;
end;

:: This is a possible generalization of the preceeding theorem.
:: :: A graph sum can be divided into its (direct, not isomorphic) parts.
:: theorem
  :: for F1 being non empty Graph-yielding Function, S being GraphSum of F1
  :: ex F2 being non empty vertex-disjoint edge-disjoint
    :: Graph-yielding ManySortedSet of dom F1
  :: st S is GraphUnion of rng F2 &
    :: for x being Element of dom F1 holds F2.x is F1.x-Disomorphic
:: proof
  :: let F1 be non empty Graph-yielding Function, S be GraphSum of F1;
  :: :: construct function from dom F1 to a Disomorphism from F1.x to GFD(F1).x |H1
  :: :: construct function from dom F1 to injection from GFD(F1).x into G9 |H2
  :: :: the Disomorphism from G9 to S |F
  :: :: set F2.x = rng (F*(H2.x)*(H1.x))
  :: :: show F2.x is Disomorphism from F1.x to F2.x
  :: :: show F2 is vertex-disjoint
  :: :: show F2 is edge-disjoint
  :: :: show S is GraphUnion
  :: thus thesis;
:: end;

theorem Th123:
  for F being non empty Graph-yielding Function, z being Element of dom F
  ex S being GraphSum of F st S is Supergraph of F.z &
    S is GraphUnion of rng canGFDistinction(F,z)
proof
  let F be non empty Graph-yielding Function, z be Element of dom F;
  set S = the GraphUnion of rng canGFDistinction(F,z);
  set G9 = the GraphUnion of rng canGFDistinction(F);
  set G0 = F.z | _GraphSelectors;
  canGFDistinction(F), canGFDistinction(F,z) are_Disomorphic by Th106;
  then S is G9-Disomorphic by Th55, Th74;
  then reconsider S as GraphSum of F by Def27;
  take S;
  z in dom F;
  then z in dom canGFDistinction(F,z) by Th94;
  then canGFDistinction(F,z).z in rng canGFDistinction(F,z) by FUNCT_1:3;
  then G0 in rng canGFDistinction(F,z) by Th95;
  then A1: G0 is Subgraph of S by GLIB_014:21;
  G0 == F.z by GLIB_009:9;
  then F.z is Subgraph of S by A1, GLIB_000:92;
  hence thesis by GLIB_006:57;
end;

theorem Th124:
  for F being non empty Graph-yielding Function, S being GraphSum of F holds
    (F is loopless iff S is loopless) &
    (F is non-multi iff S is non-multi) &
    (F is non-Dmulti iff S is non-Dmulti) &
    (F is simple iff S is simple) &
    (F is Dsimple iff S is Dsimple) &
    (F is chordal iff S is chordal) &
    (F is edgeless iff S is edgeless) &
    (F is loopfull iff S is loopfull)
proof
  let F be non empty Graph-yielding Function, S be GraphSum of F;
  consider G9 being GraphUnion of rng canGFDistinction(F) such that
    A1: S is G9-Disomorphic by Def27;
  consider H being PGraphMapping of G9, S such that
    A2: H is Disomorphism by A1, GLIB_010:def 24;
  F, canGFDistinction(F) are_Disomorphic by Th87;
  then A3: F, canGFDistinction(F) are_isomorphic by Th42;
  :: loopless
  thus A4: F is loopless implies S is loopless by A2, GLIB_010:89;
  thus A5: S is loopless implies F is loopless
  proof
    assume S is loopless;
    then G9 is loopless by A2, GLIB_010:89;
    then rng canGFDistinction(F) is loopless by GLIB_014:23;
    hence F is loopless by GLIB_014:3;
  end;
  :: non-multi
  thus A6: F is non-multi implies S is non-multi by A2, GLIB_010:89;
  thus A7: S is non-multi implies F is non-multi
  proof
    assume S is non-multi;
    then G9 is non-multi by A2, GLIB_010:89;
    then rng canGFDistinction(F) is non-multi by Th60;
    hence F is non-multi by GLIB_014:3;
  end;
  :: non-Dmulti
  thus A8: F is non-Dmulti implies S is non-Dmulti by A2, GLIB_010:90;
  thus A9: S is non-Dmulti implies F is non-Dmulti
  proof
    assume S is non-Dmulti;
    then G9 is non-Dmulti by A2, GLIB_010:90;
    then rng canGFDistinction(F) is non-Dmulti by Th60;
    hence F is non-Dmulti by GLIB_014:3;
  end;
  :: simple
  thus F is simple implies S is simple by A4, A6;
  thus S is simple implies F is simple by A5, A7;
  :: Dsimple
  thus F is Dsimple implies S is Dsimple by A4, A8;
  thus S is Dsimple implies F is Dsimple by A5, A9;
  :: chordal
  hereby
    assume F is chordal;
    then canGFDistinction(F) is chordal by A3, Th48;
    then G9 is chordal by Th63;
    hence S is chordal by A2, GLIB_010:140;
  end;
  hereby
    assume S is chordal;
    then G9 is chordal by A2, GLIB_010:140;
    then rng canGFDistinction(F) is chordal by Th63;
    then canGFDistinction(F) is chordal by GLIB_014:3;
    hence F is chordal by A3, Th48;
  end;
  :: edgeless
  thus F is edgeless implies S is edgeless by A2, GLIB_010:89;
  hereby
    assume S is edgeless;
    then G9 is edgeless by A2, GLIB_010:89;
    then rng canGFDistinction(F) is edgeless by GLIB_014:23;
    hence F is edgeless by GLIB_014:3;
  end;
  :: loopfull
  hereby
    assume F is loopfull;
    then canGFDistinction(F) is loopfull by A3, Th48;
    then rng canGFDistinction(F) is loopfull;
    hence S is loopfull by A2, GLIB_012:10;
  end;
  hereby
    assume S is loopfull;
    then G9 is loopfull by A2, GLIB_012:10;
    then rng canGFDistinction(F) is loopfull by Th63;
    then canGFDistinction(F) is loopfull by GLIB_014:3;
    hence F is loopfull by A3, Th48;
  end;
end;

registration
  let F be non empty loopless Graph-yielding Function;
  cluster -> loopless for GraphSum of F;
  coherence by Th124;
end;

registration
  let F be non empty non loopless Graph-yielding Function;
  cluster -> non loopless for GraphSum of F;
  coherence by Th124;
end;

registration
  let F be non empty non-Dmulti Graph-yielding Function;
  cluster -> non-Dmulti for GraphSum of F;
  coherence by Th124;
end;

registration
  let F be non empty non non-Dmulti Graph-yielding Function;
  cluster -> non non-Dmulti for GraphSum of F;
  coherence by Th124;
end;

registration
  let F be non empty non-multi Graph-yielding Function;
  cluster -> non-multi for GraphSum of F;
  coherence by Th124;
end;

registration
  let F be non empty non non-multi Graph-yielding Function;
  cluster -> non non-multi for GraphSum of F;
  coherence by Th124;
end;

registration
  let F be non empty simple Graph-yielding Function;
  cluster -> simple for GraphSum of F;
  coherence;
end;

registration
  let F be non empty Dsimple Graph-yielding Function;
  cluster -> Dsimple for GraphSum of F;
  coherence;
end;

registration
  let F be non empty edgeless Graph-yielding Function;
  cluster -> edgeless for GraphSum of F;
  coherence by Th124;
end;

registration
  let F be non empty non edgeless Graph-yielding Function;
  cluster -> non edgeless for GraphSum of F;
  coherence by Th124;
end;

registration
  let F be non empty loopfull Graph-yielding Function;
  cluster -> loopfull for GraphSum of F;
  coherence by Th124;
end;

registration
  let F be non empty non loopfull Graph-yielding Function;
  cluster -> non loopfull for GraphSum of F;
  coherence by Th124;
end;

theorem Th125:
  for F being non empty Graph-yielding Function, S being GraphSum of F holds
    (F is acyclic iff S is acyclic) &
    (F is chordal iff S is chordal)
proof
  let F be non empty Graph-yielding Function, S be GraphSum of F;
  consider G9 being GraphUnion of rng canGFDistinction(F) such that
    A1: S is G9-Disomorphic by Def27;
  consider H being PGraphMapping of G9, S such that
    A2: H is Disomorphism by A1, GLIB_010:def 24;
  F, canGFDistinction(F) are_Disomorphic by Th87;
  then A3: F, canGFDistinction(F) are_isomorphic by Th42;
  :: acyclic
  thus F is acyclic implies S is acyclic by A2, GLIB_010:140;
  hereby
    assume S is acyclic;
    then G9 is acyclic by A2, GLIB_010:140;
    then rng canGFDistinction(F) is acyclic by Th60;
    hence F is acyclic by GLIB_014:3;
  end;
  :: chordal
  hereby
    assume F is chordal;
    then canGFDistinction(F) is chordal by A3, Th48;
    then G9 is chordal by Th63;
    hence S is chordal by A2, GLIB_010:140;
  end;
  hereby
    assume S is chordal;
    then G9 is chordal by A2, GLIB_010:140;
    then rng canGFDistinction(F) is chordal by Th63;
    then canGFDistinction(F) is chordal by GLIB_014:3;
    hence F is chordal by A3, Th48;
  end;
end;

registration
  let F be non empty acyclic Graph-yielding Function;
  cluster -> acyclic for GraphSum of F;
  coherence by Th125;
end;

registration
  let F be non empty non acyclic Graph-yielding Function;
  cluster -> non acyclic for GraphSum of F;
  coherence by Th125;
end;

theorem
  for F being non empty Graph-yielding Function, S being GraphSum of F
  holds card F c= S.numComponents()
proof
  let F be non empty Graph-yielding Function, S be GraphSum of F;
  consider G9 being GraphUnion of rng canGFDistinction(F) such that
    A1: S is G9-Disomorphic by Def27;
  consider H being PGraphMapping of G9, S such that
    A2: H is Disomorphism by A1, GLIB_010:def 24;
  A3: card F = card dom F by CARD_1:62
    .= card dom canGFDistinction(F) by Def25
    .= card rng canGFDistinction(F) by CARD_1:70;
  S.numComponents() = G9.numComponents() by A2, GLIBPRE1:83;
  hence thesis by A3, Th68;
end;

theorem
  for F being non empty connected Graph-yielding Function,S being GraphSum of F
  holds card F = S.numComponents()
proof
  let F be non empty connected Graph-yielding Function, S be GraphSum of F;
  consider G9 being GraphUnion of rng canGFDistinction(F) such that
    A1: S is G9-Disomorphic by Def27;
  consider H being PGraphMapping of G9, S such that
    A2: H is Disomorphism by A1, GLIB_010:def 24;
  A3: card F = card dom F by CARD_1:62
    .= card dom canGFDistinction(F) by Def25
    .= card rng canGFDistinction(F) by CARD_1:70;
  S.numComponents() = G9.numComponents() by A2, GLIBPRE1:83;
  hence thesis by A3, Th69;
end;

begin :: The Sum of two Graphs

definition
  let G1, G2 be _Graph;
  mode GraphSum of G1, G2 -> Supergraph of G1 means
  :Def28:
  it is GraphSum of <* G1, G2 *>;
  existence
  proof
    1 in {1,2} by TARSKI:def 2;
    then reconsider z = 1 as Element of dom <* G1, G2 *> by FINSEQ_1:92;
    consider S being GraphSum of <* G1, G2 *> such that
      A1: S is Supergraph of <* G1, G2 *>.z and
      S is GraphUnion of rng canGFDistinction(<* G1, G2 *>,z) by Th123;
    reconsider S as Supergraph of G1 by A1, FINSEQ_1:44;
    take S;
    thus thesis;
  end;
end;

theorem Th128:
  for G1, G2 being _Graph, S being GraphSum of G1, G2 holds
    (G1 is loopless & G2 is loopless iff S is loopless) &
    (G1 is non-multi & G2 is non-multi iff S is non-multi) &
    (G1 is non-Dmulti & G2 is non-Dmulti iff S is non-Dmulti) &
    (G1 is simple & G2 is simple iff S is simple) &
    (G1 is Dsimple & G2 is Dsimple iff S is Dsimple) &
    (G1 is acyclic & G2 is acyclic iff S is acyclic) &
    (G1 is chordal & G2 is chordal iff S is chordal) &
    (G1 is edgeless & G2 is edgeless iff S is edgeless) &
    (G1 is loopfull & G2 is loopfull iff S is loopfull)
proof
  let G1, G2 be _Graph, S be GraphSum of G1, G2;
  1 in {1,2} & 2 in {1,2} by TARSKI:def 2;
  then A1: 1 in dom <* G1, G2 *> & 2 in dom <* G1, G2 *> by FINSEQ_1:92;
  A2: <* G1, G2 *>.1 = G1 & <* G1, G2 *>.2 = G2 by FINSEQ_1:44;
  A3: S is GraphSum of <* G1, G2 *> by Def28;
  :: loopless
  thus G1 is loopless & G2 is loopless implies S is loopless by A3;
  hereby
    assume S is loopless;
    then <* G1, G2 *> is loopless by A3;
    hence G1 is loopless & G2 is loopless by A1, A2;
  end;
  :: non-multi
  thus G1 is non-multi & G2 is non-multi implies S is non-multi by A3;
  hereby
    assume S is non-multi;
    then <* G1, G2 *> is non-multi by A3;
    hence G1 is non-multi & G2 is non-multi by A1, A2;
  end;
  :: non-Dmulti
  thus G1 is non-Dmulti & G2 is non-Dmulti implies S is non-Dmulti by A3;
  hereby
    assume S is non-Dmulti;
    then <* G1, G2 *> is non-Dmulti by A3;
    hence G1 is non-Dmulti & G2 is non-Dmulti by A1, A2;
  end;
  :: simple
  thus G1 is simple & G2 is simple implies S is simple by A3;
  hereby
    assume S is simple;
    then <* G1, G2 *> is simple by A3, Th124;
    hence G1 is simple & G2 is simple by A1, A2;
  end;
  :: Dsimple
  thus G1 is Dsimple & G2 is Dsimple implies S is Dsimple by A3;
  hereby
    assume S is Dsimple;
    then <* G1, G2 *> is Dsimple by A3, Th124;
    hence G1 is Dsimple & G2 is Dsimple by A1, A2;
  end;
  :: acyclic
  thus G1 is acyclic & G2 is acyclic implies S is acyclic by A3;
  hereby
    assume S is acyclic;
    then <* G1, G2 *> is acyclic by A3;
    hence G1 is acyclic & G2 is acyclic by A1, A2;
  end;
  :: chordal
  thus G1 is chordal & G2 is chordal implies S is chordal by A3, Th124;
  hereby
    assume S is chordal;
    then <* G1, G2 *> is chordal by A3, Th124;
    hence G1 is chordal & G2 is chordal by A1, A2;
  end;
  :: edgeless
  thus G1 is edgeless & G2 is edgeless implies S is edgeless by A3;
  hereby
    assume S is edgeless;
    then <* G1, G2 *> is edgeless by A3;
    hence G1 is edgeless & G2 is edgeless by A1, A2;
  end;
  :: loopfull
  thus G1 is loopfull & G2 is loopfull implies S is loopfull by A3;
  hereby
    assume S is loopfull;
    then <* G1, G2 *> is loopfull by A3;
    hence G1 is loopfull & G2 is loopfull by A1, A2;
  end;
end;

registration
  let G1, G2 be loopless _Graph;
  cluster -> loopless for GraphSum of G1, G2;
  coherence by Th128;
end;

registration
  let G1, G2 be non loopless _Graph;
  cluster -> non loopless for GraphSum of G1, G2;
  coherence;
end;

registration
  let G1, G2 be non-Dmulti _Graph;
  cluster -> non-Dmulti for GraphSum of G1, G2;
  coherence by Th128;
end;

registration
  let G1, G2 be non non-Dmulti _Graph;
  cluster -> non non-Dmulti for GraphSum of G1, G2;
  coherence;
end;

registration
  let G1, G2 be non-multi _Graph;
  cluster -> non-multi for GraphSum of G1, G2;
  coherence by Th128;
end;

registration
  let G1, G2 be non non-multi _Graph;
  cluster -> non non-multi for GraphSum of G1, G2;
  coherence;
end;

registration
  let G1, G2 be simple _Graph;
  cluster -> simple for GraphSum of G1, G2;
  coherence;
end;

registration
  let G1, G2 be Dsimple _Graph;
  cluster -> Dsimple for GraphSum of G1, G2;
  coherence;
end;

registration
  let G1, G2 be acyclic _Graph;
  cluster -> acyclic for GraphSum of G1, G2;
  coherence by Th128;
end;

registration
  let G1, G2 be non acyclic _Graph;
  cluster -> non acyclic for GraphSum of G1, G2;
  coherence;
end;

registration
  let G1, G2 be edgeless _Graph;
  cluster -> edgeless for GraphSum of G1, G2;
  coherence by Th128;
end;

registration
  let G1, G2 be non edgeless _Graph;
  cluster -> non edgeless for GraphSum of G1, G2;
  coherence;
end;

registration
  let G1, G2 be loopfull _Graph;
  cluster -> loopfull for GraphSum of G1, G2;
  coherence by Th128;
end;

registration
  let G1, G2 be non loopfull _Graph;
  cluster -> non loopfull for GraphSum of G1, G2;
  coherence by Th128;
end;

:: This is the two summands version and a corrolary
:: of the outcommented theorem above.
:: theorem Th147:
  :: for G1, G2 being _Graph, S being GraphSum of G1, G2
  :: ex G3 being _Graph
  :: st <* G1, G3 *> is vertex-disjoint edge-disjoint &
    :: G3 is G2-Disomorphic & S is GraphUnion of G1, G3 & S is GraphSum of G1, G3;

Lm6:
  for G1, G2 being _Graph
  for G9 being GraphUnion of rng canGFDistinction <* G1, G2 *>
  ex G3, G4 being _Graph
  st the_Edges_of G3 misses the_Edges_of G4 & G3 tolerates G4 &
    the_Vertices_of G3 misses the_Vertices_of G4 & G9 is GraphUnion of G3, G4 &
    G3 is G1-Disomorphic & G4 is G2-Disomorphic
proof
  let G1, G2 be _Graph;
  set F = <* G1, G2 *>;
  reconsider x = 1, y = 2 as Element of dom F by CALCUL_1:14;
  set R = rng canGFDistinction F;
  let G9 being GraphUnion of rng canGFDistinction F;
  A1: dom canGFDistinction F = dom F by Def25
    .= { x,y } by FINSEQ_1:92;
  then A2: x in dom canGFDistinction F & y in dom canGFDistinction F
    by TARSKI:def 2;
  then reconsider G3 = (canGFDistinction F).x, G4 = (canGFDistinction F).y
    as _Graph;
  take G3, G4;
  thus the_Edges_of G3 misses the_Edges_of G4 by A2, Def23;
  hence A3: G3 tolerates G4 by GLIB_014:12;
  thus the_Vertices_of G3 misses the_Vertices_of G4 by A2, Def22;
  A4: dom canGFDistinction F = Seg 2 by A1, FINSEQ_1:2;
  then reconsider p = canGFDistinction F as FinSequence by FINSEQ_1:def 2;
  len p = 2 by A4, FINSEQ_1:def 3;
  then p = <* G3,G4 *> by FINSEQ_1:44;
  then A5: rng p = { G3,G4 } by FINSEQ_2:127;
  then G3 in rng p by TARSKI:def 2;
  then G3 is Subgraph of G9 by GLIB_014:21;
  then G9 is Supergraph of G3 by GLIB_006:57;
  hence G9 is GraphUnion of G3, G4 by A3, A5, GLIB_014:def 26;
  A6: F.x = G1 & F.y = G2 by FINSEQ_1:44;
  hence G3 is G1-Disomorphic by A2, Th86;
  thus G4 is G2-Disomorphic by A2, A6, Th86;
end;

theorem
  for G1, G2 being _Graph, S being GraphSum of G1, G2
  holds S.order() = G1.order() +` G2.order()
proof
  let G1, G2 be _Graph, S be GraphSum of G1, G2;
  S is GraphSum of <* G1, G2 *> by Def28;
  then consider G9 being GraphUnion of rng canGFDistinction <* G1, G2 *>
    such that A1: S is G9-Disomorphic by Def27;
  consider H being PGraphMapping of G9, S such that
    A2: H is Disomorphism by A1, GLIB_010:def 24;
  consider G3, G4 being _Graph such that
    the_Edges_of G3 misses the_Edges_of G4 and
    A3: G3 tolerates G4 and
    A4: the_Vertices_of G3 misses the_Vertices_of G4 and
    A5: G9 is GraphUnion of G3, G4 and
    A6: G3 is G1-Disomorphic & G4 is G2-Disomorphic by Lm6;
  consider H1 being PGraphMapping of G1, G3 such that
    A7: H1 is Disomorphism by A6, GLIB_010:def 24;
  consider H2 being PGraphMapping of G2, G4 such that
    A8: H2 is Disomorphism by A6, GLIB_010:def 24;
  thus S.order() = G9.order() by A2, GLIB_010:84
    .= G3.order() +` G4.order() by A3, A4, A5, GLIBPRE1:120
    .= G1.order() +` G4.order() by A7, GLIB_010:84
    .= G1.order() +` G2.order() by A8, GLIB_010:84;
end;

theorem
  for G1, G2 being _Graph, S being GraphSum of G1, G2
  holds S.size() = G1.size() +` G2.size()
proof
  let G1, G2 be _Graph, S be GraphSum of G1, G2;
  S is GraphSum of <* G1, G2 *> by Def28;
  then consider G9 being GraphUnion of rng canGFDistinction(<* G1, G2 *>)
    such that A1: S is G9-Disomorphic by Def27;
  consider H being PGraphMapping of G9, S such that
    A2: H is Disomorphism by A1, GLIB_010:def 24;
  consider G3, G4 being _Graph such that
    A3: the_Edges_of G3 misses the_Edges_of G4 and
    A4: G3 tolerates G4 and
    the_Vertices_of G3 misses the_Vertices_of G4 and
    A5: G9 is GraphUnion of G3, G4 and
    A6: G3 is G1-Disomorphic & G4 is G2-Disomorphic by Lm6;
  consider H1 being PGraphMapping of G1, G3 such that
    A7: H1 is Disomorphism by A6, GLIB_010:def 24;
  consider H2 being PGraphMapping of G2, G4 such that
    A8: H2 is Disomorphism by A6, GLIB_010:def 24;
  thus S.size() = G9.size() by A2, GLIB_010:84
    .= G3.size() +` G4.size() by A4, A3, A5, GLIBPRE1:121
    .= G1.size() +` G4.size() by A7, GLIB_010:84
    .= G1.size() +` G2.size() by A8, GLIB_010:84;
end;

theorem
  for G1, G2 being _Graph, S being GraphSum of G1, G2
  holds S.numComponents() = G1.numComponents() +` G2.numComponents()
proof
  let G1, G2 be _Graph, S be GraphSum of G1, G2;
  S is GraphSum of <* G1, G2 *> by Def28;
  then consider G9 being GraphUnion of rng canGFDistinction(<* G1, G2 *>)
    such that A1: S is G9-Disomorphic by Def27;
  consider H being PGraphMapping of G9, S such that
    A2: H is Disomorphism by A1, GLIB_010:def 24;
  consider G3, G4 being _Graph such that
    the_Edges_of G3 misses the_Edges_of G4 and
    A3: G3 tolerates G4 and
    A4: the_Vertices_of G3 misses the_Vertices_of G4 and
    A5: G9 is GraphUnion of G3, G4 and
    A6: G3 is G1-Disomorphic & G4 is G2-Disomorphic by Lm6;
  consider H1 being PGraphMapping of G1, G3 such that
    A7: H1 is Disomorphism by A6, GLIB_010:def 24;
  consider H2 being PGraphMapping of G2, G4 such that
    A8: H2 is Disomorphism by A6, GLIB_010:def 24;
  thus S.numComponents() = G9.numComponents() by A2, GLIBPRE1:83
    .= G3.numComponents() +` G4.numComponents() by A3, A4, A5, GLIBPRE1:126
    .= G1.numComponents() +` G4.numComponents() by A7, GLIBPRE1:83
    .= G1.numComponents() +` G2.numComponents() by A8, GLIBPRE1:83;
end;
